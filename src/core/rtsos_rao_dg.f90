!NAME:            rtsos.f90
!RADIATION:       Vector 
!GEOMETRY:        Plane-parallel
!METHOD:          Successive order of scattering
!DETECTORS:       User Defined Position
!SCATTERING:      Multiple
!INTERFACE:       COX MUNK MODEL
!                 Pengwang Zhai
!DATE:            Mar 15 2009
!COMMENTS:        IF "TRUC_FLAG==.TRUE." AND THE INCORRECT SIMULATION, 
!                 CHECK INPUT FILE FOR THE CORRECT VALUE OF "FTRUNC"

!COMMENTS:        IF The radiance calculation at the forward direction 
!                 is not correct, increase the maximum order of M 
!                 to rerun 

!LINEXP=.TRUE.    ! USE THE LINEAR- EXPONENTIAL APPROXIMATION.
!                 THIS OPTION IS ALWAYS BETTER.

!DATE:            OCT 13 2009
!                 REVISED WATER LEAVING RADIANCE DETECTOR TO RECORD
!                 TOTAL IRRADIANCE INSTEAD OF WATER LEAVING IRRADIANCE.
! March 2 2010    Corrected a NAN problem found by Mike Garay. 
!                 (Exponential - linear approximation part)
! OCT 28 2011     SINGLE AND DOUBLE SCATTERING CORRECTION
! OCT 28 2011     CHANGE THE EXPONENTIAL - LINEAR APPROXIMATION COEFFICEINT
!                 TO BE ANGLE DEPENDENT

! SINGLE SCATTERING CORRECTION FOR ROUGH OCEAN SURFACE AND DETECTOR IN OCEAN 
! IS NOT IMPLEMENTED BECAUSE OF LARGE COMPUTATIONAL COST.
! Feb. 13, 2014 Fixed bug on ENGGLAREO, ADDED IF(DETO)ENGGLAREO=0 TO LINE 1067

! April 13, 2016, fixed a bug for sky light transmittance contribution for 
!                 ocean detector, only exist for rad_map=.true.
!                 this bug was introduced in a modification happened sometimes 
!                 between 09-03-2015 and 09-10-2015.
!                 The bug still exist in time-machine copies between
!                 09-10-2015 and 04-12-2016.
!                 The version after April 13 2016, 5:13 pm are correct.

! April 16, 2016, Fixed a bug for flat surface
! the bug was introduced during a revision since Dec. 09 2015.
! This bug still exist in time-machine copies between Dec. 09 2015 and April. 15. 2016.
! The version after April 16 2016 is correct.

! April 11 2019, set flato to be false by default to avoid conflict between lamb and flao.

! June 24 2020: added RSR0P to be the remote sensing reflectance at 0+ (just above water surface)
!                     RSR0P is used to simulate how a water leaving radiance propagate to TOA.
!                     RSR0P is combined with IPT=-101 option.

! June 03 2024: added -102 option to take in surface temperature and emissivity for ocean waters.
! June 03 2024: implementing thermal infrared radiative transfer

SUBROUTINE RTSOS(NREC,NDET,RECDATASTREAM,NCOLINPUT,NQUADAINPUT,NQUADOINPUT,      &
         DELTATAUAINPUT,DELTATAUOINPUT,NUMMIEINPUT,MAXLORDINPUT,MAXMORDINPUT,    &
         NUMMIEANGINPUT,PHMXDATASTREAM,MU_IN,NTHETAOUT,&
         NPHIOUT,PHIOUT,MUOUT,DIRAD,DSTOKES,WLR_FLAG_INPUT,WCFLG_INPUT,DELTAM_INPUT)
USE RTTYPE 
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE IRRADSUNL
USE SURFACE_GLINT
USE SnowBRDF
USE RossLiBRDF
implicit none

INTEGER, INTENT(IN) :: NREC,NDET,NCOLINPUT,NQUADAINPUT,NQUADOINPUT, &
                       NUMMIEINPUT,MAXLORDINPUT,MAXMORDINPUT
REAL*8, INTENT(IN) ::  DELTATAUAINPUT,DELTATAUOINPUT
REAL*8,INTENT(IN),DIMENSION(NREC,7) :: RECDATASTREAM
INTEGER,INTENT(IN),DIMENSION(NUMMIEINPUT) ::NUMMIEANGINPUT
REAL*8,INTENT(IN),DIMENSION(NUMMIEINPUT,NUMMIEANGMAX,0:6) :: PHMXDATASTREAM

INTEGER(I4B),INTENT(IN) :: NTHETAOUT,NPHIOUT
REAL*8, INTENT(IN) :: MU_IN
REAL*8,DIMENSION(NTHETAOUT), INTENT(IN) :: MUOUT
REAL*8,DIMENSION(NPHIOUT), INTENT(IN)  :: PHIOUT
REAL*8,DIMENSION(NDET,2), INTENT(OUT)  :: DIRAD  ! DIRAD(:,1) DOWNWELLING IRADIANCE
                                   ! DIRAD(:,2) UPWELLING IRADIANCE
REAL*8,DIMENSION(NDET,NTHETAOUT,NPHIOUT,4), INTENT(OUT) :: DSTOKES
LOGICAL,INTENT(IN) :: WLR_FLAG_INPUT,WCFLG_INPUT
INTEGER,INTENT(IN) :: DELTAM_INPUT

REAL*8 :: THETA_IN

REAL*8, EXTERNAL :: WHITECAP_REFLECTANCE
LOGICAL :: COARSE_LAYER_FLAG  ! IF SET TO .TRUE. USE DELTATAU_COARSE AS DELTATAU
                              ! FOR LAYERS BELOW TAU_COARSE_LIMIT
                              ! THIS IS MEANT TO INCREASE EFFICIENCY 
                              ! WHILE KEEPING ACCURACY FOR SOME LARGE OPTICAL DEPTH CASES
REAL*8 :: TAU_COARSE_LIMIT1,TAU_COARSE_LIMIT2,DELTATAU_COARSE1,DELTATAU_COARSE2

REAL(DP) :: X1,X2,RTMP,RTMP1,RTMP2,RTMP3,RTMP4,RTMP5,TAUTMP,&
            DELTATAUATMP,DELTATAUOTMP,COST1,COST2,SINT1,SINT2,MUSCAT

REAL(DP) :: THETA1,THETA2,MU0T,ENGREFL

INTEGER(I4B) :: IMIE,LORDER,I,L,M,N,ICOM,  &
      IQUAD,JQUAD,ICOL,ITAU,ITHETA,IPHI,IDTAU,IDTAUA,&
      IDTAUO,IALYR,IOLYR,ICOM1,MPLIN,NMUOUTSHFLA,NMUOUTSHFLO
             ! IMIE, LORDER ARE THE TEMPERARY VARIABLES
INTEGER(I4B),SAVE ::ICALNUM=0

REAL(DP),DIMENSION(:),ALLOCATABLE:: TAUDETA,TAUDETO
REAL(DP),DIMENSION(:),ALLOCATABLE:: ENGGLAREA,ENGGLAREO

REAL(DP),DIMENSION(4,4) :: MTRX1
REAL(DP),DIMENSION(4)   :: IRRAD,IRRAD_O,IRRAD_A,IRRAD_SNGL,IRRAD_O_SNGL,IRRAD_A_SNGL,&
                           ARRY1,ARRY2,ARRY3

REAL(DP),DIMENSION(4,4) :: FRES_MTRX  

REAL(DP),DIMENSION(:),ALLOCATABLE :: XJTMP,GAUWTTMP,MUOUTSHFLA,MUOUTSHFLO

										 
LOGICAL :: SGLNT,SOLAR_IRRAD_ABS_CAL
LOGICAL :: FLAG1,FLAG2,DIFF_FLG

REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADATMP,RADATMP1,RADOTMP,RADOTMP1,RADOUTTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADDETU,RADDETK

REAL*8,DIMENSION(:),ALLOCATABLE :: XJAD2,XJOD2

TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADATMP,LSPATMP,LRADATMP1,LSPATMP1
REAL*8,DIMENSION(:),ALLOCATABLE :: MUTMP

INTEGER :: NUMPHI,IPHI_TMP,IMU,MAXMLOCAL
REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP

integer time_array_0(8), time_array_1(8)
real start_time, finish_time

INTEGER,DIMENSION(1):: INTARR

INTERFACE

SUBROUTINE GETSDML(U)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

REAL(DP) :: U

END SUBROUTINE GETSDML

SUBROUTINE MUOUTSHUFFLE(NTHETAOUT,MUOUT,NMUOUTSHFLA,MUOUTSHFLA,&
                        NMUOUTSHFLO,MUOUTSHFLO)
INTEGER,INTENT(IN) :: NTHETAOUT
REAL*8,DIMENSION(NTHETAOUT),INTENT(IN) :: MUOUT

INTEGER,INTENT(OUT) :: NMUOUTSHFLA,NMUOUTSHFLO
REAL*8,DIMENSION(:),ALLOCATABLE :: MUOUTSHFLA,MUOUTSHFLO
ENDSUBROUTINE MUOUTSHUFFLE

END INTERFACE

ICALNUM=ICALNUM+1 ! number of calls to RTSOS
! ___________________________

WLR_FLAG=WLR_FLAG_INPUT ! OUTPUT WATER LEAVING RADIANCE IF DET IS IN AIR
WCFLG=WCFLG_INPUT     ! IF TRUE CONSIDER WHITE CAP (FOAM) COVERAGE PARAMETERIZATION
! USING TO WIND SPEED
!  THESE PARAMETERS ARE ADJUSTABLE FOR ACCURACY.
! ___________________________

DELTATAUA=DELTATAUAINPUT      ! ADJUST FOR ACCURATE OPTICAL INTEGRATION
DELTATAUO=DELTATAUOINPUT

DELTAM=DELTAM_INPUT

! DELTAM = 0 USE DELTA M FIT FOR THE PHASE MATRIX
!          1 USE DELTA M + FIT
!          2 USE DELTA FIT

MPLIN=3  ! DEFAULT ORDER OF POLYNOMIAL INTERPOLATION FOR RADIANCES

COARSE_LAYER_FLAG=.true.
TAU_COARSE_LIMIT1=3.0D0
TAU_COARSE_LIMIT2=6.0D0
DELTATAU_COARSE1=MAX(0.05D0,DELTATAUAINPUT,DELTATAUOINPUT)
DELTATAU_COARSE2=MAX(0.1D0,DELTATAUAINPUT,DELTATAUOINPUT)

! Start Reading from recdatastream

NLAYER=0
NALYR=0
NOLYR=0
NDTAUA=0
NDTAUO=0
I=0
N=0
OCEAN=.FALSE.
SAVE_RAMAN_FLAG=.FALSE.
SAVE_FLUORESCENCE_FLAG=.FALSE.
RAMAN_SOURCE_FLAG=.FALSE.
FLUORESCENCE_SOURCE_FLAG=.FALSE.
pBRDF=.false.
LAMB=.FALSE.
OCEAN_NO_TRAN=.false.
FLATO=.FALSE.
RSR0P=0.0D0
RSRADDFLG=.FALSE.

SURFACE_TEMPERATURE=0.0D0
SURFACE_EMISSIVITY=0.0D0

DETA=.FALSE.
DETO=.FALSE.

LOOP_READ_CONFIG : DO N=1,NREC
   I=RECDATASTREAM(N,1)
   RTMP=RECDATASTREAM(N,2)
   RTMP1=RECDATASTREAM(N,3)
   RTMP2=RECDATASTREAM(N,4)

   ! COUNTING DETECTOR NUMBERS
   IF(I==-1000) THEN
     IF(OCEAN .AND. OCEAN_NO_TRAN) &
         STOP 'ERROR: OCEAN DETECTOR WITH -101 INTERFACE'
     IF(OCEAN) THEN
          DETO=.TRUE.
          NDTAUO=NDTAUO+1
     ELSE
          DETA=.TRUE.
          NDTAUA=NDTAUA+1
     ENDIF
   ENDIF
   !TURN ON OCEAN FLAG IF AN OCEAN INTERFACE EXISTS
   IF(I==-100) THEN
      IF(OCEAN) STOP 'ERROR: -101 AND -100 COEXIST IN SOSI.DAT'
      OCEAN=.TRUE.

   ! AIR - SEA INTERFACE IS TREATED AS A LAYER.
      NLAYER=NLAYER+1
   ENDIF

   IF(I==-101 .or. I==-102) THEN
      IF(OCEAN) STOP 'ERROR: -101/-102 AND -100 COEXIST IN SOSI.DAT'
      OCEAN=.TRUE.
      OCEAN_NO_TRAN=.TRUE.
    ! AIR - SEA INTERFACE IS TREATED AS A LAYER.
      NLAYER=NLAYER+1
      IF(LAMB) STOP 'ERROR: 1 TWO SYSTEM BOTTOM ASSIGNED'
      IF(pBRDF) STOP 'ERROR: 1 TWO SYSTEM BOTTOM ASSIGNED'
      IF(fSnowBRDF) STOP 'ERROR: 1 TWO SYSTEM BOTTOM ASSIGNED'
      IF(fRossLiBRDF) STOP 'ERROR: both fRossLiBRDF and -101 SYSTEM BOTTOM ASSIGNED'

	EXIT LOOP_READ_CONFIG
   ENDIF

   ! MIE LAYERS, IPT HAS TO BE BIGGER THAN 0
   IF(I>0 .AND. .NOT.OCEAN ) THEN
      NALYR=NALYR+1
	  NLAYER=NLAYER+1
   ENDIF
   IF(I>0 .AND. OCEAN ) THEN
     NOLYR=NOLYR+1
     NLAYER=NLAYER+1
   ENDIF

   IF(I==-200) THEN
     NLAYER=NLAYER+1
     IF(OCEAN_NO_TRAN) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(pBRDF) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(fSnowBRDF) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(fRossLiBRDF) STOP 'Both fRossLiBRDF and Lamb SYSTEM BOTTOM ASSIGNED'
     LAMB=.TRUE.
     IF(N .NE. NREC) STOP 'CHECK NREC INPUT'
     EXIT LOOP_READ_CONFIG
   ENDIF

   IF(I==-201) THEN
     NLAYER=NLAYER+1
     IF(OCEAN_NO_TRAN) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(fSnowBRDF) STOP 'ERROR: 3 TWO SYSTEM BOTTOM ASSIGNED'
     IF(fRossLiBRDF) STOP 'both pBRDF and fRossLiBRDF SYSTEM BOTTOM ASSIGNED'
     IF(LAMB) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     pBRDF=.TRUE.
     OCEAN_NO_TRAN=.true.
     EXIT LOOP_READ_CONFIG
   ENDIF

   IF(I==-202) THEN
     NLAYER=NLAYER+1
     IF(OCEAN_NO_TRAN) STOP 'ERROR: 4 TWO SYSTEM BOTTOM ASSIGNED'
     IF(LAMB) STOP 'ERROR: 4 TWO SYSTEM BOTTOM ASSIGNED'
     IF(pBRDF) STOP 'ERROR: 4 TWO SYSTEM BOTTOM ASSIGNED'
     IF(fRossLiBRDF) STOP 'Error 4: both fSnowBRDF and fRossLiBRDF SYSTEM BOTTOM ASSIGNED'
     fSnowBRDF=.TRUE.
     OCEAN_NO_TRAN=.true.
     EXIT LOOP_READ_CONFIG
   ENDIF


	IF(I==-203) THEN
	  NLAYER=NLAYER+1
	  IF(OCEAN_NO_TRAN) STOP 'ERROR: 5 TWO SYSTEM BOTTOM ASSIGNED'
	  IF(LAMB) STOP 'ERROR: 5 TWO SYSTEM BOTTOM ASSIGNED'
	  IF(pBRDF) STOP 'ERROR: 5 TWO SYSTEM BOTTOM ASSIGNED'
	  IF(fSnowBRDF) STOP 'Error 5: both fSnowBRDF and fRossLiBRDF SYSTEM BOTTOM ASSIGNED'
	  fRossLiBRDF=.TRUE.
	  OCEAN_NO_TRAN=.true.
	  EXIT LOOP_READ_CONFIG
	ENDIF

ENDDO LOOP_READ_CONFIG

if(fSnowBRDF .and. LAMB)stop 'both fSnowBRDF .and. LAMB are true'
if(pBRDF .and. LAMB)stop 'both pBRDF .and. LAMB are true'
if(pBRDF .and. fSnowBRDF)stop 'both pBRDF .and. fSnowBRDF are true'


IF(NDET-NDTAUA-NDTAUO .NE. 0) STOP "NDET NOT EQUAL TO NDTAUA + NDTAUO"
ALLOCATE(ALYR(NALYR))
ALYR(1)%WAVELENGTH=0.0D0
IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) THEN
     PSEUDO_SPHERICAL_SHELL=.TRUE.
     SNG_RAD_CORR=.TRUE.
     FWDCN_CORR_FLAG=.FALSE.
ENDIF

ALLOCATE(HEIGHT_ATMOSPHERE(0:NALYR))
HEIGHT_ATMOSPHERE(NALYR)=0.0D0

ALLOCATE(SECANT_THETAL_PRSV(0:NALYR))
IF((.NOT.OCEAN) .AND. WLR_FLAG)STOP &
        'ERROR: WLR_FLAG = .TRUE. WHILE NO OCEAN'
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) )ALLOCATE(OLYR(NOLYR))

IF(DETA) THEN
  ALLOCATE(INDXDETA(NDTAUA),TAUDETA(NDTAUA),ENGGLAREA(NDTAUA),&
           INDXDETA_SNGSCAT(NDTAUA))
  ENGGLAREA=0.0D0
ENDIF
IF(DETO) ALLOCATE(INDXDETO(NDTAUO),TAUDETO(NDTAUO),&
                  ENGGLAREO(NDTAUO),INDXDETO_SNGSCAT(NDTAUO))

! read in atmospheric & ocean parameters
    !  TAU=0 FOR TOP OF THE ATMOSPHERE ASSUMED
    !  ALERT!!! TAUB HAS TO BE MONOTONICALLY INCREASING.
	!  0<=LBDOM<=1
IALYR=0
IOLYR=0
IDTAUA=0
IDTAUO=0
NTTAU = 1
TAUTMP=0
OCEAN=.FALSE.
DO M=1,NREC
   I=RECDATASTREAM(M,1)
   RTMP=RECDATASTREAM(M,2)
   RTMP1=RECDATASTREAM(M,3)
   RTMP2=RECDATASTREAM(M,4)
   RTMP3=RECDATASTREAM(M,5)
   RTMP4=RECDATASTREAM(M,6)
   RTMP5=RECDATASTREAM(M,7)

  IF(I==-1000) THEN
    IF (OCEAN) THEN
      IDTAUO=IDTAUO+1
      INDXDETO(IDTAUO)=NTTAU
      TAUDETO(IDTAUO)=TAUTMP
      INDXDETO_SNGSCAT(IDTAUO)=IOLYR
	ELSE
	  IDTAUA=IDTAUA+1
      INDXDETA(IDTAUA)=NTTAU
      TAUDETA(IDTAUA)=TAUTMP
      INDXDETA_SNGSCAT(IDTAUA)=IALYR
	ENDIF
  ENDIF
  
  IF(I>0 .AND. .NOT.OCEAN) THEN
    IALYR=IALYR+1
	ALYR(IALYR)%IPT=I
	ALYR(IALYR)%TAUB=TAUTMP
    TAUTMP=TAUTMP+RTMP
	ALYR(IALYR)%TAUT=TAUTMP
	ALYR(IALYR)%LBDOM=RTMP1
    ALYR(IALYR)%WAVELENGTH=RTMP2
    ALYR(IALYR)%TEMPERATURE=RTMP3
    HEIGHT_ATMOSPHERE(IALYR-1)=RTMP5

     DELTATAUATMP=DELTATAUA
     IF(COARSE_LAYER_FLAG .AND. TAUTMP>TAU_COARSE_LIMIT1) THEN
        DELTATAUATMP=DELTATAU_COARSE1
     ELSEIF(COARSE_LAYER_FLAG .AND. TAUTMP>TAU_COARSE_LIMIT2) THEN
        DELTATAUATMP=DELTATAU_COARSE2
     ENDIF

	 IF(DELTATAUATMP>RTMP/2.0D0)DELTATAUATMP=RTMP/2.0D0
     L=NINT(RTMP/DELTATAUATMP)
     IF(MOD(L,2)/=0)THEN
	    L=L+1
	    DELTATAUATMP=RTMP/DFLOAT(L)
	 ENDIF

    ALYR(IALYR)%ITAUS=NTTAU
    ALYR(IALYR)%NTAU=NINT(RTMP/DELTATAUATMP)
    IF(MOD(ALYR(IALYR)%NTAU,2)/=0) &
	  ALYR(IALYR)%NTAU=ALYR(IALYR)%NTAU+1

    NTTAU=NTTAU+ALYR(IALYR)%NTAU

    IF(IALYR==NALYR) THEN
      ALYR(IALYR)%ITAUE=NTTAU
    ELSE
      ALYR(IALYR)%ITAUE=NTTAU-1
    ENDIF
  ENDIF

  IF(I>0 .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) THEN
    IOLYR=IOLYR+1
    OLYR(IOLYR)%IPT=I

    OLYR(IOLYR)%TAUB=TAUTMP
    TAUTMP=TAUTMP+RTMP
    OLYR(IOLYR)%TAUT=TAUTMP
    OLYR(IOLYR)%LBDOM=RTMP1
    OLYR(IOLYR)%WAVELENGTH=RTMP2
    OLYR(IOLYR)%TEMPERATURE=RTMP3
    DELTATAUOTMP=DELTATAUO

    IF(COARSE_LAYER_FLAG .AND. TAUTMP>TAU_COARSE_LIMIT1)THEN
           DELTATAUOTMP=DELTATAU_COARSE1
    ELSEIF(COARSE_LAYER_FLAG .AND. TAUTMP>TAU_COARSE_LIMIT2)THEN
       DELTATAUOTMP=DELTATAU_COARSE2
    ENDIF

	IF(DELTATAUOTMP>RTMP/2.0D0)DELTATAUOTMP=RTMP/2.0D0
          L=NINT(RTMP/DELTATAUOTMP)
    IF(MOD(L,2)/=0)THEN
	   L=L+1
	   DELTATAUOTMP=RTMP/DFLOAT(L)
	ENDIF

    OLYR(IOLYR)%ITAUS=NTTAU
    OLYR(IOLYR)%NTAU=NINT(RTMP/DELTATAUOTMP)
    IF(MOD(OLYR(IOLYR)%NTAU,2)/=0) &
	  OLYR(IOLYR)%NTAU=OLYR(IOLYR)%NTAU+1
    NTTAU=NTTAU+OLYR(IOLYR)%NTAU

    IF(IOLYR==NOLYR) THEN
      OLYR(IOLYR)%ITAUE=NTTAU
    ELSE
      OLYR(IOLYR)%ITAUE=NTTAU-1
    ENDIF
	
	OLYR(IOLYR)%EFLRSC=RTMP4
    IF(OLYR(IOLYR)%EFLRSC==1 .AND. IOLYR==1) SAVE_RAMAN_FLAG=.TRUE.
    IF(OLYR(IOLYR)%EFLRSC==2 .AND. IOLYR==1) RAMAN_SOURCE_FLAG=.TRUE.

    IF(OLYR(IOLYR)%EFLRSC==3 .AND. IOLYR==1) SAVE_FLUORESCENCE_FLAG=.TRUE.
    IF(OLYR(IOLYR)%EFLRSC==4 .AND. IOLYR==1) FLUORESCENCE_SOURCE_FLAG=.TRUE.
    IF(OLYR(IOLYR)%EFLRSC==5 .AND. IOLYR==1) THEN
        RAMAN_SOURCE_FLAG=.TRUE.
        FLUORESCENCE_SOURCE_FLAG=.TRUE.
    ENDIF

    IF(OLYR(IOLYR)%EFLRSC==6 .AND. IOLYR==1) THEN
        SAVE_RAMAN_FLAG=.TRUE.
        SAVE_FLUORESCENCE_FLAG=.TRUE.
    ENDIF

    IF(OLYR(IOLYR)%EFLRSC==7 .AND. IOLYR==1) THEN
        SAVE_RAMAN_FLAG=.TRUE.
        SAVE_FLUORESCENCE_FLAG=.TRUE.
        RAMAN_SOURCE_FLAG=.TRUE.
        FLUORESCENCE_SOURCE_FLAG=.TRUE.
    ENDIF

  ENDIF

  IF(I==-100) THEN
    IF(OCEAN)STOP 'ERROR: MULTIPLE AIR-SEA INTERFACE'
    OCEAN=.TRUE.
	NTTAU=NTTAU+1
	OITAU=TAUTMP+TINY2
	TAUTMP=TAUTMP+2.0D0*TINY2
	WNDSPD=RTMP
	NWRE=RTMP1
	NWIM=RTMP2
    IF(NWRE<=1.0d0)stop 'check nmre'
    NRELRE=NWRE/(NWRE*NWRE+NWIM*NWIM)
    NRELIM=-NWIM/(NWRE*NWRE+NWIM*NWIM)
	NSQW=NWRE*NWRE
    NSQA=1.0D0/NWRE/NWRE

    IF(ABS(RTMP3)<1.0E-6) THEN
        SGLNT=.true.        ! SUN GLINT SWITCH
    ELSE
        SGLNT=.FALSE.        ! SUN GLINT SWITCH
    ENDIF

  ENDIF

  IF(I==-101 .or. I==-102) THEN
    IF(OCEAN)STOP 'ERROR: MULTIPLE AIR-SEA INTERFACE'
    OCEAN=.TRUE.
	NTTAU=NTTAU+1
	OITAU=TAUTMP
	TOTALTAU=OITAU
	WNDSPD=RTMP
	NWRE=RTMP1
	NWIM=RTMP2

    IF(NWRE<=1.0d0)stop 'check nmre'
    NRELRE=NWRE/(NWRE*NWRE+NWIM*NWIM)
    NRELIM=-NWIM/(NWRE*NWRE+NWIM*NWIM)
	NSQW=NWRE*NWRE
    NSQA=1.0D0/NWRE/NWRE

	IF(ABS(RTMP3)<1.0E-6) THEN
	   SGLNT=.true.        ! SUN GLINT SWITCH
	ELSE
	   SGLNT=.FALSE.        ! SUN GLINT SWITCH
	ENDIF

    IF(I==-101) THEN
		RSR0P=RTMP4
		IF(RSR0P>0.0D0) RSRADDFLG=.TRUE.
	ENDIF

	IF(I==-102) THEN
		SURFACE_TEMPERATURE=RTMP4
		SURFACE_EMISSIVITY=RTMP5
	ENDIF


  ENDIF

  IF(I== -200)THEN
     TOTALTAU=TAUTMP
     GLBDO=RTMP
     FLAM=RTMP1
     NMBRE=RTMP2
     NMBIM=RTMP3
     SURFACE_TEMPERATURE=RTMP4
     SURFACE_EMISSIVITY=1.0d0-RTMP !RTMP5
     IF(NMBRE<=1.0d0 .or. NMBRE>2.0d0)stop 'check nmbre'
     IF(OCEAN .AND. FLAM<1.0D0) &
	   STOP 'ERROR: MIXING LAMBERT AND SPECULAR REFLECTION &
	        &IS NOT SUPPORTED FOR OCEAN BOTTOM'
  ENDIF

  IF(I== -201)THEN
     TOTALTAU=TAUTMP
     pBRDFa=RTMP
     pBRDFk=RTMP1
     pBRDFb=RTMP2
     pBRDFe=RTMP3
     NMBRE=RTMP4
     NMBIM=RTMP5
     IF(NMBRE<=1.0d0 .or. NMBRE>2.0d0)stop 'check nmbre in pBRDF option'
  ENDIF

  IF(I== -202)THEN
     TOTALTAU=TAUTMP
     GLBDO=RTMP
  ENDIF

  IF(I== -203)THEN
     TOTALTAU=TAUTMP
     fiso=RTMP
     fvol=RTMP1
     fgeo=RTMP2
     Bpol=RTMP3
     NMBRE=RTMP4
     NMBIM=RTMP5
     IF(NMBRE<=1.0d0 .or. NMBRE>2.0d0)stop 'check nmbre in Ross-Li option'
  ENDIF

ENDDO

IF(OCEAN)THEN
  IF(I_SURFACE_ROUGHNESS_PARA==1)THEN
	  SIGMASQ=0.003D0+0.00512D0*WNDSPD   ! COX&MUNK 1954
  ELSEIF(I_SURFACE_ROUGHNESS_PARA==2)THEN
	  SIGMASQ=0.00534D0*WNDSPD   ! GORDON&WANG AO, 1992
  ELSE
	  STOP 'I_SURFACE_ROUGHNESS_PARA IS NOT INITIALIZED'
  ENDIF

  IF(WNDSPD<0.5D0) THEN
     FLATO=.TRUE.
  ELSE
     FLATO=.FALSE.
  ENDIF
ENDIF
IF(FLATO .OR. pBRDF .OR. fSnowBRDF .or. fRossLiBRDF)THEN
   ENORM_FLAT=.FALSE. ! TURN OFF ENORM_FLAT IF FLAT OCEAN SURFACE IS PRESENT
   ENGFACNORM=.FALSE.
   DOUBLE_GAUSSIAN_QUAD=.TRUE.
ENDIF

IF(DIFFUSE_TRANSMITTANCE)THEN
  IF(.NOT.LAMB)STOP 'DIFFUSE TRANSMITTANCE CALCULATION NEED A LAMBERTIAN BOTTOM'
!  IF(.NOT.OCEAN)STOP 'DIFFUSE TRANSMITTANCE OPTION IS DISIGNED FOR OCEAN'
ENDIF
!WRITE(*,"('TOTAL TAU OF THE SYSTEM=',ES13.6)")TOTALTAU
!IF(LAMB) THEN
!   WRITE(*,"('GROUND ALBEDO=',ES13.6)")GLBDO
!   IF(FLAM<1.0D0) THEN
!     WRITE(*,"('FRACTION OF LAMBERT SCATTERING =',ES13.6)") FLAM
!     WRITE(*,"('BOTTOM COMPLEX REFRACTIVE INDEX =',2(1X,ES13.6))") &
!	                NMBRE,NMBIM
!   ENDIF
!ENDIF
IF(ENORM_FLAT .AND. ENGFACNORM) &
        STOP 'ENORM_FLAT .AND. ENGFACNORM CANNOT BE BOTH TRUE'

! DON'T CHANGE THESE OPTIONS IN BETWEEN ####
IF(WLR_FLAG) THEN
  RAD_MAP=.TRUE.
  SGLNT=.FALSE.
ENDIF
IF(SEC_RAD_CORR) THEN
  SNG_RAD_CORR=.TRUE.
ENDIF
IF(RAD_MAP)  SNG_RAD_CORR=.TRUE.

IF(DIFFUSE_TRANSMITTANCE)THEN
  WRITE(*,*)'WARNING, DIFFUSE TRANSMITTANCE CALCULATION'
  SNG_RAD_CORR=.FALSE.
  SEC_RAD_CORR=.FALSE.
  RAD_MAP=.FALSE.
  SGLNT=.FALSE.
  SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION=.false.
ENDIF

! DON'T CHANGE THESE OPTIONS IN BETWEEN ####


IF(OCEAN .AND. (ENORM_FLAT .OR. ENGFACNORM)) CALL REFL_TRAN_COXMUNK
SOLAR_IRRAD_ABS_CAL=RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG &
                .OR. (ALYR(1)%WAVELENGTH>3.0D0)
IF(SOLAR_IRRAD_ABS_CAL) THEN
   CALL FSUNCAL(ALYR(1)%WAVELENGTH,ESUN(1))
ENDIF
IF(ALYR(1)%WAVELENGTH>=15.0D0 .OR. NIGHTTIME_FLAG) ESUN(1)=0.0D0

!write(*,*)ALYR(1)%WAVELENGTH,ESUN(1)
NCOL=NCOLINPUT

CALL MUOUTSHUFFLE(NTHETAOUT,MUOUT,NMUOUTSHFLA,MUOUTSHFLA,&
                  NMUOUTSHFLO,MUOUTSHFLO)

IF(PSEUDO_VIEWING_QUAD)THEN
  NQUADA=NQUADAINPUT+NMUOUTSHFLA
  NQUADO=NQUADOINPUT+NMUOUTSHFLO
  RAD_MAP=.false.
ELSE
  NQUADA=NQUADAINPUT+2
  NQUADO=NQUADOINPUT+2
ENDIF

IF(NCOL<3)THEN
	GEOSR=.FALSE.
	RAD_MAP=.FALSE.
ENDIF

IF(RAMAN_SOURCE_FLAG .AND. OCEAN_NO_TRAN) STOP 'RAMAN HAS TO COME WITH OCEAN CALCULATION'
IF(RAMAN_SOURCE_FLAG .AND. (.NOT. OCEAN)) STOP 'RAMAN IS FOR OCEAN SCENE ONLY'

IF(FLUORESCENCE_SOURCE_FLAG .AND. OCEAN_NO_TRAN) STOP 'FCDOM HAS TO COME WITH OCEAN CALCULATION'
IF(FLUORESCENCE_SOURCE_FLAG .AND. (.NOT. OCEAN)) STOP 'FCDOM IS FOR OCEAN SCENE ONLY'

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  NQUADSO=NQUADO
  NQUADDIF = NQUADOINPUT - NQUADAINPUT
  IF(NQUADDIF<0)STOP 'ERROR: QUADRATURE NUMBER OCEAN < ATMOSPEHRE'
  IF(MOD(NQUADDIF,2)/=0) THEN
    NQUADDIF=NQUADDIF+1
    NQUADO=NQUADA+NQUADDIF
!    WRITE(*,*)'NQUADO WAS ADJUSTED TO MAKE NQUADDIF EVEN'
!    WRITE(*,*)'NQUADA,NQUADO=',NQUADA,NQUADO
  ENDIF
  NQDOD2=NQUADO/2
!  WRITE(9,"('NCOL=',I8,2x,'NQUADA=',I5,2x,'NQUADO=',I5)") &
!             NCOL,NQUADA-2,NQUADO-2
!ELSE
!  WRITE(9,"('NCOL=',I8,2x,'NQUADA=',I5)") NCOL,NQUADA-2
ENDIF

NQDAD2=NQUADA/2

IMIE=ALYR(1)%IPT
DO I=1,NALYR
  IF(ALYR(I)%IPT>IMIE)IMIE=ALYR(I)%IPT
ENDDO
DO I=1,NOLYR
IF(OLYR(I)%IPT>IMIE)IMIE=OLYR(I)%IPT
ENDDO
IF(IMIE>NUMMIEINPUT)STOP 'MAX IPT INPUT IS LARGER THAN NUMMIE'

!READ(1,*) NUMMIE,MAXLORD,MAXMORD
NUMMIE=NUMMIEINPUT
MAXLORD=MAXLORDINPUT
MAXMORD=MAXMORDINPUT

IF(VERBOSE_FLAG) THEN
  call date_and_time(values=time_array_0)
  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)
ENDIF

IF(PHMX_COEFF_EXT_UNASSIGN_FLAG)THEN
	CALL PHMX_COEFF_ALLO(MAXLORD,NUMMIEINPUT,NUMMIEANGINPUT)
	CALL PHMX_ASSIGN(NUMMIEINPUT,NUMMIEANGINPUT,PHMXDATASTREAM)
	CALL DELTAFIT
    IF(SEC_RAD_CORR) CALL FULLBETAL_INIT
ENDIF

IF(SEC_RAD_CORR) CALL DBLE_SCAT_INIT

IF(VERBOSE_FLAG) THEN
	call date_and_time(values=time_array_0)
	  finish_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
			   + time_array_0 (7) + 0.001 * time_array_0 (8)

	write(*,*)'deltafit elapsed time =', finish_time-start_time
ENDIF

IF(FLATO .AND. WCFLG) WCFLG=.FALSE.

IF((.NOT.OCEAN) .AND. WCFLG) WCFLG=.FALSE.

IF(pBRDF .OR. fSnowBRDF .or. fRossLiBRDF )WCFLG=.FALSE.
IF(OCEAN .AND. WCFLG)THEN
   FWC=2.95D-6*WNDSPD**3.52D0  ! Koepke (1985), also EQUATION (3), FRASER, JGR, 1997.
!  WCLBDO=0.22D0               ! VALUE OBTAINED IN FRASER, JGR, 1997.
!	IF(WNDSPD<6.33D0)THEN                ! Private communication with Sean Bailey and Amir Ibrahim
!		FWC=0.0D0
!	ELSE IF (WNDSPD<12.0D0)THEN
!		FWC=8.75E-5*(WNDSPD-6.33D0)**3   ! Stramska and Petelski, 2003.
!	ELSE IF(WNDSPD>12.0D0)THEN
!		FWC=8.75E-5*(12.0D0-6.33D0)**3
!	ENDIF
	WCLBDO=WHITECAP_REFLECTANCE(ALYR(1)%WAVELENGTH)

!  FWC and WCLBDO can be changed to 1.0 or 0.0 to do sanity check versus lambertian bottom
!  uncomment the following two lines to check white cap correction with Coulson 's table
!  to test white cap correction, 
!  set lambertian bottom albedo = 0.66666666
!  set white cap albedo = 0.6666666
!  turn white cap flag on
!  set very thin conservative ocean
!  set white cap fraction 1
!  compare with Coulson with bottom albedo 0.8 because
!  0.8=2*0.666666666/(1+0.66666666666)

 !  FWC=1.0D0
 !  WCLBDO=0.66666666666D0
!  FWC=1.0D0
!  WCLBDO=1.0D0

ENDIF

IF(OSFREXP .AND. OCEAN .AND. (.NOT. FLATO))THEN
  IF(OCEAN_NO_TRAN)STOP 'SET OSFREXP=.FALSE. FOR -101'
  OPEN(unit=1,file='fresnel_refaw.coeff',status='OLD')
  DO I=1,6
     READ(1,*) 
  ENDDO
  READ(1,*)RTMP,MAXSORD
  MAXKORD=MAXSORD+MAXMORD
  ALLOCATE(WBETAL(2,0:MAXSORD),WALPHAL(2,0:MAXSORD),   &
           WZETAL(2,0:MAXSORD),WDELTAL(2,0:MAXSORD),   &
           WGAMMAL(2,0:MAXSORD),WEPSILONL(2,0:MAXSORD))
  CLOSE(1)

  DO IMIE=1,2
    IF(IMIE==1)THEN
     ! I==1 light incident from air to water, reflectance
      OPEN(unit=1,file='fresnel_refaw.coeff',status='OLD')  
    ELSEIF(IMIE==2)THEN
 ! I==2 light incident from air to water, transmittance
      OPEN(unit=1,file='fresnel_tranaw.coeff',status='OLD')  
    ENDIF
    DO I=1,6
      READ(1,*) 
    ENDDO
    READ(1,*)RTMP,LORDER
    IF(LORDER>MAXSORD) STOP 'ERRRO: CHECK NUMSORD INPUT'
    READ(1,*)
	READ(1,*)
	DO I=0,LORDER
      READ(1,*)L,WBETAL(IMIE,I),WALPHAL(IMIE,I),WZETAL(IMIE,I), &
               WDELTAL(IMIE,I),WGAMMAL(IMIE,I),WEPSILONL(IMIE,I)
	!NO MISHCHENKO CONVENTION CHANGES HERE.
	!BECAUSE THIS PART IS NOT SUPPOSED TO BE CHANGED BY USERS
    ENDDO
    CLOSE(1)
  ENDDO
ELSE
  MAXSORD=MAXMORD
  MAXKORD=MAXMORD
ENDIF

IF(SCL)THEN
  ALPHAL=0.0D0
  ZETAL=0.0D0
  DELTAL=0.0D0
  GAMMAL=0.0D0
  EPSILONL=0.0D0
  IF(OSFREXP .AND. OCEAN) THEN
    WALPHAL=0.0D0
    WZETAL=0.0D0
    WDELTAL=0.0D0
    WGAMMAL=0.0D0
    WEPSILONL=0.0D0
  ENDIF
ENDIF

THETA_IN=ACOS(MU_IN)

ALLOCATE(XJA(NQUADA),WTA(NQUADA))
IF(OCEAN)THEN
  IF(FLATO) ALLOCATE(FRSNLAR(NQDAD2,4,4))
  IF((.NOT. OCEAN_NO_TRAN) .AND. FLATO) &
    ALLOCATE(FRSNLWR(NQDOD2+1:NQUADO,4,4), &
		     FRSNLAT(NQDAD2,4,4),          &
		     FRSNLWT(NQDOD2+1:NQUADO,4,4))
  IF(.NOT. OCEAN_NO_TRAN) ALLOCATE(XJO(NQUADO),WTO(NQUADO))
ENDIF

X1=0.0d0
X2=1.0d0

ALLOCATE(XJTMP(NQUADAINPUT/2),GAUWTTMP(NQUADAINPUT/2))
CALL gauleg(X1,X2,XJTMP,GAUWTTMP,NQUADAINPUT/2)

IF(PSEUDO_VIEWING_QUAD)THEN
  DO IQUAD=1,NQUADAINPUT/2
! GAUSSIAN QUADRATURE AND WEIGHT IN ATMOSPHERE
    XJA(IQUAD)=-XJTMP(NQUADAINPUT/2-IQUAD+1)
    XJA(NQUADAINPUT-IQUAD+1)=-XJA(IQUAD)
    WTA(IQUAD)=GAUWTTMP(NQUADAINPUT/2-IQUAD+1)
    WTA(NQUADAINPUT-IQUAD+1)=WTA(IQUAD)
  ENDDO

  DO IQUAD=NQUADAINPUT+1,NQUADA
     XJA(IQUAD)=MUOUTSHFLA(IQUAD-NQUADAINPUT)
     WTA(IQUAD)=0.0D0
  ENDDO

  CALL sort2(NQUADA,XJA,WTA)
ELSE
  XJA(1)=-1.0D0
  WTA(1)=0.0D0
  XJA(NQUADA)=1.0D0
  WTA(NQUADA)=0.0D0
  DO IQUAD=1,NQDAD2-1
    JQUAD=IQUAD+1
! GAUSSIAN QUADRATURE AND WEIGHT IN ATMOSPHERE 
    XJA(JQUAD)=-XJTMP(NQDAD2-IQUAD)
    XJA(NQUADA-JQUAD+1)=-XJA(JQUAD)
    WTA(JQUAD)=GAUWTTMP(NQDAD2-IQUAD)
    WTA(NQUADA-JQUAD+1)=WTA(JQUAD)
  ENDDO

ENDIF
DEALLOCATE(XJTMP,GAUWTTMP)

! GAUSSIAN QUADRATURE AND WEIGHT IN OCEAN
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN

 IF(DOUBLE_GAUSSIAN_QUAD)THEN
  JQUAD=0
  DO IQUAD=1,NQDAD2
    IF(WTA(IQUAD)<1.0D-64)CYCLE
    JQUAD=JQUAD+1
    THETA1=PI-DACOS(XJA(IQUAD))
    RTMP=SIN(THETA1)/NWRE
    RTMP=COS(ASIN(RTMP))
    XJO(JQUAD)=-RTMP
    WTO(JQUAD)=WTA(IQUAD)*                     &
         DABS(XJA(IQUAD)/XJO(JQUAD))/NWRE/NWRE
    XJO(NQUADAINPUT-JQUAD+1)=-XJO(JQUAD)
    WTO(NQUADAINPUT-JQUAD+1)=WTO(JQUAD)
  ENDDO

  ALLOCATE(XJTMP(NQUADDIF/2),GAUWTTMP(NQUADDIF/2))
  X1=-COS(ASIN(1.0D0/NWRE))
  X2=0.0d0
  call gauleg(X1,X2,XJTMP,GAUWTTMP,NQUADDIF/2)

  DO IQUAD=1,NQUADDIF/2
    XJO(IQUAD+NQUADAINPUT)=XJTMP(IQUAD)
    XJO(NQUADDIF - IQUAD + 1 + NQUADAINPUT) = - XJO(IQUAD+NQUADAINPUT)

    WTO(IQUAD+NQUADAINPUT)=GAUWTTMP(IQUAD)
    WTO(NQUADDIF - IQUAD + 1 + NQUADAINPUT)=WTO(IQUAD+NQUADAINPUT)
  ENDDO
  DEALLOCATE(XJTMP,GAUWTTMP)
 ELSE

  X1=0.0d0
  X2=1.0d0
  ALLOCATE(XJTMP(NQUADOINPUT/2),GAUWTTMP(NQUADOINPUT/2))
  CALL gauleg(X1,X2,XJTMP,GAUWTTMP,NQUADOINPUT/2)
  DO IQUAD=1,NQUADOINPUT/2
! GAUSSIAN QUADRATURE AND WEIGHT IN OCEAN
    XJO(IQUAD)=-XJTMP(NQUADOINPUT/2-IQUAD+1)
    XJO(NQUADOINPUT-IQUAD+1)=-XJO(IQUAD)
    WTO(IQUAD)=GAUWTTMP(NQUADOINPUT/2-IQUAD+1)
    WTO(NQUADOINPUT-IQUAD+1)=WTO(IQUAD)
  ENDDO
 ENDIF
 ALLOCATE(XJOD2(NQDOD2),XJAD2(NQDAD2))
 IF(PSEUDO_VIEWING_QUAD)THEN
    DO IQUAD=NQUADOINPUT+1,NQUADO
       XJO(IQUAD)=MUOUTSHFLO(IQUAD-NQUADOINPUT)
       WTO(IQUAD)=0.0D0
    ENDDO
 ELSE
    XJO(NQUADOINPUT+1)=-1.0D0
    WTO(NQUADOINPUT+1)=0.0D0
    XJO(NQUADOINPUT+2)=1.0D0
    WTO(NQUADOINPUT+2)=0.0D0
 ENDIF
 CALL sort2(NQUADO,XJO,WTO)

ENDIF

!DO IQUAD=1,NQUADA
!WRITE(*,*)'XQUADA',XJA(IQUAD),WTA(IQUAD)
!ENDDO
!DO IQUAD=1,NQUADO
!WRITE(*,*)'XQUADO',XJO(IQUAD),WTO(IQUAD)
!ENDDO


IF(FLATO)THEN
  DO IQUAD=1,NQDAD2
    THETA1=PI-ACOS(XJA(IQUAD))
!    THETA2=THETA1
    CALL FRSNL_R2(NWRE,NWIM,THETA1,MTRX1)
    FRSNLAR(IQUAD,:,:)=MTRX1(:,:)
  ENDDO

  IF(.NOT. OCEAN_NO_TRAN)THEN
    DO IQUAD=1,NQDAD2
      THETA1=PI-ACOS(XJA(IQUAD))
      CALL FRSNL_T2(NWRE,NWIM,THETA1,MTRX1)
      FRSNLAT(IQUAD,:,:)=MTRX1(:,:)
    ENDDO

    DO IQUAD=NQDOD2+1,NQUADO
      THETA1=ACOS(XJO(IQUAD))
      CALL FRSNL_R2(NRELRE,NRELIM,THETA1,MTRX1)
      FRSNLWR(IQUAD,:,:)=MTRX1(:,:)
      CALL FRSNL_T2(NRELRE,NRELIM,THETA1,MTRX1)
      FRSNLWT(IQUAD,:,:)=MTRX1(:,:)
    ENDDO
  ENDIF
ENDIF ! FLATO IF

IF(LAMB .AND. FLAM<1.0D0) THEN
  GLBDO=GLBDO*FLAM
  ALLOCATE(FRSNLMBR(NQUADA,4,4))
  DO IQUAD=1,NQDAD2
      THETA1=PI-ACOS(XJA(IQUAD))
      CALL FRSNL_R2(NMBRE,NMBIM,THETA1,MTRX1)
      FRSNLMBR(IQUAD,:,:)=MTRX1(:,:)*(1.0D0-FLAM)
  ENDDO
ENDIF

ALLOCATE(BT_Planck(NALYR))
CALL BT_Planck_INIT

ALLOCATE(TAU(NTTAU),TAU_PRSV(NTTAU),LBDO_A_PRSV(NALYR),LBDO_O_PRSV(NOLYR))
ALLOCATE(COEFALDW(NTTAU),COEFALUP(NTTAU))
ALLOCATE(SECANT_THETAL(ALYR(NALYR)%ITAUE))

! ___ATMOSPHERE CONFIGRATION____
CALL ATMOS_OCEAN_CONFIG

ALLOCATE(DTAUMUADW(ALYR(NALYR)%ITAUE,NQUADA),   &
         DTAUMUAUP(ALYR(NALYR)%ITAUE,NQUADA),   &
		 EXPTAUADW(ALYR(NALYR)%ITAUE,NQUADA),   &
		 EXPTAUAUP(ALYR(NALYR)%ITAUE,NQUADA) )
DO IQUAD=1,NQUADA
 DO ITAU=ALYR(1)%ITAUS+1,ALYR(NALYR)%ITAUE
   DTAUMUADW(ITAU,IQUAD)=   &
       0.5D0*(TAU(ITAU)-TAU(ITAU-1))/DABS(XJA(IQUAD))
   EXPTAUADW(ITAU,IQUAD)=   &
       EXP(-(TAU(ITAU)-TAU(ITAU-1))/DABS(XJA(IQUAD)))
 ENDDO

 DO ITAU=ALYR(NALYR)%ITAUE-1,ALYR(1)%ITAUS,-1
   DTAUMUAUP(ITAU,IQUAD)=  &
	   0.5D0*DABS((TAU(ITAU+1)-TAU(ITAU))/(XJA(IQUAD)))
   EXPTAUAUP(ITAU,IQUAD)=  &
       EXP(-DABS(TAU(ITAU+1)-TAU(ITAU))/DABS(XJA(IQUAD)))
 ENDDO
ENDDO

IF(DETA) THEN
  ALLOCATE(INDXREVA(ALYR(NALYR)%ITAUE))
  INDXREVA=-1
  DO IDTAUA=1,NDTAUA
    IF(INDXDETA(IDTAUA)>ALYR(NALYR)%ITAUE) STOP 'ERROR: CHECK INDXDETA'
       INDXREVA(INDXDETA(IDTAUA))=IDTAUA
  ENDDO
ENDIF
! ___ATMOSPHERE CONFIGRATION OVER____

! ___OCEAN CONFIGRATION____
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  ALLOCATE(DTAUMUODW(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,NQUADO), &
         DTAUMUOUP(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,NQUADO),   &
		 EXPTAUODW(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,NQUADO),   &
		 EXPTAUOUP(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,NQUADO) )
  DO IQUAD=1,NQUADO
    DO ITAU=OLYR(1)%ITAUS+1,OLYR(NOLYR)%ITAUE
     DTAUMUODW(ITAU,IQUAD)= &
          0.5D0*(TAU(ITAU)-TAU(ITAU-1))/DABS(XJO(IQUAD))
     EXPTAUODW(ITAU,IQUAD)= &
          EXP(-(TAU(ITAU)-TAU(ITAU-1))/DABS(XJO(IQUAD)))
    ENDDO

    DO ITAU=OLYR(NOLYR)%ITAUE-1,OLYR(1)%ITAUS,-1
      DTAUMUOUP(ITAU,IQUAD)=  &
            0.5D0*DABS((TAU(ITAU+1)-TAU(ITAU))/(XJO(IQUAD)))
      EXPTAUOUP(ITAU,IQUAD)=  &
            EXP(-DABS((TAU(ITAU+1)-TAU(ITAU))/XJO(IQUAD)))
    ENDDO
  ENDDO !NQUADO LOOP
ENDIF  !OCEAN CONFIGURATION IF

! DELTA FIT TRUNCATION ADJUSTMENT FOR THE DETECTOR
IF(DETA)THEN
DO IDTAUA=1,NDTAUA
 TAUDETA(IDTAUA)=TAU(INDXDETA(IDTAUA))
! WRITE(9,"('TAU OF AIR DETECTOR(',I8,')=',ES13.6)")&
!            IDTAUA,TAUDETA(IDTAUA)
! WRITE(*,"('TAU OF AIR DETECTOR(',I8,')=',ES13.6)")&
!            IDTAUA,TAUDETA(IDTAUA)
ENDDO
ENDIF

IF(DETO)THEN
DO IDTAUO=1,NDTAUO
 TAUDETO(IDTAUO)=TAU(INDXDETO(IDTAUO))
! WRITE(9,"('TAU OF OCEAN DETECTOR(',I8,')=',ES13.6)")&
!             IDTAUO,TAUDETO(IDTAUO)
! WRITE(*,"('TAU OF OCEAN DETECTOR(',I8,')=',ES13.6)")&
!             IDTAUO,TAUDETO(IDTAUO)
ENDDO
ENDIF
!   _____OCEAN CONFIGRATION OVER___

!IF(WLR_FLAG .AND. OCEAN) THEN
! WRITE(9,'("WATER LEAVING RADIANCE IS CALCULATED&
!	&IRRADIANCE IS STILL TOTAL (Water Leaving + Atmospheric)")')
!ELSE
! WRITE(9,'("TOTAL RADIANCE AND IRRADIANCE IS CALCULATED")')
!ENDIF
!IF(WCFLG .AND. OCEAN) WRITE(9,'("WHITE CAP FLAG IS ON")')

! ___GET DML0,DML2P,DML2N DATAS_____

ALLOCATE(LSPMNA(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD),       &
		 SOURCEFA(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD),     &
         SRCFAP(NQUADA,NALYR,0:MAXMORD)  )
ALLOCATE(LSPMNA_SNG(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD), &
         LSPA_SNG_RO(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD))

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) ) THEN
 ALLOCATE(LSPMNO(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD),   &
           SOURCEFO(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD), &
           SRCFOP(NQUADO,NOLYR,0:MAXMORD)          )
 ALLOCATE(LSPMNO_SNG(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD))
 ALLOCATE(LSPO(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD),&
         LSPONM1(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD),      &
         LSPON(NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD),        &
         LSPOIRAD(NQUADO,NDTAUO),                  &
         LSPOIRADNM1(NQUADO,NDTAUO),            &
         LSPOIRADN(NQUADO,NDTAUO)                   )

 IF(RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG) THEN
	ALLOCATE(LSPMNO_INELASTIC_SNG(NQUADO,OLYR(1)%ITAUS:NTTAU,0:2))
	DO IQUAD=1,NQUADO
	  DO N=OLYR(1)%ITAUS,NTTAU
		DO M=0,2
			LSPMNO_INELASTIC_SNG(IQUAD,N,M)%VRAD(1:4)=0.0d0
		ENDDO
	  ENDDO
	ENDDO
 ENDIF

ENDIF

ALLOCATE(LSPA(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD),            &
         LSPANM1(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD),      &
         LSPAN(NQUADA,ALYR(NALYR)%ITAUE,0:MAXMORD),        &
         LSPAIRAD(NQUADA,NDTAUA),                  &
         LSPAIRADNM1(NQUADA,NDTAUA),            &
         LSPAIRADN(NQUADA,NDTAUA)                )

ALLOCATE(PMA(NQUADA,NQUADA,NUMMIE,0:MAXMORD),     &
         SPMA(NQUADA,NUMMIE,0:MAXMORD) )

IF(FLATO .OR. (LAMB .AND. FLAM<1.0D0)) &
       ALLOCATE(SRPMA(NQUADA,NUMMIE,0:MAXMORD))

IF(RAD_MAP)ALLOCATE(PMAX(NMUOUTSHFLA,NQUADA,NUMMIE,0:MAXMORD))

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
   ALLOCATE(PMO(NQUADO,NQUADO,NUMMIE,0:MAXMORD))
ENDIF

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. RAD_MAP)&
      ALLOCATE(PMOX(NMUOUTSHFLO,NQUADO,NUMMIE,0:MAXMORD))

ALLOCATE(RADATMP(NQDAD2,4),RADATMP1(NQDAD2,4))


IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))                               &
       ALLOCATE(RADOTMP(NQDOD2,4),RADOTMP1(NQDOD2,4))

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. (.NOT. FLATO)) THEN
  CALL XJATALLO
  CALL XJOTALLO
ENDIF

CALL GETDML(NMUOUTSHFLA,MUOUTSHFLA,NMUOUTSHFLO,MUOUTSHFLO)

CALL GETPM(NMUOUTSHFLA,MUOUTSHFLA,NMUOUTSHFLO,MUOUTSHFLO)

IF(OCEAN .AND. (.NOT.FLATO)) CALL CALHKW
IF(fSnowBRDF) CALL SNOW_BRDF_READIN

IF(pBRDF .or. fSnowBRDF .or. fRossLiBRDF) CALL CALPBRDF(ALYR(1)%WAVELENGTH)
IF(pBRDF .or. fSnowBRDF .or. fRossLiBRDF) CALL CALSPBRDF(ALYR(1)%WAVELENGTH,MU_IN)

CALL GETSDML(MU_IN)

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  CALL XJSOALLO(MU_IN)
  CALL GETSDMLO
ENDIF

IF(OCEAN .AND. (.NOT. FLATO)) CALL CALSHKW(MU_IN)

CALL GETSPM

DO ICOM=1,4
   LSPAIRAD(1:NQUADA,1:NDTAUA)%VRAD(ICOM)=0.0D0
   LSPAIRADNM1(1:NQUADA,1:NDTAUA)%VRAD(ICOM)=0.0D0
   LSPAIRADN(1:NQUADA,1:NDTAUA)%VRAD(ICOM)=0.0D0

   LSPA(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM)=0.0D0
   LSPANM1(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM)=0.0D0
   LSPAN(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM)=0.0D0
ENDDO
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) )THEN
DO ICOM=1,4
   LSPOIRAD(1:NQUADO,1:NDTAUO)%VRAD(ICOM)=0.0D0
   LSPOIRADNM1(1:NQUADO,1:NDTAUO)%VRAD(ICOM)=0.0D0
   LSPOIRADN(1:NQUADO,1:NDTAUO)%VRAD(ICOM)=0.0D0

   LSPO(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM)=0.0D0
   LSPONM1(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM)=0.0D0
   LSPON(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM)=0.0D0
ENDDO
ENDIF

IRRAD_A=0.0d0
IRRAD_O=0.0d0
IRRAD=0.0d0

IF(PSEUDO_SPHERICAL_SHELL)THEN
   CALL SLANT_PATH_PSS(MU_IN)
ELSE
   SECANT_THETAL_PRSV=1.0D0/ABS(MU_IN)
   SECANT_THETAL=1.0D0/ABS(MU_IN)
ENDIF


! atmospheric ROUGH OCEAN glint irradince
IF((OCEAN .AND. (.NOT.FLATO)) .or. pBRDF .OR. fSnowBRDF .or. fRossLiBRDF )THEN

  IF(DETA)ENGGLAREA=0.0D0

  IF(pBRDF .OR. fSnowBRDF .or. fRossLiBRDF)THEN
    ARRY1=ESUN*EXP(-TOTALTAU*SECANT_THETAL_PRSV(NALYR))/PI
  ELSE
    ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))/PI
  ENDIF
  DO JQUAD=NQDAD2+1,NQUADA
!    MTRX1=SFRES_REFLA(JQUAD,0)%PHMX
!    ARRY2=MATMUL(MTRX1,ARRY1)
    RTMP=SFRES_REFLA(JQUAD,0)%PHMX(1,1)*WTA(JQUAD)*XJA(JQUAD)

    IF(WCFLG)RTMP=RTMP*(1.0D0-FWC)
    IF(DETA)THEN
      DO N=1,NDTAUA
         IF(pBRDF .OR. fSnowBRDF .or. fRossLiBRDF)THEN
           RTMP3=TOTALTAU
         ELSE
           RTMP3=OITAU
         ENDIF
         RTMP1=EXP(-ABS((TAUDETA(N)-RTMP3)/XJA(JQUAD)))
         ENGGLAREA(N)=ENGGLAREA(N)+ &
            RTMP*RTMP1*ESUN(1)*EXP(-RTMP3*SECANT_THETAL_PRSV(NALYR))
      ENDDO
    ENDIF
  ENDDO

  IF(DETA) ENGGLAREA(:)=2.0D0*ENGGLAREA(:)

  IF(WCFLG .OR. RSRADDFLG) THEN
     IRRAD_A(1)=EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))*ESUN(1)*DABS(MU_IN)/PI
           !FWC*WCLBDO IS NOT INCLUDED BECAUSE FLEXIBILITY REQUIREMENT FOR BOTH
           !TRANSMISSION AND REFLECTION 
     IRRAD_O(1)=0.0D0
  ENDIF
ENDIF

! ATMOSPHERIC FLAT SURFACE GLINT IRRADIANCE
ARRY1=ESUN/FOURPI
FLAG1=OCEAN .AND. FLATO
IF(FLAG1)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)

  IF(DETA)THEN
  DO N=1,NDTAUA
       ENGGLAREA(N)=-ESUN(1)*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR)) * &
                             EXP(-ABS((OITAU-TAUDETA(N))/MU_IN))   * &
                             MU_IN*FRES_MTRX(1,1)
  ENDDO
  ENDIF
ENDIF
FLAG2=(.NOT. OCEAN).AND. LAMB .AND. (FLAM<1.0D0)
IF(FLAG2) THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)
  FRES_MTRX=FRES_MTRX*(1.0D0-FLAM)
  IF(DETA)THEN
  DO N=1,NDTAUA
       ENGGLAREA(N)=-ESUN(1)*EXP(-TOTALTAU*SECANT_THETAL_PRSV(NALYR)) * &
                             EXP(-ABS((TOTALTAU-TAUDETA(N))/MU_IN))   * &
                             FRES_MTRX(1,1)*MU_IN
  ENDDO
  ENDIF
ENDIF

IF((.NOT.OCEAN ) .AND. LAMB)THEN  
     ! NO OCEAN CASE: SOLAR IRRADIANCE AT THE LAND BOTTOM
  IRRAD=0.0D0
  RTMP=EXP(-TOTALTAU*SECANT_THETAL_PRSV(NALYR))*ESUN(1)
  IRRAD(1)=GLBDO*RTMP*DABS(MU_IN)/PI  
     !GLBDO has been modified such as GLBDO=GLBDO*FLAM
ENDIF  ! NO OCEAN IF

! IN OCEAN DETECTOR GLINT IRRADIANCE
IF(FLATO .AND. (.NOT. OCEAN_NO_TRAN))THEN

  MU0T=XJSO(1)
  THETA1=PI-THETA_IN
  CALL FRSNL_T2(NWRE,NWIM,THETA1,MTRX1)
  ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))&
          *DABS((MU_IN)/MU0T)
  ARRY2=MATMUL(MTRX1,ARRY1)

  IF(DETO)THEN
    ENGGLAREO=0.0D0
    DO N=1,NDTAUO
      ENGGLAREO(N)=EXP(-ABS((TAUDETO(N)-OITAU)/MU0T))&
              *ARRY2(1)*DABS(MU0T)
    ENDDO
  ENDIF
  RTMP=DABS((TOTALTAU-OITAU)/MU0T)
  IRRAD(1)=GLBDO*EXP(-RTMP)*ARRY2(1)*DABS(XJSO(1))/PI

ENDIF !IF(FLATO .AND. (.NOT. OCEAN_NO_TRAN))

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. (.NOT.FLATO))THEN
  IF(NQUADSO==1)THEN
    MU0T=XJSO(1)
    MTRX1=SFRES_TRANA(1,0)%PHMX
    ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))&
          * DABS(MU_IN/MU0T)
    ARRY2=MATMUL(MTRX1,ARRY1)
    IF(WCFLG) ARRY2=ARRY2*(1.0D0-FWC)
    IF(DETO)THEN
      ENGGLAREO=0.0D0
      DO N=1,NDTAUO
        ENGGLAREO(N)=EXP(-ABS((TAUDETO(N)-OITAU)/MU0T))&
              *ARRY2(1)*DABS(MU0T)
      ENDDO
    ENDIF
    RTMP=DABS((TOTALTAU-OITAU)/MU0T)
    IRRAD(1)=GLBDO*EXP(-RTMP)*ARRY2(1)*DABS(XJSO(1))/PI
  ELSE ! NQUADSO>1 CASE
   IRRAD=0.0d0
   IF(DETO)ENGGLAREO=0.0d0  ! BUG FIX FEB 13 2014
   ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))/PI
   DO JQUAD=1,NQUADSO
     MTRX1=SFRES_TRANA(JQUAD,0)%PHMX
     ARRY2=MATMUL(MTRX1,ARRY1)
! LAMBERTIAN BOTTOM INITIALIZATION
     RTMP=DABS((TOTALTAU-OITAU)/XJSO(JQUAD))
     IRRAD(1)=IRRAD(1)+GLBDO*EXP(-RTMP)*ARRY2(1) &
            *DABS(XJSO(JQUAD))*WTSO(JQUAD)
     IF(DETO)THEN
      DO N=1,NDTAUO
        ENGGLAREO(N)=ENGGLAREO(N)+ARRY2(1)*DABS(XJSO(JQUAD))    &
          *WTSO(JQUAD)*EXP(-ABS((TAUDETO(N)-OITAU)/XJSO(JQUAD)))
      ENDDO
     ENDIF
   ENDDO

   IF(DETO) ENGGLAREO=2.0D0*PI*ENGGLAREO
   IRRAD=2.0D0*IRRAD
   IF(WCFLG) THEN
     IF(DETO)ENGGLAREO=ENGGLAREO*(1.0D0-FWC)
     IRRAD=IRRAD*(1.0D0-FWC)
   ENDIF
  ENDIF ! NQUADSO==1

ENDIF ! IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. (.NOT.FLATO))

!write(*,*)'0th order irrad=',IRRAD(1)
 
IF(FWDCN_CORR_FLAG) CALL FWDCN_CONFIG(MU_IN)

! SUCCESSIVE ORDER OF SCATTERING

!write(*,*)'start SOS'
DO ICOL=1,NCOL
DO M=0,MAXMORD

IF(ICOL==1 .AND. M<=2  .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN) &
          .AND. (RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG)) THEN
  DO IQUAD=1,NQUADO
  DO N=OLYR(1)%ITAUS,NTTAU
    LSPMNO(IQUAD,N,M)%VRAD(1:4)=0.0d0
    LSPMNO_SNG(IQUAD,N,M)%VRAD(1:4)=0.0d0
  ENDDO
  ENDDO

  CALL SOURCEF_OCEAN_INELASTIC(M)
  CALL SOURCEFUNC_INTEGRATION_OCEAN(M)
  DO IQUAD=1,NQUADO
  DO N=OLYR(1)%ITAUS,NTTAU
     LSPMNO_INELASTIC_SNG(IQUAD,N,M)%VRAD(1:4)=LSPMNO(IQUAD,N,M)%VRAD(1:4)
     LSPMNO(IQUAD,N,M)%VRAD(1:4)=0.0D0
  ENDDO
  ENDDO
ENDIF

IF(ICOL==1) THEN
 IF(DIFFUSE_TRANSMITTANCE)THEN
   IF(M==0)THEN
    IRRAD=PI
    IRRAD_O=0.0D0
    IRRAD_A=0.0D0
    IRRAD_SNGL=IRRAD
    IRRAD_O_SNGL=IRRAD_O
    IRRAD_A_SNGL=IRRAD_A
   ENDIF
   DO IQUAD=1,NQUADA
   DO N=1,ALYR(NALYR)%ITAUE
      LSPMNA_SNG(IQUAD,N,M)%VRAD(1:4)=0.0d0
      LSPMNA(IQUAD,N,M)%VRAD(1:4)=0.0d0
      LSPA_SNG_RO(IQUAD,N,M)%VRAD(1:4)=0.0d0
   ENDDO
   ENDDO
   IF(OCEAN .AND. .NOT. OCEAN_NO_TRAN)THEN
      DO IQUAD=1,NQUADO
      DO N=OLYR(1)%ITAUS,NTTAU
        LSPMNO(IQUAD,N,M)%VRAD(1:4)=0.0d0
        LSPMNO_SNG(IQUAD,N,M)%VRAD(1:4)=0.0d0
      ENDDO
      ENDDO
   ENDIF
 ELSE
   CALL SINGLE_SCATTERING(M,MU_IN)
    IF(M==0)THEN
      IRRAD_SNGL=IRRAD
      IRRAD_O_SNGL=IRRAD_O
      IRRAD_A_SNGL=IRRAD_A
    ENDIF
 ENDIF
ENDIF

IF(ICOL>1)THEN
  CALL SOURCEFUNC_INTEGRATION_ATMOS(M)
  IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) &
          CALL SOURCEFUNC_INTEGRATION_OCEAN(M)
ENDIF

! LAMBERTIAN SURFACE REFLECTANCE
IF(M==0)THEN
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. LAMB)THEN
  DO IQUAD=NQDOD2+1,NQUADO
  DO I=NOLYR,1,-1
  DO ITAU=OLYR(I)%ITAUE,OLYR(I)%ITAUS,-1
     RTMP=DABS((TOTALTAU-TAU(ITAU))/XJO(IQUAD))
     LSPMNO(IQUAD,ITAU,M)%VRAD(1)= LSPMNO(IQUAD,ITAU,M)%VRAD(1)+  &
                                EXP(-RTMP)*IRRAD(1)
  ENDDO ! LOOP SUBLAYERS,BOTTOM CONTRIBUTION
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,BOTTOM CONTRIBUTION
  ENDDO ! QUAD LOOP
ENDIF

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. WCFLG)THEN
  DO IQUAD=1,NQDOD2
  DO I=1,NOLYR
  DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
     RTMP=DABS((TAU(ITAU)-OITAU)/XJO(IQUAD))
     LSPMNO(IQUAD,ITAU,M)%VRAD(1)= LSPMNO(IQUAD,ITAU,M)%VRAD(1)+  &
            EXP(-RTMP)*FWC*(IRRAD_A(1)*(1.0D0-WCLBDO)+IRRAD_O(1)*WCLBDO)
  ENDDO ! LOOP SUBLAYERS,BOTTOM CONTRIBUTION
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,OI WC FRACTION CONTRIBUTION
  ENDDO ! QUAD LOOP
ENDIF

IF(OCEAN.AND. WCFLG) THEN
  DO IQUAD=NQDAD2+1,NQUADA
  DO I=NALYR,1,-1
  DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
     RTMP=DABS((TAU(ITAU)-OITAU)/XJA(IQUAD))
     LSPMNA(IQUAD,ITAU,M)%VRAD(1)= LSPMNA(IQUAD,ITAU,M)%VRAD(1)+  &
            EXP(-RTMP)*FWC*(IRRAD_A(1)*WCLBDO+IRRAD_O(1)*(1.0D0-WCLBDO))
  ENDDO ! LOOP SUBLAYERS,BOTTOM CONTRIBUTION
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,BOTTOM CONTRIBUTION
  ENDDO ! QUAD LOOP
ENDIF

IF(OCEAN.AND. RSRADDFLG) THEN
  DO IQUAD=NQDAD2+1,NQUADA
  DO I=NALYR,1,-1
  DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
     RTMP=DABS((TAU(ITAU)-OITAU)/XJA(IQUAD))
     LSPMNA(IQUAD,ITAU,M)%VRAD(1)= LSPMNA(IQUAD,ITAU,M)%VRAD(1)+  &
            EXP(-RTMP)*IRRAD_A(1)*RSR0P*PI
  ENDDO ! LOOP SUBLAYERS,BOTTOM CONTRIBUTION
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,BOTTOM CONTRIBUTION
  ENDDO ! QUAD LOOP
ENDIF

IF((.NOT.OCEAN).AND. LAMB) THEN
  DO IQUAD=NQDAD2+1,NQUADA
  DO I=NALYR,1,-1
  DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
     RTMP=DABS((TOTALTAU-TAU(ITAU))/XJA(IQUAD))
     LSPMNA(IQUAD,ITAU,M)%VRAD(1)= LSPMNA(IQUAD,ITAU,M)%VRAD(1)+  &
                                EXP(-RTMP)*IRRAD(1)
  ENDDO ! LOOP SUBLAYERS,BOTTOM CONTRIBUTION
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,BOTTOM CONTRIBUTION
  ENDDO ! QUAD LOOP
ENDIF
ENDIF  ! M=0 IF

! AIR-SEA INTERFACE BOUNDARY CONDITIONS

! ATMOSPHERE LAYERS MU>0
! Sky light reflectance.
IF(OCEAN .or. pBRDF .OR. fSnowBRDF .or. fRossLiBRDF)THEN
  RADATMP=0.0D0
  ITAU=ALYR(NALYR)%ITAUE
  DO IQUAD=1,NQDAD2
    ARRY1=LSPMNA(IQUAD,ITAU,M)%VRAD
    IF(FLATO)THEN
      MTRX1(:,:)=FRSNLAR(IQUAD,:,:)
      ARRY2=MATMUL(MTRX1,ARRY1)
      RADATMP(NQDAD2-IQUAD+1,:)=RADATMP(NQDAD2-IQUAD+1,:) &
                              +ARRY2
    ELSE
	  DO JQUAD=NQDAD2+1,NQUADA
        MTRX1=FRES_REFLA(IQUAD,JQUAD,M)%PHMX
        ARRY2=MATMUL(MTRX1,ARRY1)
        RADATMP(JQUAD-NQDAD2,:)=RADATMP(JQUAD-NQDAD2,:) &
	                          +ARRY2*WTA(IQUAD)
      ENDDO ! QUAD LOOP
	ENDIF
  ENDDO ! QUAD LOOP

  IF(.NOT.FLATO) RADATMP=2.0d0*RADATMP

  IF(WCFLG)RADATMP=RADATMP*(1.0D0-FWC)

! UPDATE LSPMNA
  IF(pBRDF .OR. fSnowBRDF .or. fRossLiBRDF)THEN
    RTMP3=TOTALTAU
  ELSE
    RTMP3=OITAU
  ENDIF
  DO I=1,NALYR
  DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  DO IQUAD=NQDAD2+1,NQUADA
     RTMP=DABS((TAU(ITAU)-RTMP3)/XJA(IQUAD))
     LSPMNA(IQUAD,ITAU,M)%VRAD(:)=LSPMNA(IQUAD,ITAU,M)%VRAD(:)+&
           EXP(-RTMP)*RADATMP(IQUAD-NQDAD2,:)
  ENDDO ! QUAD LOOP
  ENDDO ! LOOP SUBLAYERS
  ENDDO ! LOOP ATMOSPHERE LAYERS FOR MU>0,
ENDIF ! OCEAN IF FOR SKY LIGHT REFLECTANCE

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
! OCEAN LAYER DOWNWARD MU<0
! SKY LIGHT TRANSMITTANCE
  RADOTMP=0.0D0
  ITAU=ALYR(NALYR)%ITAUE
  IF(FLATO)THEN
    DO IQUAD=1,NQDAD2
      ARRY1(:)=LSPMNA(IQUAD,ITAU,M)%VRAD(:)
      MTRX1(:,:)=FRSNLAT(IQUAD,:,:)
      ARRY2=MATMUL(MTRX1,ARRY1)
      RADOTMP(IQUAD,:)=RADOTMP(IQUAD,:)+NSQW*ARRY2
    ENDDO  
  ELSE
    DO IQUAD=1,NQDAD2
      RADATMP1(IQUAD,:)=LSPMNA(IQUAD,ITAU,M)%VRAD(:)
    ENDDO

    DO JQUAD=1,NQDOD2
      DO IQUAD=1,NQDAD2
        XJAD2(IQUAD)=XJAT(IQUAD,JQUAD)
      ENDDO
      CALL RADINTPL2(MPLIN,NQDAD2,XJA,RADATMP1,NQDAD2,XJAD2,RADATMP)

      DO IQUAD=1,NQDAD2
        ARRY1(:)=RADATMP(IQUAD,:)
        MTRX1=FRES_TRANA(IQUAD,JQUAD,M)%PHMX
        ARRY2=MATMUL(MTRX1,ARRY1)
        RADOTMP(JQUAD,:)=RADOTMP(JQUAD,:)+ARRY2*WTAT(IQUAD,JQUAD)
      ENDDO ! QUAD LOOP
    ENDDO ! QUAD LOOP
    RADOTMP=2.0d0*RADOTMP
  ENDIF
  
  IF(WCFLG)RADOTMP=RADOTMP*(1.0D0-FWC)

! UPDATE LSPMNO
  DO I=1,NOLYR
  DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
  DO IQUAD=1,NQDOD2
     RTMP=DABS((TAU(ITAU)-OITAU)/XJO(IQUAD))
     LSPMNO(IQUAD,ITAU,M)%VRAD(:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:) + &
             EXP(-RTMP)*RADOTMP(IQUAD,:)
  ENDDO ! QUAD LOOP
  ENDDO ! LOOP SUBLAYERS
  ENDDO ! LOOP OCEAN LAYERS FOR MU<0

! OCEAN LIGHT REFLECTED BY THE AIR - SEA INTERFACE

  RADOTMP=0.0D0
  ITAU=OLYR(1)%ITAUS
  DO IQUAD=NQDOD2+1,NQUADO
    IF(FLATO)THEN
      ARRY1=LSPMNO(IQUAD,ITAU,M)%VRAD
      MTRX1=FRSNLWR(IQUAD,:,:)
      ARRY2=MATMUL(MTRX1,ARRY1)
      RADOTMP(NQUADO-IQUAD+1,:)=RADOTMP(NQUADO-IQUAD+1,:) + ARRY2
	ELSE
	  DO JQUAD=1,NQDOD2
       ARRY1=LSPMNO(IQUAD,ITAU,M)%VRAD
       MTRX1=FRES_REFLO(IQUAD,JQUAD,M)%PHMX
       ARRY2=MATMUL(MTRX1,ARRY1)
       RADOTMP(JQUAD,:)=RADOTMP(JQUAD,:)+ 2.0d0*ARRY2*WTO(IQUAD)
      ENDDO ! QUAD LOOP
    ENDIF
  ENDDO ! QUAD LOOP

  IF(WCFLG)RADOTMP=RADOTMP*(1.0D0-FWC)

! UPDATE LSPMNO
  DO I=1,NOLYR
  DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
  DO IQUAD=1,NQDOD2
     RTMP=DABS((TAU(ITAU)-OITAU)/XJO(IQUAD))
     LSPMNO(IQUAD,ITAU,M)%VRAD(:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:)+&
             EXP(-RTMP)*RADOTMP(IQUAD,:)
  ENDDO ! QUAD LOOP
  ENDDO ! LOOP SUBLAYERS
  ENDDO ! LOOP OCEAN LAYERS FOR MU>0,

! ATMOSPHERE LAYERS MU>0 BOUNDARY CONDITION  
! OCEAN LIGHT TRANSMITTANCE
  RADATMP=0.0D0
  ITAU=OLYR(1)%ITAUS
  IF(FLATO)THEN
    DO IQUAD=NQUADO-NQDAD2+1,NQUADO
      ARRY1=LSPMNO(IQUAD,ITAU,M)%VRAD(:)
      MTRX1(:,:)=FRSNLWT(IQUAD,:,:)
      ARRY2=MATMUL(MTRX1,ARRY1)
      RADATMP(IQUAD-NQUADO+NQDAD2,:)=RADATMP(IQUAD-NQUADO+NQDAD2,:) &
	                               + NSQA*ARRY2
    ENDDO
  ELSE
    DO IQUAD=NQDOD2+1,NQUADO
      RADOTMP1(IQUAD-NQDOD2,:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:)
    ENDDO
    DO JQUAD=NQDAD2+1,NQUADA
      DO IQUAD=NQDOD2+1,NQUADO
        XJOD2(IQUAD-NQDOD2)=XJOT(IQUAD,JQUAD)
      ENDDO
      CALL RADINTPL2(MPLIN,NQDOD2,XJO(NQDOD2+1),RADOTMP1,NQDOD2, &
	                 XJOD2,RADOTMP)
      DO IQUAD=NQDOD2+1,NQUADO
        ARRY1=RADOTMP(IQUAD-NQDOD2,:)
        MTRX1=FRES_TRANO(IQUAD,JQUAD,M)%PHMX
        ARRY2=MATMUL(MTRX1,ARRY1)
        RADATMP(JQUAD-NQDAD2,:)=RADATMP(JQUAD-NQDAD2,:)+ &
	                2.0D0*ARRY2*WTOT(IQUAD,JQUAD)
      ENDDO ! QUAD LOOP
    ENDDO ! QUAD LOOP
  ENDIF !FLATO IF

  IF(WCFLG)RADATMP=RADATMP*(1.0D0-FWC)

! UPDATE LSPMNA
  DO I=1,NALYR
  DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  DO IQUAD=NQDAD2+1,NQUADA
     RTMP=DABS((TAU(ITAU)-OITAU)/XJA(IQUAD))
     ARRY1=EXP(-RTMP)*RADATMP(IQUAD-NQDAD2,:)

     LSPMNA(IQUAD,ITAU,M)%VRAD(:)=LSPMNA(IQUAD,ITAU,M)%VRAD(:)+&
            ARRY1(:)
  ENDDO ! QUAD LOOP
  ENDDO ! LOOP SUBLAYERS
  ENDDO ! LOOP ATMOSPHERE LAYERS FOR MU>0,

ENDIF  !OCEAN WITH TRANSMISSION IF

! _____ATMOSPHERE OCEAN LAYERS BOUNDARY CONDITION OVER_____________

! RECORD M=0 TERM FOR LAMBERTIAN BOTTOM AT THE LAST LAYER OF THE OCEAN
IF(M==0) THEN
  IRRAD=0.0D0
  IRRAD_O=0.0D0
  IRRAD_A=0.0D0
ENDIF

IF((.NOT. OCEAN) .AND. LAMB)THEN
  IF(M==0)THEN
    ITAU=ALYR(NALYR)%ITAUE
    DO JQUAD=1,NQDAD2
      IRRAD(1)=IRRAD(1)+2.0D0*GLBDO*WTA(JQUAD)*  &
			LSPMNA(JQUAD,ITAU,M)%VRAD(1)*DABS(XJA(JQUAD))
    ENDDO
  ENDIF
  IF(FLAM<1.0D0)THEN
    RADATMP=0.0D0
    ITAU=ALYR(NALYR)%ITAUE
    DO IQUAD=1,NQDAD2
      ARRY1=LSPMNA(IQUAD,ITAU,M)%VRAD
      MTRX1(:,:)=FRSNLMBR(IQUAD,:,:)
      ARRY2=MATMUL(MTRX1,ARRY1)
	  RADATMP(NQDAD2-IQUAD+1,:)=RADATMP(NQDAD2-IQUAD+1,:) &
                              +ARRY2
    ENDDO ! QUAD LOOP
! UPDATE LSPMNA FOR LAMBERT AND SPECULAR REFLECTION MIXING
    DO I=1,NALYR
    DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
    DO IQUAD=NQDAD2+1,NQUADA
       RTMP=DABS((TAU(ITAU)-TOTALTAU)/XJA(IQUAD))
       LSPMNA(IQUAD,ITAU,M)%VRAD(:)=LSPMNA(IQUAD,ITAU,M)%VRAD(:)+&
           EXP(-RTMP)*RADATMP(IQUAD-NQDAD2,:)
    ENDDO ! QUAD LOOP
    ENDDO ! LOOP SUBLAYERS
    ENDDO ! LOOP ATMOSPHERE LAYERS FOR MU>0,
  ENDIF
ENDIF

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  IF(M==0 .AND. LAMB)THEN
    IRRAD=0.0D0
    ITAU=OLYR(NOLYR)%ITAUE
    DO JQUAD=1,NQDOD2
      IRRAD(1)=IRRAD(1)+2.0D0*GLBDO*WTO(JQUAD)*  &
			LSPMNO(JQUAD,ITAU,M)%VRAD(1)*DABS(XJO(JQUAD))
    ENDDO
  ENDIF
ENDIF

IF(OCEAN .AND. (WCFLG .OR. RSRADDFLG) .AND. M==0)THEN
    IRRAD_A=0.0D0
    ITAU=ALYR(NALYR)%ITAUE
    DO JQUAD=1,NQDAD2
      IRRAD_A(1)=IRRAD_A(1)+2.0D0*WTA(JQUAD)*  &
			LSPMNA(JQUAD,ITAU,M)%VRAD(1)*DABS(XJA(JQUAD))
    ENDDO

    IF(.NOT.OCEAN_NO_TRAN)THEN
      IRRAD_O=0.0D0
      ITAU=OLYR(1)%ITAUS
      DO JQUAD=NQDOD2+1,NQUADO
        IRRAD_O(1)=IRRAD_O(1)+2.0D0*WTO(JQUAD)*  &
	       LSPMNO(JQUAD,ITAU,M)%VRAD(1)*DABS(XJO(JQUAD))
      ENDDO
    ENDIF
ENDIF

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) CALL SOURCEF_OCEAN(M)

CALL SOURCEF_ATMOS(M)

! RECORD DETECTOR CONTRIBUTION FOR DIFFUSE LIGHT

  IF(M==0)THEN
    DO IQUAD=1,NQUADA
    DO IDTAU=1,NDTAUA
       LSPAIRAD(IQUAD,IDTAU)%VRAD=LSPAIRAD(IQUAD,IDTAU)%VRAD + &
               LSPMNA(IQUAD,INDXDETA(IDTAU),M)%VRAD
       IF(ICOL==NCOL-1  .AND. GEOSR)THEN
         LSPAIRADNM1(IQUAD,IDTAU)%VRAD=  &
	         LSPAIRADNM1(IQUAD,IDTAU)%VRAD +         &
             LSPMNA(IQUAD,INDXDETA(IDTAU),M)%VRAD
       ELSE IF(ICOL==NCOL  .AND. GEOSR)THEN
         LSPAIRADN(IQUAD,IDTAU)%VRAD=LSPAIRADN(IQUAD,IDTAU)%VRAD + &
               LSPMNA(IQUAD,INDXDETA(IDTAU),M)%VRAD
       ENDIF
    ENDDO
    ENDDO
  ENDIF

  DO IQUAD=1,NQUADA
  DO ITAU=1,ALYR(NALYR)%ITAUE
      LSPA(IQUAD,ITAU,M)%VRAD=LSPA(IQUAD,ITAU,M)%VRAD + &
               LSPMNA(IQUAD,ITAU,M)%VRAD
      IF(ICOL==NCOL-1  .AND. GEOSR)THEN
        LSPANM1(IQUAD,ITAU,M)%VRAD=  &
	         LSPANM1(IQUAD,ITAU,M)%VRAD +         &
             LSPMNA(IQUAD,ITAU,M)%VRAD
      ELSE IF(ICOL==NCOL  .AND. GEOSR)THEN
        LSPAN(IQUAD,ITAU,M)%VRAD=LSPAN(IQUAD,ITAU,M)%VRAD + &
               LSPMNA(IQUAD,ITAU,M)%VRAD
      ENDIF
  ENDDO
  ENDDO
  IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. M==0)THEN
    DO IQUAD=1,NQUADO
    DO IDTAU=1,NDTAUO
       LSPOIRAD(IQUAD,IDTAU)%VRAD=LSPOIRAD(IQUAD,IDTAU)%VRAD + &
               LSPMNO(IQUAD,INDXDETO(IDTAU),M)%VRAD
       IF(ICOL==NCOL-1  .AND. GEOSR)THEN
         LSPOIRADNM1(IQUAD,IDTAU)%VRAD=  &
	         LSPOIRADNM1(IQUAD,IDTAU)%VRAD +         &
             LSPMNO(IQUAD,INDXDETO(IDTAU),M)%VRAD
       ELSE IF(ICOL==NCOL  .AND. GEOSR)THEN
         LSPOIRADN(IQUAD,IDTAU)%VRAD=LSPOIRADN(IQUAD,IDTAU)%VRAD + &
               LSPMNO(IQUAD,INDXDETO(IDTAU),M)%VRAD
       ENDIF
    ENDDO
    ENDDO
  ENDIF
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
DO IQUAD=1,NQUADO
DO ITAU=OLYR(1)%ITAUS,NTTAU
  LSPO(IQUAD,ITAU,M)%VRAD=LSPO(IQUAD,ITAU,M)%VRAD + &
               LSPMNO(IQUAD,ITAU,M)%VRAD
  IF(ICOL==NCOL-1 .AND. GEOSR)THEN
    LSPONM1(IQUAD,ITAU,M)%VRAD=LSPONM1(IQUAD,ITAU,M)%VRAD + &
               LSPMNO(IQUAD,ITAU,M)%VRAD
  ELSEIF(ICOL==NCOL .AND. GEOSR)THEN
    LSPON(IQUAD,ITAU,M)%VRAD=LSPON(IQUAD,ITAU,M)%VRAD + &
               LSPMNO(IQUAD,ITAU,M)%VRAD
  ENDIF

ENDDO
ENDDO
ENDIF

DO IQUAD=1,NQUADA
DO ITAU=1,ALYR(NALYR)%ITAUE
  LSPMNA(IQUAD,ITAU,M)%VRAD=0.0D0
ENDDO
ENDDO

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  DO IQUAD=1,NQUADO
  DO ITAU=OLYR(1)%ITAUS,NTTAU
    LSPMNO(IQUAD,ITAU,M)%VRAD=0.0D0
  ENDDO
  ENDDO
ENDIF


ENDDO  ! LOOP ORDER M

ENDDO   ! LOOP COLLISON

!  Calculate radiance parameter based on Fourier components

IF(GEOSR)THEN
! AIR DETECTOR RADIANCE FIELD
DO IQUAD=1,NQUADA
DO ITAU=1,ALYR(NALYR)%ITAUE
DO M=0,MAXMORD

!DO ICOM=1,4
!RTMP=LSPANM1(IQUAD,ITAU,M)%VRAD(ICOM)-&
!     LSPAN(IQUAD,ITAU,M)%VRAD(ICOM)
!IF(RTMP>TINY2)THEN
!  LSPA(IQUAD,ITAU,M)%VRAD(ICOM)=LSPA(IQUAD,ITAU,M)%VRAD(ICOM) + &
!      LSPAN(IQUAD,ITAU,M)%VRAD(ICOM)&
!	 *LSPAN(IQUAD,ITAU,M)%VRAD(ICOM) &
!     /RTMP
!ENDIF
!ENDDO

  ARRY1=LSPANM1(IQUAD,ITAU,M)%VRAD-LSPAN(IQUAD,ITAU,M)%VRAD
  IF(ARRY1(1)>TINY2 .and. abs(ARRY1(2))>TINY2 .and. abs(ARRY1(3))>TINY2 &
     .and. abs(ARRY1(4))>TINY2  )THEN
    ARRY2=LSPA(IQUAD,ITAU,M)%VRAD + &
        LSPAN(IQUAD,ITAU,M)%VRAD*LSPAN(IQUAD,ITAU,M)%VRAD/ARRY1
    RTMP=SQRT(ARRY2(2)*ARRY2(2)+ARRY2(3)*ARRY2(3)+ARRY2(4)*ARRY2(4))
    IF(ARRY2(1)>RTMP) LSPA(IQUAD,ITAU,M)%VRAD=ARRY2
  ENDIF
ENDDO
ENDDO
ENDDO

! AIR DETECTOR IRRADIANCE
DO IQUAD=1,NQUADA
DO IDTAU=1,NDTAUA
!DO ICOM=1,4
!RTMP=LSPAIRADNM1(IQUAD,IDTAU)%VRAD(ICOM)-&
!     LSPAIRADN(IQUAD,IDTAU)%VRAD(ICOM)
!IF(RTMP>TINY2)THEN
!  LSPAIRAD(IQUAD,IDTAU)%VRAD(ICOM)=LSPAIRAD(IQUAD,IDTAU)%VRAD(ICOM) + &
!      LSPAIRADN(IQUAD,IDTAU)%VRAD(ICOM)&
!	 *LSPAIRADN(IQUAD,IDTAU)%VRAD(ICOM) &
!     /RTMP
!ENDIF
!ENDDO

  ARRY1=LSPAIRADNM1(IQUAD,IDTAU)%VRAD-LSPAIRADN(IQUAD,IDTAU)%VRAD
  IF(ARRY1(1)>TINY2 .and. abs(ARRY1(2))>TINY2 .and. abs(ARRY1(3))>TINY2 &
    .and. abs(ARRY1(4))>TINY2  )THEN
    ARRY2=LSPAIRAD(IQUAD,IDTAU)%VRAD + &
        LSPAIRADN(IQUAD,IDTAU)%VRAD*LSPAIRADN(IQUAD,IDTAU)%VRAD/ARRY1
    RTMP=SQRT(ARRY2(2)*ARRY2(2)+ARRY2(3)*ARRY2(3)+ARRY2(4)*ARRY2(4))
    IF(ARRY2(1)>RTMP ) LSPAIRAD(IQUAD,IDTAU)%VRAD=ARRY2
  ENDIF
ENDDO
ENDDO

ENDIF ! GEOSR IF

IF(GEOSR .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN

!OCEAN DETECTOR RADIANCE GEOMETRIC CORRECTION

DO IQUAD=1,NQUADO
DO ITAU=OLYR(1)%ITAUS,NTTAU
DO M=0,MAXMORD

!DO ICOM=1,4
!RTMP=LSPONM1(IQUAD,ITAU,M)%VRAD(ICOM) &
!       -LSPON(IQUAD,ITAU,M)%VRAD(ICOM)
!IF(RTMP>TINY2)THEN
!  LSPO(IQUAD,ITAU,M)%VRAD(ICOM)=LSPO(IQUAD,ITAU,M)%VRAD(ICOM) + &
!      LSPON(IQUAD,ITAU,M)%VRAD(ICOM)                          &
!	 *LSPON(IQUAD,ITAU,M)%VRAD(ICOM)                          &
!     /RTMP
!ENDIF
!ENDDO

  ARRY1=LSPONM1(IQUAD,ITAU,M)%VRAD-LSPON(IQUAD,ITAU,M)%VRAD
  IF(ARRY1(1)>TINY2 .and. abs(ARRY1(2))>TINY2 .and. abs(ARRY1(3))>TINY2 &
     .and. abs(ARRY1(4))>TINY2  )THEN

    ARRY2=LSPO(IQUAD,ITAU,M)%VRAD + &
        LSPON(IQUAD,ITAU,M)%VRAD*LSPON(IQUAD,ITAU,M)%VRAD/ARRY1
    RTMP=SQRT(ARRY2(2)*ARRY2(2)+ARRY2(3)*ARRY2(3)+ARRY2(4)*ARRY2(4))
    IF(ARRY2(1)>RTMP) LSPO(IQUAD,ITAU,M)%VRAD=ARRY2
  ENDIF
ENDDO
ENDDO
ENDDO

!OCEAN DETECTOR IRRADIANCE GEOMETRIC CORRECTION
DO IQUAD=1,NQUADO
DO IDTAU=1,NDTAUO
DO M=0,MAXMORD

!DO ICOM=1,4
!RTMP=LSPOIRADNM1(IQUAD,IDTAU)%VRAD(ICOM)-&
!     LSPOIRADN(IQUAD,IDTAU)%VRAD(ICOM)
!IF(RTMP>TINY2)THEN
!  LSPOIRAD(IQUAD,IDTAU)%VRAD(ICOM)=LSPOIRAD(IQUAD,IDTAU)%VRAD(ICOM) + &
!      LSPOIRADN(IQUAD,IDTAU)%VRAD(ICOM)&
!	 *LSPOIRADN(IQUAD,IDTAU)%VRAD(ICOM) &
!     /RTMP
!ENDIF
!ENDDO

  ARRY1=LSPOIRADNM1(IQUAD,IDTAU)%VRAD-LSPOIRADN(IQUAD,IDTAU)%VRAD
  IF(ARRY1(1)>TINY2 .and. abs(ARRY1(2))>TINY2 .and. abs(ARRY1(3))>TINY2 &
     .and. abs(ARRY1(4))>TINY2  )THEN
    ARRY2=LSPOIRAD(IQUAD,IDTAU)%VRAD + &
        LSPOIRADN(IQUAD,IDTAU)%VRAD*LSPOIRADN(IQUAD,IDTAU)%VRAD/ARRY1
    RTMP=SQRT(ARRY2(2)*ARRY2(2)+ARRY2(3)*ARRY2(3)+ARRY2(4)*ARRY2(4))
    IF(ARRY2(1)>RTMP ) LSPOIRAD(IQUAD,IDTAU)%VRAD=ARRY2
  ENDIF
ENDDO
ENDDO
ENDDO

ENDIF  ! GEOMETRIC SERIES

IF(SAVE_RAMAN_FLAG .OR. SAVE_FLUORESCENCE_FLAG) CALL TAU_EX_ALLO
IF(SAVE_RAMAN_FLAG)THEN ! save LSPO for inelastic Raman scattering in another wavelength
  CALL SAVE_OCEAN_RAD(MU_IN)
ENDIF
IF(SAVE_FLUORESCENCE_FLAG)THEN !SAVE SCALAR IRRADIANCE FOR FLUORESCENCE SCATTERING
  CALL SAVE_OCEAN_SCALAR_IRRAD(MU_IN)
ENDIF

CALL IRRAD_UPDATE(IRRAD_SNGL,IRRAD_A_SNGL,IRRAD_O_SNGL,IRRAD,IRRAD_A,IRRAD_O)

IF(FWDCN_CORR_FLAG)THEN
  call date_and_time(values=time_array_0)
  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

  CALL SNGL_FWDCN_CRRCT_ATMOS(MU_IN)

  call date_and_time(values=time_array_1)
      finish_time = time_array_1 (5) * 3600 + time_array_1 (6) * 60 &
           + time_array_1 (7) + 0.001 * time_array_1 (8)
IF(VERBOSE_FLAG) write(*,*)'SNGL_FWDCN_CRRCT_ATMOS elapsed time =', finish_time-start_time
ENDIF

IF(SNG_RAD_CORR)THEN

  call date_and_time(values=time_array_0)
  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

! ATMOSPHERIC SINGLE SCATTERING CORRECTION
  ALLOCATE(LRADA_SNG(NMUOUTSHFLA,0:NALYR,NPHIOUT))
  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
           ALLOCATE(LRADA_SNG_SPSH(NMUOUTSHFLA,0:NALYR,NPHIOUT))
  CALL SNGL_SCAT_CRRCT_ATMOS(MU_IN,NMUOUTSHFLA,&
         NPHIOUT,PHIOUT,MUOUTSHFLA,MPLIN)

  call date_and_time(values=time_array_1)
      finish_time = time_array_1 (5) * 3600 + time_array_1 (6) * 60 &
           + time_array_1 (7) + 0.001 * time_array_1 (8)
  IF(VERBOSE_FLAG) &
      write(*,*)'atmosphere single scattering correction elapsed time =', &
      finish_time-start_time

! OCEAN SINGLE SCATTERING CORRECTION
  IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
    ALLOCATE(LRADO_SNG(1:NMUOUTSHFLO,0:NOLYR,NPHIOUT))
    CALL SNGL_SCAT_CRRCT_OCEAN(MU_IN,NMUOUTSHFLO,&
                    NPHIOUT,PHIOUT,MUOUTSHFLO)

    call date_and_time(values=time_array_1)
      start_time = time_array_1 (5) * 3600 + time_array_1 (6) * 60 &
           + time_array_1 (7) + 0.001 * time_array_1 (8)
    IF(VERBOSE_FLAG) &
      write(*,*)'ocean single scattering correction elapsed time =', &
      start_time-finish_time


  ENDIF


  IF(RAD_MAP) THEN
      call date_and_time(values=time_array_1)
      start_time = time_array_1 (5) * 3600 + time_array_1 (6) * 60 &
           + time_array_1 (7) + 0.001 * time_array_1 (8)

      CALL RADOUT_MAPPING(MU_IN,IRRAD,IRRAD_A,IRRAD_O,NMUOUTSHFLA,&
            MUOUTSHFLA, NMUOUTSHFLO,MUOUTSHFLO,NPHIOUT,PHIOUT,MPLIN)

	  call date_and_time(values=time_array_1)
			finish_time = time_array_1 (5) * 3600 + time_array_1 (6) * 60 &
			   + time_array_1 (7) + 0.001 * time_array_1 (8)
	  IF(VERBOSE_FLAG) &
		write(*,*)'RADOUT_Mapping elapsed time =', finish_time-start_time
  ENDIF

ENDIF

IF(DETA)THEN
ALLOCATE(RADDETU(NTHETAOUT,4))

DO IDTAU=1,NDTAUA
!WRITE(9,"('TAUDETA(',I8,')=',ES13.6)")IDTAU,TAUDETA(IDTAU)
ENGREFL=0.0D0
DO IQUAD=1,NQDAD2
ENGREFL=ENGREFL+LSPAIRAD(IQUAD,IDTAU)%VRAD(1)*WTA(IQUAD)*ABS(XJA(IQUAD))
ENDDO

ENGREFL=2.0D0*PI*ENGREFL+ESUN(1)*EXP(-TAUDETA(IDTAU)*SECANT_THETAL(INDXDETA(IDTAU)))&
						 *ABS(MU_IN)

!WRITE(9,"('DOWNWELLING IRRADIANCE =',ES13.6)")ENGREFL
! DIRAD(IDTAU,:,1) DOWNWELLING IRADIANCE
! DIRAD(IDTAU,:,2) UPWELLING IRADIANCE

DIRAD(IDTAU,1)=ENGREFL

ENGREFL=0.0D0
DO IQUAD=NQDAD2+1,NQUADA
!ENGREFL=ENGREFL+LSPA(IQUAD,IDTAU,0)%VRAD(1)*WTA(IQUAD)*XJA(IQUAD)
ENGREFL=ENGREFL+LSPAIRAD(IQUAD,IDTAU)%VRAD(1)*WTA(IQUAD)*XJA(IQUAD)
ENDDO

!WRITE(*,"('UPWELLING IRRADIANCE atmos=',I3,ES13.6,ES13.6,ES13.6)")&
!      IDTAU,TAUDETA(IDTAU),ENGREFL,ENGGLAREA(IDTAU)

ENGREFL=2.0D0*PI*ENGREFL+ENGGLAREA(IDTAU) ! DIFFUSE + DIRECT
!WRITE(9,"('UPWELLING IRRADIANCE =',ES13.6,ES13.6)")TAUDETA(IDTAU),ENGREFL
DIRAD(IDTAU,2)=ENGREFL

ENDDO  ! LOOP IDTAU

!IF(MUFLG)THEN
!  WRITE(9,'("COS(THETA)",1x,"PHI", 5x,"Radiance", &
!            &7x,  "Q", 16x ,"U", 15x, "V")')
!ELSE
!  WRITE(9,'(2x,"THETA",4x,"PHI", 5x,"Radiance", &
!            &8x,  "Q", 15x ,"U", 15x, "V")')
!ENDIF

! GLINT CORRECTION FOR THE FIRST ORDER SCATTERING.
IF(RAD_MAP) THEN
DO IDTAU=1,NDTAUA
DO IPHI=1,NPHIOUT
RADDETU=0.0D0
DO ITHETA=1,NTHETAOUT

	IF(OCEAN)THEN
		DIFF_FLG=.true.
		CALL RADACMDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
		IF(WCFLG) ARRY1=ARRY1*(1.0D0-FWC)
	ENDIF

	IF((.NOT. WLR_FLAG) .AND. (MUOUT(ITHETA)>0.0D0)      &
						   .AND. SGLNT .AND. OCEAN)      &
			RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	IF((MUOUT(ITHETA)>0.0D0).AND. OCEAN .AND. SURFACE_GLINT_FLAG) THEN
		DSTOKES_GLINT(IDTAU,ITHETA,IPHI,:)=ARRY1(:)
	ENDIF

	IF(pBRDF) THEN
	  DIFF_FLG=.true.
	  CALL RADALandDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	ELSEIF(fSnowBRDF)THEN

	  DIFF_FLG=.true.
	  CALL RADASnowDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	ELSEIF(fRossLiBRDF)THEN

	  DIFF_FLG=.true.
	  CALL RADARossLiDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)

	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)


	ENDIF

!  DO IMU=1,NMUOUTSHFLA
!     IF(ABS(MUOUT(ITHETA)-MUOUTSHFLA(IMU))<1.0E-4)EXIT
!  ENDDO
  INTARR=MINLOC(ABS(MUOUT(ITHETA)-MUOUTSHFLA))
  IMU=INTARR(1)
  IF(ABS(MUOUT(ITHETA)-MUOUTSHFLA(IMU))>1.0E-5)STOP 'CHECK IMU SEARCH 1'

  RADDETU(ITHETA,:)=RADDETU(ITHETA,:) + LRADA(IMU,IDTAU,IPHI)%VRAD(:)

  IF(WLR_FLAG .AND. MUOUT(ITHETA)<0.0D0)THEN
     DSTOKES(IDTAU,ITHETA,IPHI,:)=0.0D0
  ELSE   
     DSTOKES(IDTAU,ITHETA,IPHI,:)=RADDETU(ITHETA,:)
  ENDIF
ENDDO  !ITHETA
ENDDO  ! LOOP IPHI
ENDDO  ! LOOP IDTAU

ELSE ! no RAD_MAP

IF(WLR_FLAG) THEN
   WRITE(*,*) 'WLR_FLAG FOR (RAD_MAP=.FALSE.) IS NOT IMPLEMENTED'
   WRITE(*,*) 'SET RAD_MAP=.TRUE. AND RETRY'
   STOP
ENDIF

ALLOCATE(RADDETK(NQUADA,4),LRADA(NQUADA,1:NDTAUA,NPHIOUT) )

IF(SNG_RAD_CORR) THEN !SINGLE SCATTERING CORRECTION WITHOUT MAPPING
  DO ICOM1=1,4
    LSPA(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1) =            &
         LSPA(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1) -       &
         LSPMNA_SNG(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1) - &
         LSPA_SNG_RO(1:NQUADA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1)
  ENDDO
ENDIF

ALLOCATE(LSPATMP(NQUADA,0:MAXMORD),LRADATMP(NQUADA,NPHIOUT))
DO IDTAU=1,NDTAUA
  LSPATMP(1:NQUADA,0:MAXMORD)=LSPA(1:NQUADA,INDXDETA(IDTAU),0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NQUADA,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPATMP,LRADATMP)
  LRADA(1:NQUADA,IDTAU,1:NPHIOUT)=LRADATMP(1:NQUADA,1:NPHIOUT)
ENDDO

DEALLOCATE(LSPATMP,LRADATMP)

! CORRECT FOR SINGLE SCATTERING FORWARD PEAK
IF(SNG_RAD_CORR .AND. FWDCN_CORR_FLAG) THEN !SINGLE SCATTERING CORRECTION WITHOUT MAPPING
 FLAG1=OCEAN .AND. FLATO
 FLAG2=(.NOT. OCEAN) .AND. LAMB .AND. (FLAM<1.0D0)
 IF(FLAG1 .OR. FLAG2) THEN !FLAT OCEAN OR LAMBERTIAN MIXTURE WITH SPECULAR REFLECTION
 
  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NPHIOUT))

  LSPATMP(1:NQDAD2,0:MAXMORD)= &
          LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPATMP,LRADATMP)
 
  DO ITHETA=1,NMUOUTSHFLA
    IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
    THETA1=ACOS(MUOUTSHFLA(ITHETA))
    IF(FLAG1)THEN
      CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)
    ELSE
      CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)
      FRES_MTRX=FRES_MTRX*(1.0D0-FLAM)
    ENDIF
    COST1=MU_IN
    COST2=-MUOUTSHFLA(ITHETA)

    SINT1=SQRT(1.0D0-COST1*COST1)
    SINT2=SQRT(1.0D0-COST2*COST2)
    MUTMP(1)=-MUOUTSHFLA(ITHETA)
    DO IPHI=1,NPHIOUT
      MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHIOUT(IPHI))
      IF(MUSCAT>MINMUFWDCN)THEN
         DO ICOM1=1,4
          RADATMP(1:NQDAD2,ICOM1)=LRADATMP(1:NQDAD2,IPHI)%VRAD(ICOM1)
         ENDDO
          CALL RADINTPL2(MPLIN,NQDAD2,XJA,RADATMP,1,MUTMP,RADOUTTMP)
          ARRY1(:)=RADOUTTMP(1,:)
          ! SEARCH LRAD FROM FORWARD CONE
          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHIOUT(IPHI),ARRY2)
          ARRY1=ARRY2-ARRY1
          ARRY1=MATMUL(FRES_MTRX,ARRY1)
      ELSE
       CYCLE
      ENDIF
       DO IDTAU=1,NDTAUA
         IF(FLAG1)THEN
            RTMP1=OITAU
         ELSE
            RTMP1=TOTALTAU
         ENDIF
         RTMP=DABS((TAU(INDXDETA(IDTAU))-RTMP1)/MUOUTSHFLA(ITHETA))
         LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD=       &
              LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD + &
                                 EXP(-RTMP)*ARRY1        
       ENDDO ! IDTAU LOOP

    ENDDO
  ENDDO

  DEALLOCATE(MUTMP,RADOUTTMP,LSPATMP,LRADATMP)

 ENDIF !FLAT OCEAN OR LAMBERTIAN MIXTURE WITH SPECULAR REFLECTION

! ATMOSPHERE LAYERS MU>0 resultant from first order
! Sky light reflectance correction, ROUGH OCEAN
!! This section is commented out on April 15, 2014 by Pengwang Zhai
!! The reason is that this correction may have violated energy conservation.
!! More thinking is needed to take this into account appropriatedly.

! IF(OCEAN .AND. (.NOT. FLATO))THEN
!  NUMPHI=400
!  ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
!  CALL gauleg(-PI,PI,PHI_TMP,WPHI_TMP,NUMPHI)
!
!  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
!  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NUMPHI))
!
!  LSPATMP(1:NQDAD2,0:MAXMORD)= &
!          LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                           LSPATMP,LRADATMP)
!
!  COST1=MU_IN
!  SINT1=SQRT(1.0D0-COST1*COST1)
!
!  DO ITHETA=1,NMUOUTSHFLA
!  IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
!  DO IPHI=1,NPHIOUT
!     ARRY3=0.0D0
!     DO IQUAD=1,NQDAD2
!
!        COST2=XJA(IQUAD)
!        SINT2=SQRT(1.0D0-COST2*COST2)
!
!     DO IPHI_TMP=1,NUMPHI
!       MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI_TMP(IPHI_TMP))
!       IF(MUSCAT>MINMUFWDCN)THEN
!      ! SEARCH LRAD FROM FORWARD CONE
!          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHI_TMP(IPHI_TMP),ARRY2)
!          ARRY1=ARRY2-LRADATMP(IQUAD,IPHI_TMP)%VRAD(:)
!       ELSE
!          CYCLE
!       ENDIF
!
!       CALL BRDM_OCEAN(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),&
!                       PHIOUT(IPHI),NWRE,NWIM,MTRX1)
!       IF(SCL)THEN
!         ARRY3(1)=ARRY3(1)+MTRX1(1,1)*ARRY1(1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ELSE
!         ARRY3=ARRY3+MATMUL(MTRX1,ARRY1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ENDIF
!     ENDDO
!     ENDDO
!     IF(WCFLG)ARRY3=ARRY3*(1.0D0-FWC)
!     DO IDTAU=1,NDTAUA
!         RTMP=DABS((TAU(INDXDETA(IDTAU))-OITAU)/MUOUTSHFLA(ITHETA))
!         LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD=         &
!                LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD + &
!                                EXP(-RTMP)*ARRY3
!     ENDDO ! IDTAU LOOP
!
!  ENDDO
!  ENDDO
!
!  DEALLOCATE(LSPATMP,LRADATMP,MUTMP,RADOUTTMP)
!  DEALLOCATE(PHI_TMP,WPHI_TMP)
! ENDIF ! ROUGH OCEAN IF FOR SKY LIGHT REFLECTANCE
ENDIF ! SNG_RAD_CORR .AND. FWDCN_CORR_FLAG if

! GET OUTPUT FOR USER DEFINED ZENITH ANGLES
DO IDTAU=1,NDTAUA
DO IPHI=1,NPHIOUT
 DO IQUAD=1,NQUADA
   RADDETK(IQUAD,1)=LRADA(IQUAD,IDTAU,IPHI)%VRAD(1)
   RADDETK(IQUAD,2)=LRADA(IQUAD,IDTAU,IPHI)%VRAD(2)
   RADDETK(IQUAD,3)=LRADA(IQUAD,IDTAU,IPHI)%VRAD(3)
   RADDETK(IQUAD,4)=LRADA(IQUAD,IDTAU,IPHI)%VRAD(4)
 ENDDO
 CALL RADINTPL2(MPLIN,NQUADA,XJA,RADDETK,NTHETAOUT,MUOUT,RADDETU)
 IF(SNG_RAD_CORR) THEN !SINGLE SCATTERING CORRECTION WITHOUT MAPPING
  DO ITHETA=1,NTHETAOUT
!    DO IMU=1,NMUOUTSHFLA
!     IF(ABS(MUOUT(ITHETA)-MUOUTSHFLA(IMU))<1.0E-4)EXIT
!    ENDDO
	INTARR=MINLOC(ABS(MUOUT(ITHETA)-MUOUTSHFLA))
	IMU=INTARR(1)
!    IF(ABS(MUOUT(ITHETA)-MUOUTSHFLA(IMU))>1.0E-5)STOP 'CHECK IMU SEARCH 2'
    IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)THEN
        ARRY1=RADDETU(ITHETA,:)+LRADA_SNG(IMU,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)
		ARRY2=ARRY1/ARRY1(1)

        RTMP=RADDETU(ITHETA,1)/LRADA_SNG(IMU,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)
        RTMP1=(1.0D0+RTMP)*LRADA_SNG_SPSH(IMU,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)
        ARRY3=ARRY2*RTMP1
		RADDETU(ITHETA,:)=ARRY3(:)
    ELSE
		RADDETU(ITHETA,:)=RADDETU(ITHETA,:) + &
		   LRADA_SNG(IMU,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)
    ENDIF
  ENDDO  !ITHETA
 ENDIF

DO ITHETA=1,NTHETAOUT
	DIFF_FLG=.true.
	CALL RADACMDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
				  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	IF(WCFLG) ARRY1=ARRY1*(1.0D0-FWC)

	IF((.NOT. WLR_FLAG) .AND. (MUOUT(ITHETA)>0.0D0) &
							.AND. SGLNT .AND. OCEAN) &
		RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	IF((MUOUT(ITHETA)>0.0D0).AND. OCEAN .AND. SURFACE_GLINT_FLAG) THEN
		DSTOKES_GLINT(IDTAU,ITHETA,IPHI,:)=ARRY1(:)
	ENDIF

	IF(pBRDF) THEN
	  DIFF_FLG=.true.
	  CALL RADALandDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)
	ELSEIF(fSnowBRDF)THEN
	  DIFF_FLG=.true.
	  CALL RADASnowDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	ELSEIF(fRossLiBRDF)THEN
	  DIFF_FLG=.true.
	  CALL RADARossLiDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
	  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

	ENDIF

	DSTOKES(IDTAU,ITHETA,IPHI,:)=RADDETU(ITHETA,:)

ENDDO  !ITHETA
ENDDO  ! LOOP IPHI
ENDDO  ! LOOP IDTAU
DEALLOCATE(RADDETK)

ENDIF ! SNG_RAD_CORR .and. RAD_MAP IF

DEALLOCATE(RADDETU)

ENDIF  ! deta if

IF(DETO) THEN

ALLOCATE(RADDETU(NTHETAOUT,4))

DO IDTAU=1,NDTAUO
!WRITE(9,"('TAUDETO(',I8,')=',ES13.6)")IDTAU,TAUDETO(IDTAU)

ENGREFL=0.0D0
DO IQUAD=1,NQDOD2
!ENGREFL=ENGREFL+LSPO(IQUAD,IDTAU,0)%VRAD(1)*WTO(IQUAD)*ABS(XJO(IQUAD))
ENGREFL=ENGREFL+LSPOIRAD(IQUAD,IDTAU)%VRAD(1)*WTO(IQUAD)*ABS(XJO(IQUAD))
ENDDO

ENGREFL=2.0D0*PI*ENGREFL+ENGGLAREO(IDTAU)

!WRITE(9,"('DOWNWELLING IRRADIANCE =',ES13.6)")ENGREFL
DIRAD(IDTAU+NDTAUA,1)=ENGREFL

ENGREFL=0.0D0
DO IQUAD=NQDOD2+1,NQUADO
!ENGREFL=ENGREFL+LSPO(IQUAD,IDTAU,0)%VRAD(1)*WTO(IQUAD)*XJO(IQUAD)
ENGREFL=ENGREFL+LSPOIRAD(IQUAD,IDTAU)%VRAD(1)*WTO(IQUAD)*ABS(XJO(IQUAD))
ENDDO
ENGREFL=2.0D0*PI*ENGREFL
!WRITE(9,"('UPWELLING IRRADIANCE =',ES13.6)")ENGREFL
DIRAD(IDTAU+NDTAUA,2)=ENGREFL
!WRITE(*,"('UPWELLING IRRADIANCE O=',I3,ES13.6)")IDTAU+NDTAUA,DIRAD(IDTAU+NDTAUA,2)
ENDDO ! IDTAU OCEAN
!IF(MUFLG)THEN
!  WRITE(9,'("COS(THETA)",1x,"PHI", 5x,"Radiance", &
!            &7x,  "Q", 16x ,"U", 15x, "V")')
!ELSE
!  WRITE(9,'(2x,"THETA",4x,"PHI", 5x,"Radiance", &
!            &8x,  "Q", 15x ,"U", 15x, "V")')
!ENDIF
IF(SNG_RAD_CORR .AND. RAD_MAP)THEN
  DO ITHETA=1,NTHETAOUT
!    DO IMU=1,NMUOUTSHFLO
!     IF(ABS(MUOUT(ITHETA)-MUOUTSHFLO(IMU))<1.0E-4)EXIT
!    ENDDO

	INTARR=MINLOC(ABS(MUOUT(ITHETA)-MUOUTSHFLO))
	IMU=INTARR(1)
	IF(ABS(MUOUT(ITHETA)-MUOUTSHFLO(IMU))>1.0E-5)STOP 'CHECK IMU SEARCH 3'

  DO IDTAU=1,NDTAUO
  DO IPHI=1,NPHIOUT

	DSTOKES(IDTAU+NDTAUA,ITHETA,IPHI,:)= LRADO(IMU,IDTAU,IPHI)%VRAD(:)

	DIFF_FLG=.true.
	CALL RADOCMDRCT(MU_IN,TAU((INDXDETO(IDTAU))),MUOUT(ITHETA), &
				PHIOUT(IPHI),ARRY1,DIFF_FLG)
	IF(WCFLG) ARRY1=ARRY1*(1.0D0-FWC)

    IF((MUOUT(ITHETA)<0.0D0) .AND. SGLNT ) THEN
		DSTOKES(IDTAU+NDTAUA,ITHETA,IPHI,:)= ARRY1(:) + &
						DSTOKES(IDTAU+NDTAUA,ITHETA,IPHI,:)
    ENDIF

	IF((MUOUT(ITHETA)<0.0D0) .AND. SURFACE_GLINT_FLAG) THEN
		DSTOKES_GLINT(IDTAU+NDTAUA,ITHETA,IPHI,:)=ARRY1(:)
	ENDIF

  ENDDO
  ENDDO
  ENDDO  ! LOOP IDTAU
ELSE
  ALLOCATE(LRADO(NQUADO,NDTAUO,NPHIOUT),RADDETK(NQUADO,4))

IF(SNG_RAD_CORR)THEN
  DO ICOM1=1,4
    LSPO(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM1) =        &
         LSPO(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM1) -   &
         LSPMNO_SNG(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM1)
  ENDDO
  IF(RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG)THEN
    MAXMLOCAL=MIN(2,MAXMORD)
    DO ICOM1=1,4
      LSPO(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMLOCAL)%VRAD(ICOM1) =        &
         LSPO(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMLOCAL)%VRAD(ICOM1) -   &
         LSPMNO_INELASTIC_SNG(1:NQUADO,OLYR(1)%ITAUS:NTTAU,0:MAXMLOCAL)%VRAD(ICOM1)
    ENDDO
  ENDIF


ENDIF

DO IDTAU=1,NDTAUO
DO IPHI=1,NPHIOUT
  DO IQUAD=1,NQUADO
  LRADO(IQUAD,IDTAU,IPHI)%VRAD=0.0D0
  LRADO(IQUAD,IDTAU,IPHI)%VRAD(1)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(1) + &
          LSPO(IQUAD,INDXDETO(IDTAU),0)%VRAD(1)
  LRADO(IQUAD,IDTAU,IPHI)%VRAD(2)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(2) + &
          LSPO(IQUAD,INDXDETO(IDTAU),0)%VRAD(2)
  DO M=1,MAXMORD
   LRADO(IQUAD,IDTAU,IPHI)%VRAD(1)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(1) + &
       2.0D0*COS(M*PHIOUT(IPHI))*LSPO(IQUAD,INDXDETO(IDTAU),M)%VRAD(1)
   LRADO(IQUAD,IDTAU,IPHI)%VRAD(2)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(2) + &
      2.0D0*COS(M*PHIOUT(IPHI))*LSPO(IQUAD,INDXDETO(IDTAU),M)%VRAD(2)
   LRADO(IQUAD,IDTAU,IPHI)%VRAD(3)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(3) + &
      2.0D0*SIN(M*PHIOUT(IPHI))*LSPO(IQUAD,INDXDETO(IDTAU),M)%VRAD(3)
   LRADO(IQUAD,IDTAU,IPHI)%VRAD(4)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(4) + &
      2.0D0*SIN(M*PHIOUT(IPHI))*LSPO(IQUAD,INDXDETO(IDTAU),M)%VRAD(4)
  ENDDO
  ENDDO
ENDDO
ENDDO

! CORRECT FOR SINGLE SCATTERING FORWARD PEAK

IF(SNG_RAD_CORR .AND. FWDCN_CORR_FLAG) THEN !SINGLE SCATTERING CORRECTION WITHOUT MAPPING
 
 IF(OCEAN .AND. FLATO .AND. (.NOT. OCEAN_NO_TRAN)) THEN
 
  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NPHIOUT))

  LSPATMP(1:NQDAD2,0:MAXMORD)= &
          LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPATMP,LRADATMP)
 
 DO ITHETA=1,NMUOUTSHFLO
    IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
    THETA2=ACOS(-MUOUTSHFLO(ITHETA))
    THETA1=SIN(THETA2)*NWRE
    IF(THETA1>1.0D0)CYCLE
    THETA1=ASIN(THETA1)
    CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_MTRX)

    COST1=MU_IN
    COST2=-COS(THETA1)

    SINT1=SQRT(1.0D0-COST1*COST1)
    SINT2=SQRT(1.0D0-COST2*COST2)
    MUTMP(1)=COST2
    DO IPHI=1,NPHIOUT
      MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHIOUT(IPHI))
      IF(MUSCAT>MINMUFWDCN)THEN
         DO ICOM1=1,4
          RADATMP(1:NQDAD2,ICOM1)=LRADATMP(1:NQDAD2,IPHI)%VRAD(ICOM1)
         ENDDO
          CALL RADINTPL2(MPLIN,NQDAD2,XJA,RADATMP,1,MUTMP,RADOUTTMP)
          ARRY1(:)=RADOUTTMP(1,:)
          ! SEARCH LRAD FROM FORWARD CONE
          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHIOUT(IPHI),ARRY2)
          ARRY1=ARRY2-ARRY1
          ARRY1=MATMUL(FRES_MTRX,ARRY1)
          ARRY1=ARRY1*NSQW
      ELSE
       CYCLE
      ENDIF
      DO IDTAU=1,NDTAUO
         RTMP=DABS((TAU(INDXDETO(IDTAU))-OITAU)/MUOUTSHFLO(ITHETA))
         LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD=       &
              LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD + &
                                 EXP(-RTMP)*ARRY1        
      ENDDO ! IDTAU LOOP

    ENDDO
 ENDDO

 DEALLOCATE(MUTMP,RADOUTTMP,LSPATMP,LRADATMP)

 ENDIF !FLAT OCEAN TRANSMITTANCE FOR DIFFERENCE OF FORWARD SCATTERING AREA

! ATMOSPHERE LAYERS MU>0 resultant from first order 
! Sky light transmission correction, ROUGH OCEAN
!! This section is commented out on April 15, 2014 by Pengwang Zhai
!! The reason is that this correction may have violated energy conservation.
!! More thinking is needed to take this into account appropriatedly.
!IF(OCEAN .AND. (.NOT. FLATO) .AND. (.NOT. OCEAN_NO_TRAN))THEN
!  NUMPHI=400
!  ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
!  CALL gauleg(-PI,PI,PHI_TMP,WPHI_TMP,NUMPHI)
!
!  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
!  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NUMPHI))
!
!  LSPATMP(1:NQDAD2,0:MAXMORD)= &
!          LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                           LSPATMP,LRADATMP)
!
!  COST1=MU_IN
!  SINT1=SQRT(1.0D0-COST1*COST1)
!
!  DO ITHETA=1,NMUOUTSHFLO
!  IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
!  DO IPHI=1,NPHIOUT
!     ARRY3=0.0D0
!     DO IQUAD=1,NQDAD2
!
!        COST2=XJA(IQUAD)
!        SINT2=SQRT(1.0D0-COST2*COST2)
!
!     DO IPHI_TMP=1,NUMPHI
!       MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI_TMP(IPHI_TMP))
!       IF(MUSCAT>MINMUFWDCN)THEN
!      ! SEARCH LRAD FROM FORWARD CONE
!          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHI_TMP(IPHI_TMP),ARRY2)
!          ARRY1=ARRY2-LRADATMP(IQUAD,IPHI_TMP)%VRAD(:)
!       ELSE
!          CYCLE
!       ENDIF
!       CALL BTDM_AT_OCEAN(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLO(ITHETA),&
!                          PHIOUT(IPHI),NWRE,NWIM,MTRX1)
!       IF(SCL)THEN
!        ARRY3(1)=ARRY3(1)+MTRX1(1,1)*ARRY1(1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ELSE
!        ARRY3=ARRY3+MATMUL(MTRX1,ARRY1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ENDIF
!     ENDDO
!     ENDDO
!     IF(WCFLG)ARRY3=ARRY3*(1.0D0-FWC)
!     DO IDTAU=1,NDTAUO
!         RTMP=DABS((TAU(INDXDETO(IDTAU))-OITAU)/MUOUTSHFLO(ITHETA))
!         LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD=         &
!                LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD + &
!                                EXP(-RTMP)*ARRY3
!     ENDDO ! IDTAU LOOP
!
!  ENDDO
!  ENDDO
!
!  DEALLOCATE(LSPATMP,LRADATMP,MUTMP,RADOUTTMP)
!  DEALLOCATE(PHI_TMP,WPHI_TMP)
!ENDIF ! ROUGH OCEAN IF FOR SKY LIGHT transmission
ENDIF ! SNG_RAD_CORR if


DO IDTAU=1,NDTAUO
DO IPHI=1,NPHIOUT
	DO IQUAD=1,NQUADO
		RADDETK(IQUAD,1)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(1)
		RADDETK(IQUAD,2)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(2)
		RADDETK(IQUAD,3)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(3)
		RADDETK(IQUAD,4)=LRADO(IQUAD,IDTAU,IPHI)%VRAD(4)
	ENDDO

	CALL RADINTPL2(2,NQUADO,XJO,RADDETK,NTHETAOUT,MUOUT,RADDETU)
	IF(SNG_RAD_CORR) THEN !SINGLE SCATTERING CORRECTION WITHOUT MAPPING
	DO ITHETA=1,NTHETAOUT
!		DO IMU=1,NMUOUTSHFLO
!		 IF(ABS(MUOUT(ITHETA)-MUOUTSHFLO(IMU))<1.0E-4)EXIT
!		ENDDO

		INTARR=MINLOC(ABS(MUOUT(ITHETA)-MUOUTSHFLO))
		IMU=INTARR(1)
		IF(ABS(MUOUT(ITHETA)-MUOUTSHFLO(IMU))>1.0E-5)STOP 'CHECK IMU SEARCH 4'

		RADDETU(ITHETA,:)=RADDETU(ITHETA,:) + &
			 LRADO_SNG(IMU,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD(:)
	ENDDO  !ITHETA
	ENDIF

	DO ITHETA=1,NTHETAOUT
		DIFF_FLG=.true.
		CALL RADOCMDRCT(MU_IN,TAU((INDXDETO(IDTAU))),MUOUT(ITHETA), &
					  PHIOUT(IPHI),ARRY1,DIFF_FLG)
		IF(WCFLG) ARRY1=ARRY1*(1.0D0-FWC)

		IF((MUOUT(ITHETA)<0.0D0) .AND. SGLNT ) THEN
			RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1
		ENDIF
		DSTOKES(IDTAU+NDTAUA,ITHETA,IPHI,:)=RADDETU(ITHETA,:)

		IF((MUOUT(ITHETA)<0.0D0) .AND. SURFACE_GLINT_FLAG) THEN
			DSTOKES_GLINT(IDTAU+NDTAUA,ITHETA,IPHI,:)=ARRY1(:)
		ENDIF

	ENDDO

ENDDO
ENDDO
DEALLOCATE(RADDETK)
ENDIF ! SNG_RAD_CORR IF
DEALLOCATE(RADDETU)
ENDIF  ! DETO if

DEALLOCATE(SDML0,SDML2P,SDML2N)

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) THEN
    DEALLOCATE(SPMO,XJSO,WTSO,SFRES_TRANA)
ENDIF
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) ) &
  DEALLOCATE(DML0SO,DML2PSO,DML2NSO)
IF(FLATO .OR. (LAMB .AND. FLAM<1.0D0))DEALLOCATE(SRDML0,SRDML2P,SRDML2N)
IF(OCEAN .AND. (.NOT. FLATO))DEALLOCATE(SFRES_REFLA)
IF(OCEAN .AND. (ENORM_FLAT .OR. ENGFACNORM)) &
    DEALLOCATE(MU_CM,REFL_CM_AT,TRAN_CM_AT,REFL_CM_OT,TRAN_CM_OT)
IF(pBRDF .or. fSnowBRDF .or. fRossLiBRDF)DEALLOCATE(SFRES_REFLA)
IF(DETA)DEALLOCATE(LRADA)
IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) DEALLOCATE(LRADA_SNG_SPSH)
IF(SNG_RAD_CORR) DEALLOCATE(LRADA_SNG)

IF(DETO)DEALLOCATE(LRADO)
IF(SNG_RAD_CORR .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) DEALLOCATE(LRADO_SNG)

DEALLOCATE(MUOUTSHFLA,MUOUTSHFLO)
IF(FWDCN_CORR_FLAG)DEALLOCATE(LRADA_FWDCN_SNG)

IF(OCEAN .AND. (.NOT. FLATO)) DEALLOCATE(SHDWXJA)

CALL PHMX_COEFF_DEALLO

DEALLOCATE(BT_Planck)
DEALLOCATE(ALYR,DML0A,DML2PA,DML2NA,LSPMNA,SOURCEFA,           &
           SRCFAP,PMA,SPMA,TAU,DTAUMUADW,DTAUMUAUP,EXPTAUADW,  &
		   EXPTAUAUP,COEFALDW,COEFALUP,TAU_PRSV,LBDO_A_PRSV,LBDO_O_PRSV)
DEALLOCATE(HEIGHT_ATMOSPHERE)
DEALLOCATE(SECANT_THETAL,SECANT_THETAL_PRSV)
DEALLOCATE(LSPMNA_SNG,LSPA_SNG_RO)

IF(RAD_MAP)DEALLOCATE(PMAX)
IF(RAD_MAP)DEALLOCATE(DML0XA,DML2PXA,DML2NXA)
IF(RAD_MAP.AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) &
            DEALLOCATE(DML0XO,DML2PXO,DML2NXO)
IF(OSFREXP .AND. OCEAN .AND. (.NOT. FLATO)) &
  DEALLOCATE(WBETAL,WALPHAL, WZETAL,WDELTAL,WGAMMAL,WEPSILONL)

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) THEN 
  DEALLOCATE(XJO,WTO,OLYR,DML0O,DML2PO,DML2NO,LSPMNO,  &
	  SOURCEFO,SRCFOP,PMO,XJAD2,XJOD2,&
	  DTAUMUODW,DTAUMUOUP,EXPTAUODW,EXPTAUOUP,RADOTMP,RADOTMP1)
  DEALLOCATE(LSPMNO_SNG)
  IF(RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG)DEALLOCATE(LSPMNO_INELASTIC_SNG)
  IF(RAD_MAP)DEALLOCATE(PMOX)
ENDIF
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. (.NOT.FLATO))&
   DEALLOCATE(FRES_TRANA,FRES_TRANO,FRES_REFLO,XJAT,WTAT,XJOT,WTOT,     &
	            DML0AT,DML2PAT,DML2NAT,DML0OT,DML2POT,DML2NOT)

IF(FLATO .OR. (LAMB .AND. FLAM<1.0D0)) DEALLOCATE(SRPMA)

IF(FLATO)THEN
  DEALLOCATE(FRSNLAR)
  IF(.NOT. OCEAN_NO_TRAN)DEALLOCATE(FRSNLWR,FRSNLAT,FRSNLWT)
ENDIF

IF(LAMB .AND. FLAM<1.0D0)DEALLOCATE(FRSNLMBR)
IF((OCEAN .AND. (.NOT. FLATO)) .OR. pBRDF .or. fSnowBRDF .or. fRossLiBRDF) &
      DEALLOCATE(FRES_REFLA)

DEALLOCATE(DMM0FCTR,DMM2FCTR,COEF1,COEF2,COEF3,COEF4,COEF5,COEF6)

DEALLOCATE(XJA,WTA)

DEALLOCATE(RADATMP,RADATMP1)

DEALLOCATE(LSPA,LSPANM1,LSPAN,LSPAIRAD,LSPAIRADNM1,LSPAIRADN)
IF(DETA)DEALLOCATE(INDXDETA,INDXREVA,TAUDETA,INDXDETA_SNGSCAT,ENGGLAREA)
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) &
      DEALLOCATE(LSPO,LSPONM1,LSPON,LSPOIRAD,LSPOIRADN,LSPOIRADNM1)
IF(DETO)DEALLOCATE(INDXDETO,TAUDETO,INDXDETO_SNGSCAT,ENGGLAREO)

CLOSE(9)

END SUBROUTINE RTSOS

SUBROUTINE CALHKW
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
INTEGER K,IQUAD1,IQUAD2,L,LPS,LMS
REAL*8 :: THETA1,SINT1,SINT2,COST1,COST2,CAPA,LITA,LITB, &
	   MUDIFFSQ,MUDIFFQU,RTMP,RTMP1,TWOCOS,EXPBA,SHDWFCT
TYPE(MATRIX44),DIMENSION(:),ALLOCATABLE::RTMX
REAL*8,DIMENSION(:,:,:),ALLOCATABLE :: HKWAR,HKWAT,HKWOT
INTEGER :: NUMPHI,IPHI
REAL*8 :: THRESH1,THRESH2,THRESH3,PHIRG,E1O12
REAL*8 :: SINMPHI,COSMPHI
REAL*8,DIMENSION(4,4)::FFINT,TEM1,TEM2
REAL*8,DIMENSION(:), ALLOCATABLE::PHI,WPHI

REAL*8,DIMENSION(:), ALLOCATABLE::ENGFCTAI,ENGFCTOI

  ! HKW() IS FUNCTIONS OF: VARIABLE MU',VARIABLE MU,ORDER K 

REAL*8 expbessi,SHADOW,REFL_COEFF,TRAN_COEFF
LOGICAL FLAG1,FLAG2
EXTERNAL expbessi,SHADOW


IF(OSFREXP)THEN
  ALLOCATE(HKWAR(1:NQDAD2,NQDAD2+1:NQUADA,0:MAXKORD))
  IF(.NOT. OCEAN_NO_TRAN)  &
     ALLOCATE(HKWAT(1:NQDAD2,1:NQDOD2,0:MAXKORD),&
         HKWOT(NQDOD2+1:NQUADO,NQDAD2+1:NQUADA,0:MAXKORD))
ENDIF

ALLOCATE(SHDWXJA(NQUADA))
ALLOCATE(ENGFCTAI(NQDAD2))
ENGFCTAI=0.0D0

IF(.NOT. OCEAN_NO_TRAN) THEN 
  ALLOCATE(SHDWXJO(NQUADO))
  ALLOCATE(ENGFCTOI(NQDOD2+1:NQUADO))
  ENGFCTOI=0.0D0
ENDIF

CALL RTWVSF

IF(SHDWFLG)THEN
  DO IQUAD1=1,NQUADA
    SHDWXJA(IQUAD1)=SHADOW(XJA(IQUAD1),SIGMASQ)
  ENDDO
ELSE
  SHDWXJA=1.0D0
ENDIF

IF(.NOT. OCEAN_NO_TRAN)THEN
  IF(SHDWFLG)THEN
    DO IQUAD1=1,NQUADO
      SHDWXJO(IQUAD1)=SHADOW(XJO(IQUAD1),SIGMASQ)
    ENDDO
  ELSE
    SHDWXJO=1.0D0
  ENDIF
ENDIF

THRESH1=-LOG(1.0D-307)*SIGMASQ
THRESH2=-LOG(1.0D-37)*SIGMASQ
THRESH3=-LOG(1.0D-20)  !threshold to do integration over phi,
                       ! \phi=[0,pi/2]
E1O12=11.0D0/12.0D0
NUMPHI=100

ALLOCATE(PHI(NUMPHI),WPHI(NUMPHI))

IF(OSFREXP)THEN 

ALLOCATE(RTMX(0:MAXKORD))

HKWAR=0.0D0
DO IQUAD1=1,NQDAD2
COST1=XJA(IQUAD1)
SINT1=DSQRT(1.0D0-COST1*COST1)
DO IQUAD2=NQDAD2+1,NQUADA
  COST2=XJA(IQUAD2)
  SINT2=DSQRT(1.0D0-COST2*COST2)
  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)
  MUDIFFQU=MUDIFFSQ*MUDIFFSQ
  CAPA=1.0D0/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
  LITA=(2.0D0-COST1*COST1-COST2*COST2)/SIGMASQ/MUDIFFSQ
  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ
  IF(SHDWFLG)THEN
    SHDWFCT=1.0D0/(1.0D0+SHDWXJA(IQUAD1)+SHDWXJA(IQUAD2))
  ELSE
    SHDWFCT=1.0D0
  ENDIF
! bessi(k,LITB) is not bounded.  It is easy to overflow
! USE exp(-litb)*bessi(k,LITB) instead.

  IF(ABS(COST1)<0.1D0 .AND. ABS(COST2)<0.1D0)THEN
    RTMP=(COST1+COST2)
	RTMP=-RTMP*RTMP*(0.25D0+0.125D0*(COST1*COST1+COST2*COST2))/SIGMASQ
    EXPBA=EXP(RTMP)
  ELSE
    EXPBA=EXP(LITB-LITA)
  ENDIF
  RTMP=CAPA*EXPBA*SHDWFCT
  DO K=0,MAXKORD
     HKWAR(IQUAD1,IQUAD2,K)= RTMP*expbessi(K,LITB)
  ENDDO

ENDDO
ENDDO


ENDIF  ! OSFREXP = .TRUE. CALCULATE HKW

DO IQUAD1=1,NQDAD2
DO IQUAD2=NQDAD2+1,NQUADA

FLAG1=.NOT.OSFREXP
FLAG2=ABS(XJA(IQUAD1))<0.1D0 .AND. ABS(XJA(IQUAD2))<0.1D0

IF(FLAG1 .OR. FLAG2)THEN
  COST1=XJA(IQUAD1)
  COST2=XJA(IQUAD2)

  SINT1=DSQRT(1.0D0-COST1*COST1)
  SINT2=DSQRT(1.0D0-COST2*COST2)

  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)
  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ

  IF (LITB>THRESH3)THEN
!    PHIRG=ACOS(1.0D0-THRESH3/LITB)
     PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG
  ELSE
    PHIRG=PI
  ENDIF
  CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
  WPHI=WPHI/TWOPI
  
  DO K=0,MAXMORD
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:)=0.0D0
    FFINT=0.0D0
    DO IPHI=1,NUMPHI
      SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
      COSMPHI=COS(DFLOAT(K)*PHI(IPHI))
      
      CALL BRDM_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM1)
      IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BRDM_DS_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM2)
        TEM1=TEM1+TEM2
      ENDIF

      FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)

      IF(SCL)CYCLE

      FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
      FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
      FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
      FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
      FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

      FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
      FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
      FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
      FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
    ENDDO   !PHI DO
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,1)=FFINT(1,1)

    IF(SCL)CYCLE

    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(4,4)=FFINT(4,4)

    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,3)=FFINT(1,3)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,3)=FFINT(2,3)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
    FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,2)=FFINT(3,2)

!if(k==2  .and. iquad1==3)&
!write(*,*)'di ar',FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(1,1),&
!                  FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(1,2),&
!				  FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(1,3),&
! 				  FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(1,4)

  ENDDO  !LOOP K

ELSE !USE COMBINITION

DO K=0,MAXMORD
!! COSINE EXPANSION TERMS
  RTMX(K)%PHMX(:,:)=0.0D0
  RTMX(K)%PHMX(1,1)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(1,1)
  RTMX(K)%PHMX(1,2)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(1,2)
  RTMX(K)%PHMX(2,1)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(2,1)
  RTMX(K)%PHMX(2,2)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(2,2)

  RTMX(K)%PHMX(3,3)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(3,3)
  RTMX(K)%PHMX(3,4)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(3,4)
  RTMX(K)%PHMX(4,3)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(4,3)
  RTMX(K)%PHMX(4,4)=HKWAR(IQUAD1,IQUAD2,K) &
        *FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(4,4)

  DO L=1,MAXSORD
  LPS=L+K
  LMS=ABS(L-K)

  RTMP=HKWAR(IQUAD1,IQUAD2,LMS)+HKWAR(IQUAD1,IQUAD2,LPS)
  RTMP1=HKWAR(IQUAD1,IQUAD2,LMS)-HKWAR(IQUAD1,IQUAD2,LPS)
!! COSINE EXPANSION TERMS

  RTMX(K)%PHMX(1,1)=RTMX(K)%PHMX(1,1)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(1,1)*RTMP

  IF(SCL)CYCLE

  RTMX(K)%PHMX(1,2)=RTMX(K)%PHMX(1,2)+ &
		  FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(1,2)*RTMP
  RTMX(K)%PHMX(2,1)=RTMX(K)%PHMX(2,1)+ &
		  FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(2,1)*RTMP
  RTMX(K)%PHMX(2,2)=RTMX(K)%PHMX(2,2)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(2,2)*RTMP

  RTMX(K)%PHMX(3,3)=RTMX(K)%PHMX(3,3)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(3,3)*RTMP
  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
		  FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(4,4)*RTMP
  
!! SINE EXPANSION TERMS
  RTMX(K)%PHMX(1,3)=RTMX(K)%PHMX(1,3)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(1,3)*RTMP1
  RTMX(K)%PHMX(1,4)=RTMX(K)%PHMX(1,4)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(1,4)*RTMP1
  RTMX(K)%PHMX(2,3)=RTMX(K)%PHMX(2,3)+ &
		  FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(2,3)*RTMP1
  RTMX(K)%PHMX(2,4)=RTMX(K)%PHMX(2,4)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(2,4)*RTMP1

  RTMX(K)%PHMX(3,1)=RTMX(K)%PHMX(3,1)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(3,1)*RTMP1
  RTMX(K)%PHMX(3,2)=RTMX(K)%PHMX(3,2)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(3,2)*RTMP1
  RTMX(K)%PHMX(4,1)=RTMX(K)%PHMX(4,1)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(4,1)*RTMP1
  RTMX(K)%PHMX(4,2)=RTMX(K)%PHMX(4,2)+ &
          FRES_REFLA(IQUAD1,IQUAD2,L)%PHMX(4,2)*RTMP1
  ENDDO !LOOP L

ENDDO !LOOP K

DO K=0,MAXMORD
  FRES_REFLA(IQUAD1,IQUAD2,K)=RTMX(K)
ENDDO

ENDIF 

!testing FRES_reflA
!DO K=0,MAXMORD
!if(k<4 .and. iquad1==3)then
!write(*,*)'ex Dt',k,xja(iquad1),xja(iquad2)
!write(*,'(4(E13.6,2X))')FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(1,1:4),&
!FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(2,1:4),&
!FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(3,1:4),&
!FRES_reflA(IQUAD1,IQUAD2,K)%PHMX(4,1:4)
!ENDIF
!enddo

ENGFCTAI(IQUAD1)=ENGFCTAI(IQUAD1) &
  +2.0D0*FRES_REFLA(IQUAD1,IQUAD2,0)%PHMX(1,1)*XJA(IQUAD2)*WTA(IQUAD2)
!if(iquad1==28)&
! write(*,*)'ex dr',xja(iquad1),xja(iquad2),FRES_reflA(IQUAD1,IQUAD2,0)%PHMX(1,1),&
!               -ENGFCTAI(IQUAD1)/xja(iquad1)

ENDDO ! LOOP IQUAD2
ENDDO ! LOOP IQUAD1

IF(ENORM_FLAT .OR. ENGFACNORM)THEN

DO IQUAD1=1,NQDAD2
DO IQUAD2=NQDAD2+1,NQUADA

  COST1=XJA(IQUAD1)
  COST2=XJA(IQUAD2)

  SINT1=DSQRT(1.0D0-COST1*COST1)
  SINT2=DSQRT(1.0D0-COST2*COST2)

  THETA1=PI-ACOS(COST1)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL REFL_SEARCH(COST1,FLAG1,REFL_COEFF)
  IF(ENORM_FLAT)THEN
    DO K=0,MAXMORD
      FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:) =  &
           FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:)/REFL_COEFF*TEM1(1,1)
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL TRAN_SEARCH(COST1,FLAG1,TRAN_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO K=0,MAXMORD
      FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:) = &
                FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
  ENDIF
ENDDO
ENDDO
ENDIF

IF(OCEAN_NO_TRAN) THEN
 IF(OSFREXP)DEALLOCATE(HKWAR,RTMX)
 DEALLOCATE(ENGFCTAI,PHI,WPHI)
 RETURN
ENDIF
IF(OSFREXP)THEN

HKWAT=0.0D0
DO IQUAD2=1,NQDOD2
COST2=XJO(IQUAD2)
SINT2=DSQRT(1.0D0-COST2*COST2)

DO IQUAD1=1,NQDAD2
  COST1=XJAT(IQUAD1,IQUAD2)
  SINT1=DSQRT(1.0D0-COST1*COST1)
  MUDIFFSQ=(COST1-NWRE*COST2)
  IF(MUDIFFSQ<1.0D-8)THEN
    DO K=0,MAXKORD
      HKWAT(IQUAD1,IQUAD2,K)=0.0D0
    ENDDO
  ELSE  
    MUDIFFSQ=MUDIFFSQ*MUDIFFSQ
    CAPA=NSQW/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
    TWOCOS=1.0D0-COST1*COST1+NSQW*(1.0D0-COST2*COST2)
    LITA=TWOCOS/SIGMASQ/MUDIFFSQ
    LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ
    IF(SHDWFLG)THEN
!TESTING
      SHDWFCT=1.0D0/(1.0D0+SHADOW(COST1,SIGMASQ)+SHDWXJO(IQUAD2))
!    SHDWFCT=beta(1.0D0+SHADOW(COST1,SIGMASQ),1.0d0+SHDWXJO(IQUAD2))
    ELSE
      SHDWFCT=1.0d0
    ENDIF
    EXPBA=EXP(LITB-LITA)
	RTMP=CAPA*EXPBA*SHDWFCT
    DO K=0,MAXKORD
      HKWAT(IQUAD1,IQUAD2,K)=RTMP*expbessi(K,LITB)
    ENDDO
  ENDIF
ENDDO
ENDDO

HKWOT=0.0D0
DO IQUAD2=NQDAD2+1,NQUADA

COST2=XJA(IQUAD2)
SINT2=DSQRT(1.0D0-COST2*COST2)

DO IQUAD1=NQDOD2+1,NQUADO
  COST1=XJOT(IQUAD1,IQUAD2)
  SINT1=DSQRT(1.0D0-COST1*COST1)
  MUDIFFSQ=(NWRE*COST1-COST2)
  MUDIFFSQ=MUDIFFSQ*MUDIFFSQ
    CAPA=1.0D0/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
    TWOCOS=NSQW*(1.0D0-COST1*COST1)+(1.0D0-COST2*COST2)
    LITA=TWOCOS/SIGMASQ/MUDIFFSQ
    LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ
    IF(SHDWFLG)THEN
      SHDWFCT=1.0D0/(1.0D0+SHADOW(COST1,SIGMASQ)+SHDWXJA(IQUAD2))
    !SHDWFCT=beta(1.0D0+SHADOW(COST1,SIGMASQ),1.0d0+SHDWXJA(IQUAD2))
    ELSE
      SHDWFCT=1.0d0
    ENDIF
    EXPBA=EXP(LITB-LITA)
	RTMP=CAPA*EXPBA*SHDWFCT
	DO K=0,MAXKORD
      HKWOT(IQUAD1,IQUAD2,K)=RTMP*expbessi(K,LITB)
    ENDDO
ENDDO
ENDDO
ENDIF !OSFREXP

DO IQUAD1=1,NQDAD2
DO IQUAD2=1,NQDOD2

COST1=XJAT(IQUAD1,IQUAD2)
COST2=XJO(IQUAD2)

SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)

MUDIFFSQ=COST1-NWRE*COST2
MUDIFFSQ=MUDIFFSQ*MUDIFFSQ
LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ
    
IF(abs(COST1)<0.1D0 .OR. FLAG1)THEN

  IF (LITB>THRESH3)THEN
!     PHIRG=ACOS(1.0D0-THRESH3/LITB)
     PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG
  ELSE
     PHIRG=PI
  ENDIF	

  DO K=0,MAXMORD
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(:,:)=0.0D0

   CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
   WPHI=WPHI/TWOPI
 
   FFINT=0.0D0

   DO IPHI=1,NUMPHI
     SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
     COSMPHI=COS(DFLOAT(K)*PHI(IPHI))

     CALL BTDM_AT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM1)

      IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BTDM_DS_AT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM2)
        TEM1=TEM1+TEM2
      ENDIF

     FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
     IF(SCL)CYCLE

     FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
     FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
     FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
     FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
     FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

     FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
     FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
     FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
     FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
   ENDDO
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
   IF(SCL)CYCLE

   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(4,4)=FFINT(4,4)
	
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(1,3)=FFINT(1,3)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(2,3)=FFINT(2,3)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
   FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(3,2)=FFINT(3,2)

!if(k==2 .and. iquad1==2)&
!write(*,*)'di AT',FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(1,1),&
!                  FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(1,2),&
!				   FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(1,3),& 
!                  FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(1,4)
   ENDDO
ELSE

DO K=0,MAXMORD
!! COSINE EXPANSION TERMS
  RTMX(K)%PHMX(:,:)=0.0D0
  RTMX(K)%PHMX(1,1)=HKWAT(IQUAD1,IQUAD2,K) &
         *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(1,1)
  RTMX(K)%PHMX(1,2)=HKWAT(IQUAD1,IQUAD2,K) &
		 *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(1,2)
  RTMX(K)%PHMX(2,1)=HKWAT(IQUAD1,IQUAD2,K) &
		 *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(2,1)
  RTMX(K)%PHMX(2,2)=HKWAT(IQUAD1,IQUAD2,K) &
         *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(2,2)

  RTMX(K)%PHMX(3,3)=HKWAT(IQUAD1,IQUAD2,K) &
         *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(3,3)
  RTMX(K)%PHMX(3,4)=HKWAT(IQUAD1,IQUAD2,K) &
         *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(3,4)
  RTMX(K)%PHMX(4,3)=HKWAT(IQUAD1,IQUAD2,K) &
		 *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(4,3)
  RTMX(K)%PHMX(4,4)=HKWAT(IQUAD1,IQUAD2,K) &
		 *FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(4,4)

  DO L=1,MAXSORD
  LPS=L+K
  LMS=ABS(L-K)

  RTMP=HKWAT(IQUAD1,IQUAD2,LMS)+HKWAT(IQUAD1,IQUAD2,LPS)
  RTMP1=HKWAT(IQUAD1,IQUAD2,LMS)-HKWAT(IQUAD1,IQUAD2,LPS)
!! COSINE EXPANSION TERMS

  RTMX(K)%PHMX(1,1)=RTMX(K)%PHMX(1,1)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(1,1)*RTMP
  IF(SCL)CYCLE

  RTMX(K)%PHMX(1,2)=RTMX(K)%PHMX(1,2)+ &
		  FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(1,2)*RTMP
  RTMX(K)%PHMX(2,1)=RTMX(K)%PHMX(2,1)+ &
		  FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(2,1)*RTMP
  RTMX(K)%PHMX(2,2)=RTMX(K)%PHMX(2,2)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(2,2)*RTMP

  RTMX(K)%PHMX(3,3)=RTMX(K)%PHMX(3,3)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(3,3)*RTMP
  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
		  FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(4,4)*RTMP
  
!! SINE EXPANSION TERMS
  RTMX(K)%PHMX(1,3)=RTMX(K)%PHMX(1,3)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(1,3)*RTMP1
  RTMX(K)%PHMX(1,4)=RTMX(K)%PHMX(1,4)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(1,4)*RTMP1
  RTMX(K)%PHMX(2,3)=RTMX(K)%PHMX(2,3)+ &
		  FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(2,3)*RTMP1
  RTMX(K)%PHMX(2,4)=RTMX(K)%PHMX(2,4)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(2,4)*RTMP1

  RTMX(K)%PHMX(3,1)=RTMX(K)%PHMX(3,1)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(3,1)*RTMP1
  RTMX(K)%PHMX(3,2)=RTMX(K)%PHMX(3,2)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(3,2)*RTMP1
  RTMX(K)%PHMX(4,1)=RTMX(K)%PHMX(4,1)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(4,1)*RTMP1
  RTMX(K)%PHMX(4,2)=RTMX(K)%PHMX(4,2)+ &
          FRES_TRANA(IQUAD1,IQUAD2,L)%PHMX(4,2)*RTMP1
  ENDDO !LOOP L

ENDDO !LOOP K

DO K=0,MAXMORD
  FRES_TRANA(IQUAD1,IQUAD2,K)=RTMX(K)
ENDDO

ENDIF

!testing FRES_TRANA
!DO K=0,MAXMORD
!if(k<4 .and. iquad2==2)then
!write(*,*)'ex Dt',k,xjat(iquad1,iquad2),xjo(iquad2)
!write(*,'(4(E13.6,2X))')FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(1,1:4),&
!FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(2,1:4),&
!FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(3,1:4),&
!FRES_tranA(IQUAD1,IQUAD2,K)%PHMX(4,1:4)
!ENDIF
!enddo

ENGFCTAI(IQUAD1)=ENGFCTAI(IQUAD1)+              &
        FRES_TRANA(IQUAD1,IQUAD2,0)%PHMX(1,1)*  &
        DABS(XJO(IQUAD2))*WTO(IQUAD2)*2.0D0
!if(iquad1==28)&
!  write(*,*)'ex dr',xja(iquad1),xja(iquad2),FRES_tranA(IQUAD1,IQUAD2,0)%PHMX(1,1),&
!          -ENGFCTAI(IQUAD1)/xja(iquad1)

ENDDO ! LOOP IQUAD2
ENDDO ! LOOP IQUAD1

!testing  
!if NEEDED, xjatallo and xjotallo testing part need to BE turn on
!WRITE(*,*)'ENGFCT AI'
!DO IQUAD1=1,NQDAD2
!  WRITE(*,*)180.0d0-acos(XJA(IQUAD1))/pi*180.0d0,&
!         -ENGFCTAI(IQUAD1)/XJA(IQUAD1)
!ENDDO

IF(ENORM_FLAT .OR. ENGFACNORM)THEN
DO IQUAD1=1,NQDAD2
DO IQUAD2=1,NQDOD2

  COST1=XJAT(IQUAD1,IQUAD2)
  COST2=XJO(IQUAD2)

  THETA1=PI-ACOS(COST1)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL TRAN_SEARCH(COST1,FLAG1,TRAN_COEFF)
  IF(ENORM_FLAT)THEN
    DO K=0,MAXMORD
     FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(:,:)= &
      FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(:,:)/TRAN_COEFF*(1.0D0-TEM1(1,1))
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL REFL_SEARCH(COST1,FLAG1,REFL_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO K=0,MAXMORD
      FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(:,:)= &
           FRES_TRANA(IQUAD1,IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
  ENDIF
ENDDO
ENDDO
ENDIF

DO IQUAD1=NQDOD2+1,NQUADO

  COST1=XJO(IQUAD1)

DO IQUAD2=1,NQDOD2

  COST2=XJO(IQUAD2)
  
  SINT1=DSQRT(1.0D0-COST1*COST1)
  SINT2=DSQRT(1.0D0-COST2*COST2)

  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)
  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ


  IF (LITB>THRESH3)THEN
!     PHIRG=ACOS(1.0D0-THRESH3/LITB)
     PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG
  ELSE
     PHIRG=PI
  ENDIF	

CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
WPHI=WPHI/TWOPI
  
DO K=0,MAXMORD
  FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(:,:)=0.0D0

  FFINT=0.0D0

  DO IPHI=1,NUMPHI
     SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
     COSMPHI=COS(DFLOAT(K)*PHI(IPHI))

     CALL BRDM_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM1)
     IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BRDM_DS_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM2)
        TEM1=TEM1+TEM2
     ENDIF
     FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
     IF(SCL)CYCLE

     FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
     FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
     FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
     FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
     FFINT(3,4)=FFINT(3,4)+TEM1(3,4)*COSMPHI*WPHI(IPHI)
     FFINT(4,3)=FFINT(4,3)+TEM1(4,3)*COSMPHI*WPHI(IPHI)
     FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

     FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
     FFINT(1,4)=FFINT(1,4)+TEM1(1,4)*SINMPHI*WPHI(IPHI)
     FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
     FFINT(2,4)=FFINT(2,4)+TEM1(2,4)*SINMPHI*WPHI(IPHI)
     FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
     FFINT(4,1)=FFINT(4,1)+TEM1(4,1)*SINMPHI*WPHI(IPHI)
     FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
     FFINT(4,2)=FFINT(4,2)+TEM1(4,2)*SINMPHI*WPHI(IPHI)
   ENDDO
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
    IF(SCL)CYCLE

    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(3,4)=FFINT(3,4)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(4,3)=FFINT(4,3)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(4,4)=FFINT(4,4)
	
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(1,3)=FFINT(1,3)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(2,3)=FFINT(2,3)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(1,4)=FFINT(1,4)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(2,4)=FFINT(2,4)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(3,2)=FFINT(3,2)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(4,1)=FFINT(4,1)
    FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(4,2)=FFINT(4,2)
ENDDO
!testing
ENGFCTOI(IQUAD1)=ENGFCTOI(IQUAD1)+&
         2.0D0*FRES_REFLO(IQUAD1,IQUAD2,0)%PHMX(1,1)* &
         DABS(XJO(IQUAD2))*WTO(IQUAD2)
!if(iquad1==nquado-32)&
!write(*,'("di or",5(e13.6, 2x))'),xjo(iquad1),xjo(iquad2),WTO(iquad2),&
!           FRES_reflo(IQUAD1,IQUAD2,0)%PHMX(1,1),ENGFCTOI(IQUAD1)

ENDDO
ENDDO

!write(*,*)'di or',ENGFCTOI(IQUAD1)

DO IQUAD1=NQDOD2+1,NQUADO
DO IQUAD2=NQDAD2+1,NQUADA
COST2=XJA(IQUAD2)
COST1=XJOT(IQUAD1,IQUAD2)
MUDIFFSQ=NWRE*COST1-COST2

SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)

MUDIFFSQ=MUDIFFSQ*MUDIFFSQ
LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ

FLAG1=.not.OSFREXP
IF(COST2<0.1D0 .OR. FLAG1)THEN

  IF (LITB>THRESH3)THEN
!     PHIRG=ACOS(1.0D0-THRESH3/LITB)
     PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG

  ELSE
     PHIRG=PI
  ENDIF	

  CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
  WPHI=WPHI/TWOPI

  DO K=0,MAXMORD
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(:,:)=0.0D0

   FFINT=0.0D0

   DO IPHI=1,NUMPHI
     SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
     COSMPHI=COS(DFLOAT(K)*PHI(IPHI))

     CALL BTDM_OT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM1)

      IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BTDM_DS_OT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM2)
        TEM1=TEM1+TEM2
      ENDIF

     FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
     IF(SCL)CYCLE

     FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
     FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)

     FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
     FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
     FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

     FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
     FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
     FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
     FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
   ENDDO
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
   IF(SCL)CYCLE

   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(4,4)=FFINT(4,4)
	
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(1,3)=FFINT(1,3) 
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(2,3)=FFINT(2,3) 
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(3,1)=FFINT(3,1) 
   FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(3,2)=FFINT(3,2) 

   ENDDO
ENGFCTOI(IQUAD1)=ENGFCTOI(IQUAD1) &
       +2.0D0*FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(1,1)* &
	    XJA(IQUAD2)*WTA(IQUAD2)
!if(iquad1==nquado-32)&
!write(*,'("di ot",5(e13.6, 2x))') xjo(iquad1),xja(iquad2),WTA(iquad2),&
!          FRES_trano(IQUAD1,IQUAD2,0)%PHMX(1,1),ENGFCTOI(IQUAD1)
        
ELSE


DO K=0,MAXMORD

!! COSINE EXPANSION TERMS
  RTMX(K)%PHMX(:,:)=0.0D0
  RTMX(K)%PHMX(1,1)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(1,1)
  RTMX(K)%PHMX(1,2)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(1,2)
  RTMX(K)%PHMX(2,1)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(2,1)
  RTMX(K)%PHMX(2,2)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(2,2)

  RTMX(K)%PHMX(3,3)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(3,3)
  RTMX(K)%PHMX(3,4)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(3,4)
  RTMX(K)%PHMX(4,3)=HKWOT(IQUAD1,IQUAD2,K) &
			*FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(4,3)
  RTMX(K)%PHMX(4,4)=HKWOT(IQUAD1,IQUAD2,K) &
            *FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(4,4)


  DO L=1,MAXSORD
  LPS=L+K
  LMS=ABS(L-K)

  RTMP=HKWOT(IQUAD1,IQUAD2,LMS)+HKWOT(IQUAD1,IQUAD2,LPS)
  RTMP1=HKWOT(IQUAD1,IQUAD2,LMS)-HKWOT(IQUAD1,IQUAD2,LPS)
!! COSINE EXPANSION TERMS

  RTMX(K)%PHMX(1,1)=RTMX(K)%PHMX(1,1)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(1,1)*RTMP
  IF(SCL)CYCLE

  RTMX(K)%PHMX(1,2)=RTMX(K)%PHMX(1,2)+ &
		  FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(1,2)*RTMP
  RTMX(K)%PHMX(2,1)=RTMX(K)%PHMX(2,1)+ &
		  FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(2,1)*RTMP
  RTMX(K)%PHMX(2,2)=RTMX(K)%PHMX(2,2)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(2,2)*RTMP

  RTMX(K)%PHMX(3,3)=RTMX(K)%PHMX(3,3)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(3,3)*RTMP
  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
		  FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(4,4)*RTMP
  
!! SINE EXPANSION TERMS
  RTMX(K)%PHMX(1,3)=RTMX(K)%PHMX(1,3)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(1,3)*RTMP1
  RTMX(K)%PHMX(1,4)=RTMX(K)%PHMX(1,4)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(1,4)*RTMP1
  RTMX(K)%PHMX(2,3)=RTMX(K)%PHMX(2,3)+ &
		  FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(2,3)*RTMP1
  RTMX(K)%PHMX(2,4)=RTMX(K)%PHMX(2,4)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(2,4)*RTMP1

  RTMX(K)%PHMX(3,1)=RTMX(K)%PHMX(3,1)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(3,1)*RTMP1
  RTMX(K)%PHMX(3,2)=RTMX(K)%PHMX(3,2)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(3,2)*RTMP1
  RTMX(K)%PHMX(4,1)=RTMX(K)%PHMX(4,1)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(4,1)*RTMP1
  RTMX(K)%PHMX(4,2)=RTMX(K)%PHMX(4,2)+ &
          FRES_TRANO(IQUAD1,IQUAD2,L)%PHMX(4,2)*RTMP1
  ENDDO !LOOP L

ENDDO !LOOP K

DO K=0,MAXMORD
  FRES_TRANO(IQUAD1,IQUAD2,K)=RTMX(K)

!if(k==2 .and. iquad1==nquado-3)&
!write(*,*)'ex ot',FRES_trano(IQUAD1,IQUAD2,K)%PHMX(3,1),&
!                  FRES_trano(IQUAD1,IQUAD2,K)%PHMX(3,2),&
!				  FRES_trano(IQUAD1,IQUAD2,K)%PHMX(3,3),& 
!                  FRES_trano(IQUAD1,IQUAD2,K)%PHMX(3,4)

ENDDO

ENGFCTOI(IQUAD1)=ENGFCTOI(IQUAD1) &
       +2.0D0*FRES_TRANO(IQUAD1,IQUAD2,0)%PHMX(1,1)* &
	    XJA(IQUAD2)*WTA(IQUAD2)

ENDIF



ENDDO ! LOOP IQUAD2
ENDDO ! LOOP IQUAD1

!testing 
!if NEEDED, xjatallo and xjotallo testing part need to BE turnED on
!WRITE(*,*)'ENGFCT OI'
!DO IQUAD1=NQDOD2+1,NQUADO
! WRITE(*,*)acos(XJO(IQUAD1))/pi*180.0d0,ENGFCTOI(IQUAD1)/XJO(IQUAD1)
!ENDDO

IF(ENORM_FLAT .OR. ENGFACNORM)THEN
DO IQUAD1=NQDOD2+1,NQUADO
  COST1=XJO(IQUAD1)
DO IQUAD2=1,NQDOD2
  COST2=XJO(IQUAD2)

  THETA1=ACOS(COST1)
  CALL FRSNL_R2(NRELRE,NRELIM,THETA1,TEM1)
  FLAG1=.FALSE.
  CALL REFL_SEARCH(COST1,FLAG1,REFL_COEFF)
  IF(ENORM_FLAT)THEN
    DO K=0,MAXMORD
      FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(:,:) = &
         FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(:,:)/REFL_COEFF*TEM1(1,1)
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL TRAN_SEARCH(COST1,FLAG1,TRAN_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO K=0,MAXMORD
      FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(:,:) = &
           FRES_REFLO(IQUAD1,IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
  ENDIF
ENDDO
ENDDO

DO IQUAD1=NQDOD2+1,NQUADO
DO IQUAD2=NQDAD2+1,NQUADA
  COST2=XJA(IQUAD2)
  COST1=XJOT(IQUAD1,IQUAD2)

  THETA1=ACOS(COST1)
  CALL FRSNL_R2(NRELRE,NRELIM,THETA1,TEM1)
  FLAG1=.FALSE.
  CALL TRAN_SEARCH(COST1,FLAG1,TRAN_COEFF)
  IF(ENORM_FLAT)THEN
    DO K=0,MAXMORD
      FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(:,:) = &
        FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(:,:)/TRAN_COEFF*(1.0D0-TEM1(1,1))
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL REFL_SEARCH(COST1,FLAG1,REFL_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO K=0,MAXMORD
      FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(:,:) = &
         FRES_TRANO(IQUAD1,IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
  ENDIF
ENDDO
ENDDO

ENDIF


IF(OSFREXP)DEALLOCATE(HKWAR,HKWAT,HKWOT,RTMX)
DEALLOCATE(ENGFCTAI,ENGFCTOI,PHI,WPHI,SHDWXJO)

END SUBROUTINE CALHKW

SUBROUTINE CALSHKW(MU0)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
INTEGER K,IQUAD2,L,LPS,LMS,IPHI,NUMPHI
REAL*8 MU0,SINT1,SINT2,COST1,COST2,CAPA,LITA,LITB, &
	   MUDIFFSQ,MUDIFFQU,THETA1, RTMP,RTMP1,TWOCOS,EXPBA,  &
	   COSMPHI,SINMPHI,SENGREFL,SENGTRAN,REFL_COEFF,TRAN_COEFF

REAL*8 :: THRESH1,THRESH2,THRESH3, PHIRG,E1O12

TYPE(MATRIX44),DIMENSION(:),ALLOCATABLE::RTMX

REAL*8,DIMENSION(:,:),ALLOCATABLE :: SHKWAR,SHKWAT
REAL*8,DIMENSION(4,4)::FFINT,TEM1,TEM2
REAL*8,DIMENSION(:), ALLOCATABLE::PHI,WPHI

REAL*8 :: SSHDW,SHDWFCT

REAL*8 expbessi,SHADOW

LOGICAL :: FLAG1
EXTERNAL expbessi

THRESH1=-LOG(1.0D-307)*SIGMASQ
THRESH2=-LOG(1.0D-37)*SIGMASQ
THRESH3=-LOG(1.0D-20)  !threshold to do integration over phi,
                       !  \phi=[0,pi/2]
E1O12=11.0D0/12.0D0

IF(SHDWFLG)THEN
  SSHDW=SHADOW(MU0,SIGMASQ)
ELSE
  SSHDW=1.0D0
ENDIF
CALL RTSWVSF

IF(OSFREXP)THEN
  ALLOCATE(SHKWAR(NQDAD2+1:NQUADA,0:MAXKORD))
  ALLOCATE(RTMX(0:MAXKORD))

SHKWAR=0.0D0

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)
DO IQUAD2=NQDAD2+1,NQUADA
  COST2=XJA(IQUAD2)
  SINT2=DSQRT(1.0D0-COST2*COST2)
  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)
  MUDIFFQU=MUDIFFSQ*MUDIFFSQ
  CAPA=1.0D0/SIGMASQ/ABS(COST2)/MUDIFFQU
  TWOCOS=2.0D0-COST1*COST1-COST2*COST2
  LITA=(2.0D0-COST1*COST1-COST2*COST2)/SIGMASQ/MUDIFFSQ
  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ

! bessi(k,LITB) is not bounded.  It is easy to overflow
! USE exp(-litb)*bessi(k,LITB) instead.
  EXPBA=EXP(LITB-LITA)
  IF(SHDWFLG)THEN
     SHDWFCT=1.0D0/(1.0D0+SSHDW+SHDWXJA(IQUAD2))
  ELSE
     SHDWFCT=1.0D0
  ENDIF
  RTMP=CAPA*EXPBA*SHDWFCT
  DO K=0,MAXKORD
      SHKWAR(IQUAD2,K)=RTMP*expbessi(K,LITB)
  ENDDO

ENDDO

SENGREFL=0.0d0
SENGTRAN=0.0d0

DO IQUAD2=NQDAD2+1,NQUADA
DO K=0,MAXMORD

! COSINE EXPANSION TERMS
  RTMX(K)%PHMX(:,:)=0.0D0
  RTMX(K)%PHMX(1,1)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(1,1)
  RTMX(K)%PHMX(1,2)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(1,2)
  RTMX(K)%PHMX(2,1)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(2,1)
  RTMX(K)%PHMX(2,2)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(2,2)

  RTMX(K)%PHMX(3,3)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(3,3)
  RTMX(K)%PHMX(3,4)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(3,4)
  RTMX(K)%PHMX(4,3)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(4,3)
  RTMX(K)%PHMX(4,4)=SHKWAR(IQUAD2,K)*SFRES_REFLA(IQUAD2,0)%PHMX(4,4)

  DO L=1,MAXSORD
  LPS=L+K
  LMS=ABS(L-K)

! COSINE EXPANSION TERMS
  RTMP=SHKWAR(IQUAD2,LMS)+SHKWAR(IQUAD2,LPS)
  RTMP1=SHKWAR(IQUAD2,LMS)-SHKWAR(IQUAD2,LPS)
  RTMX(K)%PHMX(1,1)=RTMX(K)%PHMX(1,1)+                  &
                    SFRES_REFLA(IQUAD2,L)%PHMX(1,1)*RTMP
  RTMX(K)%PHMX(1,2)=RTMX(K)%PHMX(1,2)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(1,2)*RTMP
  RTMX(K)%PHMX(2,1)=RTMX(K)%PHMX(2,1)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(2,1)*RTMP
  RTMX(K)%PHMX(2,2)=RTMX(K)%PHMX(2,2)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(2,2)*RTMP

  RTMX(K)%PHMX(3,3)=RTMX(K)%PHMX(3,3)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(3,3)*RTMP
  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
					SFRES_REFLA(IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(4,4)*RTMP

  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
				    SFRES_REFLA(IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(4,4)*RTMP
  
! SINE EXPANSION TERMS
  RTMX(K)%PHMX(1,3)=RTMX(K)%PHMX(1,3)+ &
					SFRES_REFLA(IQUAD2,L)%PHMX(1,3)*RTMP1
  RTMX(K)%PHMX(1,4)=RTMX(K)%PHMX(1,4)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(1,4)*RTMP1
  RTMX(K)%PHMX(2,3)=RTMX(K)%PHMX(2,3)+ &
		            SFRES_REFLA(IQUAD2,L)%PHMX(2,3)*RTMP1
  RTMX(K)%PHMX(2,4)=RTMX(K)%PHMX(2,4)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(2,4)*RTMP1

  RTMX(K)%PHMX(3,1)=RTMX(K)%PHMX(3,1)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(3,1)*RTMP1
  RTMX(K)%PHMX(3,2)=RTMX(K)%PHMX(3,2)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(3,2)*RTMP1
  RTMX(K)%PHMX(4,1)=RTMX(K)%PHMX(4,1)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(4,1)*RTMP1
  RTMX(K)%PHMX(4,2)=RTMX(K)%PHMX(4,2)+ &
                    SFRES_REFLA(IQUAD2,L)%PHMX(4,2)*RTMP1
  ENDDO !LOOP L

ENDDO !LOOP K

DO K=0,MAXMORD
  SFRES_REFLA(IQUAD2,K)=RTMX(K)
!if(k==2)&
!write(*,*)'ex sr',SFRES_reflA(IQUAD2,K)%PHMX(3,1),&
!                  SFRES_reflA(IQUAD2,K)%PHMX(3,2),&
!				  SFRES_reflA(IQUAD2,K)%PHMX(3,3),&
!				  SFRES_reflA(IQUAD2,K)%PHMX(3,4)

ENDDO

SENGREFL=SENGREFL+SFRES_REFLA(IQUAD2,0)%PHMX(1,1)*&
              DABS(XJA(IQUAD2))*WTA(IQUAD2)*2.0D0
			  
ENDDO ! LOOP IQUAD2

IF((ENORM_FLAT .OR. ENGFACNORM))THEN
  THETA1=PI-ACOS(MU0)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL REFL_SEARCH(MU0,FLAG1,REFL_COEFF)
  IF(ENORM_FLAT)THEN
    DO IQUAD2=NQDAD2+1,NQUADA
    DO K=0,MAXMORD
      SFRES_REFLA(IQUAD2,K)%PHMX(:,:)= &
        SFRES_REFLA(IQUAD2,K)%PHMX(:,:)/REFL_COEFF*TEM1(1,1)
    ENDDO
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL TRAN_SEARCH(MU0,FLAG1,TRAN_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO IQUAD2=NQDAD2+1,NQUADA
    DO K=0,MAXMORD
      SFRES_REFLA(IQUAD2,K)%PHMX(:,:)=SFRES_REFLA(IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
    ENDDO
  ENDIF
ENDIF

DEALLOCATE(SHKWAR)
IF(NQUADSO==1 .OR. OCEAN_NO_TRAN)THEN
  DEALLOCATE(RTMX)
  RETURN
ENDIF

ALLOCATE(SHKWAT(NQUADSO,0:MAXKORD))
SHKWAT=0.0D0

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)
DO IQUAD2=1,NQUADSO
  COST2=XJSO(IQUAD2)
  SINT2=DSQRT(1.0D0-COST2*COST2)
  MUDIFFSQ=(COST1-NWRE*COST2)*(COST1-NWRE*COST2)
  CAPA=NSQW/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
  TWOCOS=1.0D0-COST1*COST1+NSQW*(1.0D0-COST2*COST2)
  LITA=TWOCOS/SIGMASQ/MUDIFFSQ
  LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ
  EXPBA=EXP(LITB-LITA)
  IF(SHDWFLG)THEN
    SHDWFCT=1.0D0/(1.0D0+SSHDW+SHADOW(COST2,SIGMASQ))
  ELSE
    SHDWFCT=1.0D0  
  ENDIF
  RTMP=CAPA*EXPBA*SHDWFCT
  DO K=0,MAXKORD
      SHKWAT(IQUAD2,K)=RTMP*expbessi(K,LITB)
  ENDDO
ENDDO

DO IQUAD2=1,NQUADSO
DO K=0,MAXMORD

! COSINE EXPANSION TERMS
  RTMX(K)%PHMX(:,:)=0.0D0
  RTMX(K)%PHMX(1,1)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(1,1)
  RTMX(K)%PHMX(1,2)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(1,2)
  RTMX(K)%PHMX(2,1)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(2,1)
  RTMX(K)%PHMX(2,2)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(2,2)

  RTMX(K)%PHMX(3,3)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(3,3)
  RTMX(K)%PHMX(3,4)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(3,4)
  RTMX(K)%PHMX(4,3)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(4,3)
  RTMX(K)%PHMX(4,4)=SHKWAT(IQUAD2,K)*SFRES_TRANA(IQUAD2,0)%PHMX(4,4)
  DO L=1,MAXSORD
  LPS=L+K
  LMS=ABS(L-K)

  RTMP=SHKWAT(IQUAD2,LMS)+SHKWAT(IQUAD2,LPS)
  RTMP1=SHKWAT(IQUAD2,LMS)-SHKWAT(IQUAD2,LPS)
! COSINE EXPANSION TERMS

  RTMX(K)%PHMX(1,1)=RTMX(K)%PHMX(1,1)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(1,1)*RTMP
  RTMX(K)%PHMX(1,2)=RTMX(K)%PHMX(1,2)+ &
		  SFRES_TRANA(IQUAD2,L)%PHMX(1,2)*RTMP
  RTMX(K)%PHMX(2,1)=RTMX(K)%PHMX(2,1)+ &
		  SFRES_TRANA(IQUAD2,L)%PHMX(2,1)*RTMP
  RTMX(K)%PHMX(2,2)=RTMX(K)%PHMX(2,2)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(2,2)*RTMP

  RTMX(K)%PHMX(3,3)=RTMX(K)%PHMX(3,3)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(3,3)*RTMP
  RTMX(K)%PHMX(3,4)=RTMX(K)%PHMX(3,4)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(3,4)*RTMP
  RTMX(K)%PHMX(4,3)=RTMX(K)%PHMX(4,3)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(4,3)*RTMP
  RTMX(K)%PHMX(4,4)=RTMX(K)%PHMX(4,4)+ &
		  SFRES_TRANA(IQUAD2,L)%PHMX(4,4)*RTMP
 
! SINE EXPANSION TERMS
  RTMX(K)%PHMX(1,3)=RTMX(K)%PHMX(1,3)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(1,3)*RTMP1
  RTMX(K)%PHMX(1,4)=RTMX(K)%PHMX(1,4)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(1,4)*RTMP1
  RTMX(K)%PHMX(2,3)=RTMX(K)%PHMX(2,3)+ &
		  SFRES_TRANA(IQUAD2,L)%PHMX(2,3)*RTMP1
  RTMX(K)%PHMX(2,4)=RTMX(K)%PHMX(2,4)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(2,4)*RTMP1

  RTMX(K)%PHMX(3,1)=RTMX(K)%PHMX(3,1)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(3,1)*RTMP1
  RTMX(K)%PHMX(3,2)=RTMX(K)%PHMX(3,2)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(3,2)*RTMP1
  RTMX(K)%PHMX(4,1)=RTMX(K)%PHMX(4,1)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(4,1)*RTMP1
  RTMX(K)%PHMX(4,2)=RTMX(K)%PHMX(4,2)+ &
          SFRES_TRANA(IQUAD2,L)%PHMX(4,2)*RTMP1

  ENDDO ! LOOP L

ENDDO  ! LOOP K

DO K=0,MAXMORD
  SFRES_TRANA(IQUAD2,K)=RTMX(K)

!if(k==2)&
!write(*,*)'EX sT',SFRES_TRANA(IQUAD2,K)%PHMX(3,1),&
!                  SFRES_TRANA(IQUAD2,K)%PHMX(3,2),&
!				  SFRES_TRANA(IQUAD2,K)%PHMX(3,3),&
!				  SFRES_TRANA(IQUAD2,K)%PHMX(3,4)

ENDDO

SENGTRAN=SENGTRAN+SFRES_TRANA(IQUAD2,0)%PHMX(1,1)*&
              DABS(XJSO(IQUAD2))*WTSO(IQUAD2)*2.0D0

ENDDO  !LOOP IQUAD2

IF((ENORM_FLAT .OR. ENGFACNORM))THEN
  THETA1=PI-ACOS(MU0)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL TRAN_SEARCH(MU0,FLAG1,TRAN_COEFF)
  IF(ENORM_FLAT)THEN
    DO IQUAD2=1,NQUADSO
    DO K=0,MAXMORD
      SFRES_TRANA(IQUAD2,K)%PHMX(:,:) = &
            SFRES_TRANA(IQUAD2,K)%PHMX(:,:)/TRAN_COEFF*(1.0D0-TEM1(1,1))
    ENDDO
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL REFL_SEARCH(MU0,FLAG1,REFL_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO IQUAD2=1,NQUADSO
    DO K=0,MAXMORD
      SFRES_TRANA(IQUAD2,K)%PHMX(:,:) = &
            SFRES_TRANA(IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
    ENDDO
  ENDIF
ENDIF

!WRITE(*,'("MU0=",F8.4,2x,"SERIES EXPANSION SENGREFL=",F8.4)')&
!             MU0,-SENGREFL/MU0,-SENGTRAN/MU0,-(SENGREFL+SENGTRAN)/MU0

DEALLOCATE(RTMX,SHKWAT)

ELSE
!CALCULATE SFRES_REFLA, AND SFRES_TRANA USING DIRECT INTEGRATION

DO IQUAD2=NQDAD2+1,NQUADA
DO K=0,MAXSORD
   SFRES_REFLA(IQUAD2,K)%PHMX(:,:)=0.0D0
ENDDO
ENDDO

SENGREFL=0.0D0
SENGTRAN=0.0D0

NUMPHI=100
ALLOCATE(PHI(NUMPHI),WPHI(NUMPHI))

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)
DO IQUAD2=NQDAD2+1,NQUADA
  COST2=XJA(IQUAD2)
  SINT2=DSQRT(1.0D0-COST2*COST2)

  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)

  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ

  IF (LITB>THRESH3)THEN
!    PHIRG=ACOS(1.0D0-THRESH3/LITB)
    PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG
  ELSE
    PHIRG=PI
  ENDIF
  CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
  WPHI=WPHI/TWOPI
  DO K=0,MAXMORD

	FFINT=0.0D0
    DO IPHI=1,NUMPHI
      SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
      COSMPHI=COS(DFLOAT(K)*PHI(IPHI))
  
      CALL BRDM_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM1)
      IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BRDM_DS_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM2)
        TEM1=TEM1+TEM2
      ENDIF

      FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
      IF(SCL)CYCLE

      FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
      FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
      FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
      FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
      FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

      FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
      FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
      FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
      FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)

    ENDDO   !PHI DO

    SFRES_REFLA(IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
    IF(SCL)CYCLE

    SFRES_REFLA(IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
    SFRES_REFLA(IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
    SFRES_REFLA(IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
    SFRES_REFLA(IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
    SFRES_REFLA(IQUAD2,K)%PHMX(4,4)=FFINT(4,4)

    SFRES_REFLA(IQUAD2,K)%PHMX(1,3)=FFINT(1,3) 
    SFRES_REFLA(IQUAD2,K)%PHMX(2,3)=FFINT(2,3) 
    SFRES_REFLA(IQUAD2,K)%PHMX(3,1)=FFINT(3,1)  
    SFRES_REFLA(IQUAD2,K)%PHMX(3,2)=FFINT(3,2)  

  ENDDO  !LOOP K
  SENGREFL=SENGREFL+SFRES_REFLA(IQUAD2,0)%PHMX(1,1)*&
              DABS(XJA(IQUAD2))*WTA(IQUAD2)*2.0D0
!WRITE(*,'("MU0=",F8.4,2x,e13.6,F8.4,(2x,e13.6))') &
!             MU0,XJA(IQUAD2),SFRES_REFLA(IQUAD2,0)%PHMX(1,1),-SENGREFL/MU0
ENDDO
!testing
!WRITE(*,'("MU0=",F8.4,2x,"DI REFLECTION SENGREFL=",F8.4))')&
!             MU0,-SENGREFL/MU0

IF((ENORM_FLAT .OR. ENGFACNORM))THEN
  THETA1=PI-ACOS(MU0)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL REFL_SEARCH(MU0,FLAG1,REFL_COEFF)
  IF(ENORM_FLAT)THEN
    DO IQUAD2=NQDAD2+1,NQUADA
    DO K=0,MAXMORD
      SFRES_REFLA(IQUAD2,K)%PHMX(:,:)= &
        SFRES_REFLA(IQUAD2,K)%PHMX(:,:)/REFL_COEFF*TEM1(1,1)
    ENDDO
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL TRAN_SEARCH(MU0,FLAG1,TRAN_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO IQUAD2=NQDAD2+1,NQUADA
    DO K=0,MAXMORD
      SFRES_REFLA(IQUAD2,K)%PHMX(:,:)=SFRES_REFLA(IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
    ENDDO
  ENDIF
ENDIF

IF(NQUADSO==1 .OR. OCEAN_NO_TRAN)  RETURN
DO IQUAD2=1,NQUADSO
DO K=0,MAXSORD
   SFRES_TRANA(IQUAD2,K)%PHMX(:,:)=0.0D0
ENDDO
ENDDO

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)
DO IQUAD2=1,NQUADSO
  COST2=XJSO(IQUAD2)
  MUDIFFSQ=COST1-NWRE*COST2

  SINT2=DSQRT(1.0D0-COST2*COST2)

  MUDIFFSQ=MUDIFFSQ*MUDIFFSQ

  LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ

  IF (LITB>THRESH3)THEN
!    PHIRG=ACOS(1.0D0-THRESH3/LITB)
    PHIRG=ACOS(-THRESH3/LITB)  !testing PHIRG

  ELSE
     PHIRG=PI
  ENDIF	
 
  CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
  WPHI=WPHI/TWOPI
   
  DO K=0,MAXMORD
   SFRES_TRANA(IQUAD2,K)%PHMX(:,:)=0.0D0

   FFINT=0.0D0

   DO IPHI=1,NUMPHI
     SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
     COSMPHI=COS(DFLOAT(K)*PHI(IPHI))

     CALL BTDM_AT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NWRE,NWIM,TEM1)
 
     IF(OC_IF_DS .AND. ABS(COST1)<COS(50.D0/180.D0*PI)) THEN
        CALL BTDM_DS_AT_OCEAN(COST1,0.0D0,COST2,PHI(IPHI),NRELRE,NRELIM,TEM2)
        TEM1=TEM1+TEM2
     ENDIF

     FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
     IF(SCL)CYCLE

     FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
     FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
     FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
     FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
     FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

     FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
     FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
     FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
     FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
   ENDDO
   SFRES_TRANA(IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
  IF(SCL)CYCLE

   SFRES_TRANA(IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
   SFRES_TRANA(IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
   SFRES_TRANA(IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
   SFRES_TRANA(IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
   SFRES_TRANA(IQUAD2,K)%PHMX(4,4)=FFINT(4,4)
	
   SFRES_TRANA(IQUAD2,K)%PHMX(1,3)=FFINT(1,3) 
   SFRES_TRANA(IQUAD2,K)%PHMX(2,3)=FFINT(2,3) 
   SFRES_TRANA(IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
   SFRES_TRANA(IQUAD2,K)%PHMX(3,2)=FFINT(3,2) 

!if(k==0)&
!write(*,*)'di sT',SFRES_TRANA(IQUAD2,K)%PHMX(3,1),&
!                  SFRES_TRANA(IQUAD2,K)%PHMX(3,2),&
!				  SFRES_TRANA(IQUAD2,K)%PHMX(3,3),&
!				  SFRES_TRANA(IQUAD2,K)%PHMX(3,4)


   ENDDO


SENGTRAN=SENGTRAN+SFRES_TRANA(IQUAD2,0)%PHMX(1,1)*&
                  DABS(XJSO(IQUAD2))*WTSO(IQUAD2)*2.0D0

!WRITE(*,'("MU0=",F8.4,2x,e13.6, F8.4,2x,e13.6)')&
!      MU0,XJSO(IQUAD2),SFRES_TRANA(IQUAD2,0)%PHMX(1,1),-SENGTRAN/MU0

ENDDO ! NQUADSO
!testing
!WRITE(*,'("MU0=",F8.4,2x,"DI SENGTRAN=",F8.4)')MU0,-SENGTRAN/MU0
DEALLOCATE(PHI,WPHI)
ENDIF ! OSFREXP IF
! TESTING
!DO K=0,4
!Iquad2=3
!write(*,*)'ex',k,xja(iquad2)
!write(*,'(4(E13.6,2X))')sFRES_TRANA(IQUAD2,K)%PHMX(1,1:4),&
!sFRES_TRANA(IQUAD2,K)%PHMX(2,1:4),&
!sFRES_TRANA(IQUAD2,K)%PHMX(3,1:4),&
!sFRES_TRANA(IQUAD2,K)%PHMX(4,1:4)
!ENDDO

IF((ENORM_FLAT .OR. ENGFACNORM))THEN
  THETA1=PI-ACOS(MU0)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  FLAG1=.TRUE.
  CALL TRAN_SEARCH(MU0,FLAG1,TRAN_COEFF)
  IF(ENORM_FLAT)THEN
    DO IQUAD2=1,NQUADSO
    DO K=0,MAXMORD
      SFRES_TRANA(IQUAD2,K)%PHMX(:,:) = &
            SFRES_TRANA(IQUAD2,K)%PHMX(:,:)/TRAN_COEFF*(1.0D0-TEM1(1,1))
    ENDDO
    ENDDO
  ELSEIF(ENGFACNORM) THEN
    CALL REFL_SEARCH(MU0,FLAG1,REFL_COEFF)
    RTMP=REFL_COEFF+TRAN_COEFF
    DO IQUAD2=1,NQUADSO
    DO K=0,MAXMORD
      SFRES_TRANA(IQUAD2,K)%PHMX(:,:) = &
            SFRES_TRANA(IQUAD2,K)%PHMX(:,:)/RTMP
    ENDDO
    ENDDO
  ENDIF
ENDIF


END SUBROUTINE CALSHKW

SUBROUTINE XJSOALLO(MU0)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION, ONLY : NUMMIE
IMPLICIT NONE

REAL*8, INTENT(IN)::MU0
REAL*8 :: TOL,X1,X2,MU0T,SIN0,SIN0T,MUTMP,FBTMAT,FBTMP
REAL*8 :: THETA1,THETA2
REAL*8,DIMENSION(4,4) :: MTRX1
INTEGER :: M,MAXMS,ICONT

TOL=1.0D-6

!testing
!X1=-1.0d0
!X2=0.0D0
!ALLOCATE(XJSO(NQUADSO),WTSO(NQUADSO))
!CALL gauleg(X1,X2,XJSO,WTSO,NQUADSO)
!ALLOCATE(SPMO(NQUADSO,NQUADO,NUMMIE,0:MAXMORD))
!RETURN

SIN0=SQRT(1.0D0-MU0*MU0)
SIN0T=SIN0/NWRE
MU0T=-SQRT(1.0D0-SIN0T*SIN0T)

IF(FLATO)THEN
  NQUADSO=1
  ALLOCATE(XJSO(NQUADSO),WTSO(NQUADSO))
  XJSO(1)=MU0T
  WTSO(1)=1.0D0
  ALLOCATE(SPMO(NQUADSO,NQUADO,NUMMIE,0:MAXMORD))


!  MAXMS=MAX(MAXMORD,MAXSORD)
  ALLOCATE(SFRES_TRANA(NQUADSO,0:MAXMORD))
  THETA1=ASIN(SIN0)
  THETA2=ASIN(SIN0T)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,MTRX1)

  DO M=0,MAXMORD
   SFRES_TRANA(1,M)%PHMX=MTRX1
  ENDDO

  RETURN
ENDIF

MUTMP=-TOL
FBTMP=FBTMAT(MU0,MUTMP)
IF(FBTMP>TOL)THEN
  X2=0.0D0
ELSE
  ICONT=0
  FTMPLOOP1 : DO WHILE(FBTMP<TOL)
    ICONT=ICONT+1
	IF(ICONT>1000) STOP 'ERROR: ICONT OUT OF LIMIT 1'
    MUTMP=MUTMP-0.001D0
    IF(MUTMP<0.0D0) THEN
       MUTMP=0.0D0
       EXIT FTMPLOOP1
    ENDIF
    FBTMP=FBTMAT(MU0,MUTMP)    
  ENDDO FTMPLOOP1
  X2=MUTMP
ENDIF

MUTMP=-1.0d0
FBTMP=FBTMAT(MU0,MUTMP)
IF(FBTMP>TOL)THEN
  X1=-1.0D0
ELSE
  ICONT=0
  FTMPLOOP : DO WHILE(ABS(FBTMP)<TOL)
    ICONT=ICONT+1
	IF(ICONT>1000)STOP ' ERROR: ICONT OUT OF LIMIT 2'
    MUTMP=MUTMP+0.001D0
    IF(MUTMP>0.0D0) THEN
       MUTMP=-1.0D0
       EXIT FTMPLOOP
    ENDIF
    FBTMP=FBTMAT(MU0,MUTMP)    
  ENDDO FTMPLOOP
  X1=MUTMP
ENDIF
IF(X1<-1.0D0)X1=-1.0D0
IF(X2>0.0D0)X2=0.0D0
IF(X2<X1 .OR. ABS(X2-X1)<0.0001)THEN
  NQUADSO=1
  ALLOCATE(XJSO(NQUADSO),WTSO(NQUADSO))
  XJSO(1)=MU0T
  WTSO(1)=1.0D0
  MAXMS=MAX(MAXMORD,MAXSORD)
  ALLOCATE(SFRES_TRANA(NQUADSO,0:MAXMS))
  THETA1=ASIN(SIN0)
  THETA2=ASIN(SIN0T)
  CALL FRSNL_R2(NWRE,NWIM,THETA1,MTRX1)

  DO M=0,MAXSORD
   SFRES_TRANA(1,M)%PHMX=MTRX1
  ENDDO
ELSE
  ALLOCATE(XJSO(NQUADSO),WTSO(NQUADSO))
  CALL gauleg(X1,X2,XJSO,WTSO,NQUADSO)
ENDIF
ALLOCATE(SPMO(NQUADSO,NQUADO,NUMMIE,0:MAXMORD))

END SUBROUTINE XJSOALLO


SUBROUTINE XJATALLO
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

REAL*8 :: TOL,X1,X2,COST1,COST2,SINT1,SINT2,MUTMP,FBTMAT,FBTMP
REAL*8,DIMENSION(:),ALLOCATABLE :: MUAT,WTMUAT
INTEGER :: IQUAD,JQUAD

TOL=1.0D-6
!SIGMASQ=0.003D0+0.00512D0*WNDSPD

ALLOCATE(XJAT(NQDAD2,NQDOD2),WTAT(NQDAD2,NQDOD2))
ALLOCATE(MUAT(NQDAD2),WTMUAT(NQDAD2))

DO IQUAD=1,NQDOD2

  COST2=XJO(IQUAD)
  SINT2=SQRT(1.0D0-COST2*COST2)

  X1=NWRE*COST2
  IF(X1<-1.0D0)X1=-1.0D0

  SINT1=NWRE*SINT2

  IF(SINT1>1.0D0)THEN
    X2=0.0D0
    call gauleg(X1,X2,MUAT,WTMUAT,NQDAD2)
    DO JQUAD=1,NQDAD2
      XJAT(JQUAD,IQUAD)=MUAT(JQUAD)
      WTAT(JQUAD,IQUAD)=WTMUAT(JQUAD)
    ENDDO
    CYCLE
  ENDIF	
  COST1=-SQRT(1.0D0-SINT1*SINT1)

  FBTMP=1.0D0
  MUTMP=COST1
  DO WHILE(FBTMP>TOL)
    MUTMP=MUTMP+0.001D0
    IF(MUTMP>0.0D0)EXIT
    FBTMP=FBTMAT(MUTMP,COST2)    
  ENDDO
  X2=MUTMP
  IF(X2>0.0D0)X2=0.0D0
  call gauleg(X1,X2,MUAT,WTMUAT,NQDAD2)
  DO JQUAD=1,NQDAD2
     XJAT(JQUAD,IQUAD)=MUAT(JQUAD)
	 WTAT(JQUAD,IQUAD)=WTMUAT(JQUAD)
  ENDDO
ENDDO

!testing
!do iquad=1,nqdad2
!do jquad=1,nqdod2
!xjat(iquad,jquad)=xja(iquad)
!wtat(iquad,jquad)=wta(iquad)
!enddo
!enddo


DEALLOCATE(MUAT,WTMUAT)

END SUBROUTINE XJATALLO

SUBROUTINE XJOTALLO
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

REAL*8 :: X1,X2,COST1,COST2,SINT1,SINT2
REAL*8,DIMENSION(:),ALLOCATABLE :: MUOT,WTMUOT
INTEGER :: IQUAD,JQUAD

ALLOCATE(XJOT(NQDOD2+1:NQUADO,NQDAD2+1:NQUADA),&
         WTOT(NQDOD2+1:NQUADO,NQDAD2+1:NQUADA))
ALLOCATE(MUOT(NQDOD2),WTMUOT(NQDOD2))


DO IQUAD=NQDAD2+1,NQUADA
  COST2=XJA(IQUAD)
  SINT2=SQRT(1.0D0-COST2*COST2)

  SINT1=SINT2/NWRE
  COST1=SQRT(1.0D0-SINT1*SINT1)

  X1=COST2/NWRE
  X2=1.0D0
  CALL gauleg(X1,X2,MUOT,WTMUOT,NQDOD2)
  DO JQUAD=1,NQDOD2
     XJOT(JQUAD+NQDOD2,IQUAD)=MUOT(JQUAD)
     WTOT(JQUAD+NQDOD2,IQUAD)=WTMUOT(JQUAD)
  ENDDO
ENDDO

!testing
!do iquad=nqdad2+1,nquada
!do jquad=1,nqdod2
!xjot(JQUAD+NQDOD2,iquad)=xjo(jquad+NQDOD2)
!wtot(JQUAD+NQDOD2,iquad)=wto(jquad+NQDOD2)
!enddo
!enddo

DEALLOCATE(MUOT,WTMUOT)

END SUBROUTINE XJOTALLO


REAL*8 FUNCTION FBTMAT(MUP,MU)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
REAL*8 MUP,MU

REAL*8 :: LITAT,LITBT,DNOM,SINTP,SINT
REAL*8 :: MUDIFF
SINT=SQRT(1.0D0-MU*MU)
SINTP=SQRT(1.0D0-MUP*MUP)
MUDIFF=MUP-NWRE*MU
DNOM=1.0D0/SIGMASQ/MUDIFF/MUDIFF
LITAT=(SINTP*SINTP+NSQW*SINT*SINT)*DNOM
LITBT=2.0D0*NWRE*SINT*SINTP*DNOM
FBTMAT=DEXP(LITBT-LITAT)
END FUNCTION FBTMAT

SUBROUTINE RADINTPL2(MPLIN,NK,XJK,RADKTMP,NU,XJU,RADUTMP) 
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

INTEGER,INTENT(IN) :: NK,NU,MPLIN
REAL*8, DIMENSION(NK,4),INTENT(IN)::RADKTMP
REAL*8, DIMENSION(NU,4),INTENT(OUT)::RADUTMP
REAL*8, DIMENSION(NK),INTENT(IN)::XJK
REAL*8, DIMENSION(NU),INTENT(IN)::XJU
REAL*8, DIMENSION(:),ALLOCATABLE::VSK,VSU

INTEGER :: ICOM,IR,IULO,KLO,MPL
REAL*8 :: RTMP

MPL=MPLIN
RADUTMP=0.0d0

ALLOCATE(VSK(NK),VSU(NU))

DO ICOM=1,4
   DO IR=1,NK
     VSK(IR)=RADKTMP(IR,ICOM)
   ENDDO

!  CALL myspline(NK,XJK,VSK,NU,XJU,VSU)
  DO IR=1,NU

      IF(ABS(XJU(IR))<0.1D0) THEN
	     MPL=2
      ELSE
         MPL=MPLIN
      ENDIF
      IULO=INT(FLOAT(NK)*ABS((XJU(IR)-XJK(1))/(XJK(NK)-XJK(1))))
      call hunt(XJK,NK,XJU(IR),IULO)
      KLO=min(max(IULO-(MPL-1)/2,1),NK+1-MPL)
      CALL POLINT(XJK(KLO),VSK(KLO),MPL,XJU(IR),VSU(IR),RTMP)
      RADUTMP(IR,ICOM)=VSU(IR)
  ENDDO
ENDDO
DEALLOCATE(VSK,VSU)
END SUBROUTINE RADINTPL2

SUBROUTINE RADOCMDRCT(MU0,TAUDETS,MU,PHI,ARRY1,DIFF_FLG)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

LOGICAL,INTENT(IN):: DIFF_FLG
REAL*8, INTENT(IN)::MU0,TAUDETS,PHI,MU
REAL*8,DIMENSION(4),INTENT(OUT)::ARRY1
REAL*8, DIMENSION(4,4)::FRES_TRAN,SLI1,SLI2,TEM1,TEM2
REAL*8 :: COST1,SINT1,COST2,SINT2,CAPA,COSINOM,COSTNOM,MUDIFFSQ, &
          LITA,LITB,EXPBA,COST,NTGFCT,RTMP,RTMP1,RTMP2
REAL*8 :: THRESH2,THETA1,THETA2,SA,SB,SC,SPHI,FA,FB,FC,FPHI,SHDWFCT,&
          SHADOW
COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)

COST2=MU
SINT2=DSQRT(1.0D0-COST2*COST2)

IF(FLATO .AND. (ABS(PHI)>1.0D-6 .OR. ABS(SINT1-NWRE*SINT2)>1.0D-6))THEN
  ARRY1=0.0D0
  RETURN
ENDIF

IF(FLATO)THEN
  THETA1=ACOS(ABS(MU0))
  CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_TRAN)
  TEM1=FRES_TRAN*NWRE*NWRE
  ARRY1=MATMUL(TEM1,ESUN)
ELSE
  CALL BTDM_AT_OCEAN(COST1,0.0D0,COST2,PHI,NWRE,NWIM,TEM1)
  ARRY1=MATMUL(TEM1,ESUN)
  ARRY1=ARRY1/PI
ENDIF

IF(DIFF_FLG)THEN
  ARRY1=ARRY1*EXP(-(ABS(OITAU*SECANT_THETAL_PRSV(NALYR))+ABS((TAUDETS-OITAU)/MU)))
ELSE
  ARRY1=ARRY1*EXP(-(ABS(OITAU_PRSV*SECANT_THETAL_PRSV(NALYR))+ABS((TAUDETS-OITAU_PRSV)/MU)))
ENDIF
END SUBROUTINE RADOCMDRCT

SUBROUTINE RADACMDRCT(MU0,TAUDETS,MU,PHI,ARRY1,DIFF_FLG)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
LOGICAL,INTENT(IN):: DIFF_FLG
REAL*8, INTENT(IN)::MU0,TAUDETS,PHI,MU
REAL*8,DIMENSION(4),INTENT(OUT)::ARRY1
REAL*8, DIMENSION(4,4)::FRES_REFL,SLI1,SLI2,TEM1,TEM2
REAL*8 :: COST1,SINT1,COST2,SINT2,CAPA,CAPAP,MUDIFFSQ, &
          LITA,LITB,EXPBA, COST,MUNSQINV,NTGFCT,RTMP,RTMP2
REAL*8 :: THRESH2,THETA1,THETA2,SA,SB,SC,SPHI,FA,FB,FC,FPHI,E1O12,&
          SHDWFCT,SHADOW

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)

COST2=MU
SINT2=DSQRT(1.0D0-COST2*COST2)

IF(FLATO .AND.(ABS(PHI)>1.0D-6 .OR. ABS(SINT1-SINT2)>1.0D-6))THEN
  ARRY1=0.0D0
  RETURN
ENDIF

IF(FLATO)THEN
  THETA1=ACOS(ABS(MU0))
  CALL FRSNL_R2(NWRE,NWIM,THETA1,TEM1)
  ARRY1=MATMUL(TEM1,ESUN)
ELSE
  CALL BRDM_OCEAN(COST1,0.0D0,COST2,PHI,NWRE,NWIM,TEM1)
  ARRY1=MATMUL(TEM1,ESUN)
  ARRY1=ARRY1/PI
ENDIF

IF(DIFF_FLG)THEN
  ARRY1=ARRY1*EXP(-(ABS(OITAU*SECANT_THETAL_PRSV(NALYR))+ABS((OITAU-TAUDETS)/MU)))
ELSE
  ARRY1=ARRY1*EXP(-(ABS(OITAU_PRSV*SECANT_THETAL_PRSV(NALYR))+ABS((OITAU_PRSV-TAUDETS)/MU)))
ENDIF

END SUBROUTINE RADACMDRCT

REAL*8 FUNCTION SHADOW(U,SIGMASQ)
USE RTUTILITY, ONLY : PI

IMPLICIT NONE
REAL*8 :: DERFC
REAL*8 U,SIGMASQ
REAL*8 USQ,SUSQ,NU,NUSR

USQ=U*U
SUSQ=1.0D0-USQ
IF(ABS(SUSQ)<1.0D-9)THEN
  SHADOW=0.0D0
  RETURN
ENDIF
NU=USQ/SUSQ/SIGMASQ
NUSR=DSQRT(NU)
SHADOW=0.5D0*(EXP(-NU)/NUSR/DSQRT(PI)-DERFC(NUSR))

END FUNCTION SHADOW

SUBROUTINE RADALandDRCT(MU0,TAUDETS,MU,PHI,ARRY1,DIFF_FLG)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
LOGICAL,INTENT(IN):: DIFF_FLG
REAL*8, INTENT(IN)::MU0,TAUDETS,PHI,MU
REAL*8,DIMENSION(4),INTENT(OUT)::ARRY1
REAL*8, DIMENSION(4,4)::TEM1
REAL*8 :: COST1,SINT1,COST2,SINT2,RTMP

IF(MU<0.0D0)THEN
   ARRY1=0.0D0
   RETURN
ENDIF


COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)

COST2=MU
SINT2=DSQRT(1.0D0-COST2*COST2)

RTMP=0.0d0

CALL pBRDM_LAND(COST1,RTMP,COST2,PHI,TEM1)

IF(SCL)THEN
  ARRY1=0.0D0
  ARRY1(1)=TEM1(1,1)*ESUN(1)
ELSE
  ARRY1=MATMUL(TEM1,ESUN)
ENDIF
IF(DIFF_FLG)THEN
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU-TAUDETS)/MU)))/PI
ELSE
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU_PRSV*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU_PRSV-TAUDETS)/MU)))/PI
ENDIF
END SUBROUTINE RADALandDRCT

SUBROUTINE RADASnowDRCT(MU0,TAUDETS,MU,PHI,ARRY1,DIFF_FLG)
USE RTTYPE
USE RTUTILITY
USE SnowBRDF
IMPLICIT NONE
LOGICAL,INTENT(IN):: DIFF_FLG
REAL*8, INTENT(IN)::MU0,TAUDETS,PHI,MU
REAL*8,DIMENSION(4),INTENT(OUT)::ARRY1
REAL*8, DIMENSION(4,4)::TEM1
REAL*8 :: COST1,SINT1,COST2,SINT2,WAVELENGTH_MICRON,RTMP

IF(MU<0.0D0)THEN
   ARRY1=0.0D0
   RETURN
ENDIF

WAVELENGTH_MICRON=ALYR(1)%WAVELENGTH

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)

COST2=MU
SINT2=DSQRT(1.0D0-COST2*COST2)

RTMP=0.0d0

CALL pBRDM_Snow(WAVELENGTH_MICRON,COST1,RTMP,COST2,PHI,TEM1,GLBDO)

IF(SCL)THEN
  ARRY1=0.0D0
  ARRY1(1)=TEM1(1,1)*ESUN(1)
ELSE
  ARRY1=MATMUL(TEM1,ESUN)
ENDIF
IF(DIFF_FLG)THEN
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU-TAUDETS)/MU)))/PI
ELSE
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU_PRSV*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU_PRSV-TAUDETS)/MU)))/PI
ENDIF

END SUBROUTINE RADASnowDRCT

SUBROUTINE RADARossLiDRCT(MU0,TAUDETS,MU,PHI,ARRY1,DIFF_FLG)
USE RTTYPE
USE RTUTILITY
USE RossLiBRDF
IMPLICIT NONE
LOGICAL,INTENT(IN):: DIFF_FLG
REAL*8, INTENT(IN)::MU0,TAUDETS,PHI,MU
REAL*8,DIMENSION(4),INTENT(OUT)::ARRY1
REAL*8, DIMENSION(4,4)::TEM1
REAL*8 :: COST1,SINT1,COST2,SINT2,WAVELENGTH_MICRON,RTMP

IF(MU<0.0D0)THEN
   ARRY1=0.0D0
   RETURN
ENDIF

!WAVELENGTH_MICRON=ALYR(1)%WAVELENGTH

COST1=MU0
!SINT1=DSQRT(1.0D0-COST1*COST1)

COST2=MU
!SINT2=DSQRT(1.0D0-COST2*COST2)

RTMP=0.0d0

CALL pBRDM_RossLi(COST1,RTMP,COST2,PHI,TEM1)
IF(SCL)THEN
  ARRY1=0.0D0
  ARRY1(1)=TEM1(1,1)*ESUN(1)
ELSE
  ARRY1=MATMUL(TEM1,ESUN)
ENDIF
IF(DIFF_FLG)THEN
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU-TAUDETS)/MU)))/PI
ELSE
  ARRY1=ARRY1*EXP(-(ABS(TOTALTAU_PRSV*SECANT_THETAL_PRSV(NALYR))+ABS((TOTALTAU_PRSV-TAUDETS)/MU)))/PI
ENDIF

END SUBROUTINE RADARossLiDRCT

SUBROUTINE SOURCEFUNC_INTEGRATION_OCEAN(M)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
INTEGER,INTENT(IN) :: M
INTEGER :: IQUAD,I,N,ITAU,ITAUEND
REAL*8 :: SIGN,RTMP, RTMP1,RTMP2,RTMP3,INTCOEFF1,INTCOEFF2
REAL(DP),DIMENSION(4)   :: SRC0,SRC1,ARRY1
REAL*8,PARAMETER :: SLOPE_CUTOFF=100.0D0

IF(LINEXP)THEN

DO N=1,NOLYR
!DO ITAU=OLYR(1)%ITAUS+2,OLYR(NOLYR)%ITAUE,2
IF(N==NOLYR)THEN
  ITAUEND=OLYR(N)%ITAUE
ELSE
  ITAUEND=OLYR(N)%ITAUE+1
ENDIF
DO ITAU=OLYR(N)%ITAUS+2,ITAUEND,2
DO IQUAD=1,NQDOD2
IF(M==0)THEN
IF( ITAU== ITAUEND)THEN
  RTMP=SRCFOP(IQUAD,N,M)%VRAD(1)
ELSE
  RTMP=SOURCEFO(IQUAD,ITAU,M)%VRAD(1)
ENDIF
RTMP1=SOURCEFO(IQUAD,ITAU-1,M)%VRAD(1)
RTMP2=SOURCEFO(IQUAD,ITAU-2,M)%VRAD(1)
RTMP3=RTMP1*RTMP1-RTMP*RTMP2

IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF

IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
  COEFALDW(ITAU)=0.0D0
ELSE IF(RTMP<TINY2)THEN
  COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
      DLOG(RTMP2/RTMP1)
ELSE
COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP)
ENDIF

IF(COEFALDW(ITAU)>LARGERN)COEFALDW(ITAU)=0.0D0
IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
   COEFALDW(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!   WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP001',RTMP, RTMP1, RTMP2
   COEFALDW(ITAU)=0.0D0
ENDIF

ENDIF              ! M==0

RTMP=TAU(ITAU)-TAU(ITAU-2)
RTMP1=TAU(ITAU-1)-TAU(ITAU-2)

RTMP2=1.0D0+COEFALDW(ITAU)*XJO(IQUAD)

SRC0=SOURCEFO(IQUAD,ITAU-2,M)%VRAD
IF( ITAU== ITAUEND)THEN
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFOP(IQUAD,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SOURCEFO(IQUAD,ITAU,M)%VRAD-SRC0)/RTMP
ENDIF

IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/XJO(IQUAD))/XJO(IQUAD)  
  INTCOEFF2=0.5D0*RTMP1*RTMP1/XJO(IQUAD)
  INTCOEFF1=INTCOEFF1*EXPTAUODW(ITAU-1,IQUAD)
  INTCOEFF2=INTCOEFF2*EXPTAUODW(ITAU-1,IQUAD)
ELSE
  RTMP3=RTMP2*RTMP1/XJO(IQUAD)
  INTCOEFF1=(EXPTAUODW(ITAU-1,IQUAD)-EXP(-COEFALDW(ITAU)*RTMP1))/RTMP2  
  INTCOEFF2=XJO(IQUAD)*(EXPTAUODW(ITAU,IQUAD)- &
            EXP(-COEFALDW(ITAU)*RTMP1)*(1+RTMP3))/RTMP2/RTMP2
ENDIF
    LSPMNO(IQUAD,ITAU-1,M)%VRAD(:)=    &
      EXPTAUODW(ITAU-1,IQUAD)*LSPMNO(IQUAD,ITAU-2,M)%VRAD(:)   - &
      (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

    LSPMNO(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUODW(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU-1,M)%VRAD(:)   - &
      EXP(-COEFALDW(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
	                   SRC1*RTMP1*INTCOEFF1 ) 
ENDDO   ! LOOP IQUAD
ENDDO   ! LOOP ITAU 
ENDDO   !LOOP OCEAN LAYERS FOR MU<0

! LINEAR - EXPONENTIAL APPROXIMATION FOR OCEAN MU>0
DO N=NOLYR,1,-1
!DO ITAU=OLYR(NOLYR)%ITAUE-2,OLYR(1)%ITAUS,-2
IF(N==NOLYR)THEN
  ITAUEND=OLYR(N)%ITAUE-2
ELSE
  ITAUEND=OLYR(N)%ITAUE-1
ENDIF
DO ITAU=ITAUEND,OLYR(N)%ITAUS,-2
DO IQUAD=NQDOD2+1,NQUADO
IF(M==0)THEN
RTMP=SOURCEFO(IQUAD,ITAU,M)%VRAD(1)
RTMP1=SOURCEFO(IQUAD,ITAU+1,M)%VRAD(1)
IF(ITAU==ITAUEND)THEN
  RTMP2=SRCFOP(IQUAD,N,M)%VRAD(1)
ELSE
  RTMP2=SOURCEFO(IQUAD,ITAU+2,M)%VRAD(1)
ENDIF

RTMP3=RTMP1*RTMP1-RTMP*RTMP2
IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF
IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
  COEFALUP(ITAU)=0.0D0
ELSEIF(RTMP<TINY2)THEN
  COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG(RTMP/RTMP1)
ELSE
IF((RTMP1+SIGN*DSQRT(RTMP3))/RTMP2<0.0D0)THEN
  WRITE(*,*)'TESTING SOURCEFUNC_INTEGRATION_OCEAN',m,itau, iquad,RTMP,RTMP1,RTMP2
  STOP
ENDIF

COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP2)
ENDIF

IF(COEFALUP(ITAU)>LARGERN)COEFALUP(ITAU)=0.0D0
IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
   COEFALUP(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!   WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP002',RTMP, RTMP1, RTMP2
   COEFALUP(ITAU)=0.0D0
ENDIF
ENDIF              ! M==0
RTMP=TAU(ITAU+2)-TAU(ITAU)
RTMP1=TAU(ITAU+1)-TAU(ITAU)



RTMP2=1.0D0+COEFALUP(ITAU)*XJO(IQUAD)

SRC0=SOURCEFO(IQUAD,ITAU,M)%VRAD
IF(ITAU==ITAUEND)THEN
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFOP(IQUAD,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SOURCEFO(IQUAD,ITAU+2,M)%VRAD-SRC0)/RTMP
ENDIF
IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/XJO(IQUAD))/XJO(IQUAD)  
  INTCOEFF2=0.5D0*RTMP1*RTMP1/XJO(IQUAD)
ELSE
  RTMP3=RTMP2*RTMP1/XJO(IQUAD)
  INTCOEFF1=(1-EXP(-RTMP3))/RTMP2  
  INTCOEFF2=XJO(IQUAD)*(1-EXP(-RTMP3)-RTMP3*EXP(-RTMP3))/RTMP2/RTMP2
ENDIF


    LSPMNO(IQUAD,ITAU+1,M)%VRAD(:)=    &
      EXPTAUOUP(ITAU+1,IQUAD)*LSPMNO(IQUAD,ITAU+2,M)%VRAD(:)   + &
                          (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

    LSPMNO(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUOUP(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU+1,M)%VRAD(:)   + &
      EXP(-COEFALUP(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
                       SRC1*RTMP1*INTCOEFF1 )

ENDDO   ! LOOP IQUAD
ENDDO   ! LOOP ITAU
ENDDO   ! LINEAR - EXPONENTIAL APPROXIMATION FOR OCEAN MU>0

ELSE  !USING DIRECT INTEGRATION
!_______OCEAN_______

DO IQUAD=1,NQDOD2
DO I=1,NOLYR
DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
  IF(ITAU>OLYR(1)%ITAUS)THEN

    IF(ITAU==OLYR(I)%ITAUS)THEN
       ARRY1=SRCFOP(IQUAD,I,M)%VRAD(:)
    ELSE
       ARRY1=SOURCEFO(IQUAD,ITAU,M)%VRAD(:)
    ENDIF

    LSPMNO(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUODW(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU-1,M)%VRAD(:)   + &
    ( EXPTAUODW(ITAU,IQUAD)*SOURCEFO(IQUAD,ITAU-1,M)%VRAD(:) + &
      ARRY1 ) * DTAUMUODW(ITAU,IQUAD) 
  ENDIF
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP OCEAN LAYERS FOR MU<0
ENDDO   ! LOOP IQUAD

! UPDATE L^M_N FOR MU>0.0D0

! OCEAN MU>0
DO IQUAD=NQDOD2+1,NQUADO
DO I=NOLYR,1,-1
DO ITAU=OLYR(I)%ITAUE,OLYR(I)%ITAUS,-1
  IF(ITAU<NTTAU)THEN
    IF(ITAU==OLYR(I)%ITAUE)THEN
      ARRY1=SRCFOP(IQUAD,I,M)%VRAD(:)
    ELSE
      ARRY1=SOURCEFO(IQUAD,ITAU+1,M)%VRAD(:)
    ENDIF
  
      LSPMNO(IQUAD,ITAU,M)%VRAD(:)=                           &
        EXPTAUOUP(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU+1,M)%VRAD(:)   + &
      ( EXPTAUOUP(ITAU,IQUAD)*ARRY1 + &
        SOURCEFO(IQUAD,ITAU,M)%VRAD(:) ) * DTAUMUOUP(ITAU,IQUAD) 
  ENDIF
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP OCEAN LAYERS FOR MU>0
ENDDO   ! LOOP IQUAD

ENDIF ! LINEXP IF

ENDSUBROUTINE SOURCEFUNC_INTEGRATION_OCEAN

SUBROUTINE SOURCEFUNC_INTEGRATION_ATMOS(M)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
INTEGER,INTENT(IN) :: M
INTEGER :: IQUAD,I,N,ITAU,ITAUEND
REAL*8 :: SIGN,RTMP, RTMP1,RTMP2,RTMP3,INTCOEFF1,INTCOEFF2
REAL(DP),DIMENSION(4)   :: SRC0,SRC1,ARRY1
REAL*8,PARAMETER :: SLOPE_CUTOFF=100.0D0

IF(LINEXP)THEN

! UPDATE L^M_N FOR MU<0.0D0
! _________ATMOSPHERE___________ 

DO N=1,NALYR
!DO ITAU=ALYR(1)%ITAUS+2,ALYR(NALYR)%ITAUE,2
IF(N==NALYR)THEN
  ITAUEND=ALYR(N)%ITAUE
ELSE
  ITAUEND=ALYR(N)%ITAUE+1
ENDIF
DO ITAU=ALYR(N)%ITAUS+2,ITAUEND,2
DO IQUAD=1,NQDAD2

IF(M==0)THEN
IF( ITAU== ITAUEND)THEN
  RTMP=SRCFAP(IQUAD,N,M)%VRAD(1)
ELSE
  RTMP=SOURCEFA(IQUAD,ITAU,M)%VRAD(1)
ENDIF
RTMP1=SOURCEFA(IQUAD,ITAU-1,M)%VRAD(1)
RTMP2=SOURCEFA(IQUAD,ITAU-2,M)%VRAD(1)
RTMP3=RTMP1*RTMP1-RTMP*RTMP2

IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF
IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
  COEFALDW(ITAU)=0.0D0
ELSEIF(RTMP<TINY2)THEN
  COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
      DLOG(RTMP2/RTMP1)
ELSE
COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP)
ENDIF

IF(COEFALDW(ITAU)>LARGERN)COEFALDW(ITAU)=0.0D0
IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
  COEFALDW(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!  WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP003',RTMP, RTMP1, RTMP2
  COEFALDW(ITAU)=0.0D0
ENDIF

ENDIF               ! M==0

RTMP=TAU(ITAU)-TAU(ITAU-2)
RTMP1=TAU(ITAU-1)-TAU(ITAU-2)



RTMP2=1.0D0+COEFALDW(ITAU)*XJA(IQUAD)
SRC0=SOURCEFA(IQUAD,ITAU-2,M)%VRAD
IF( ITAU== ITAUEND)THEN
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFAP(IQUAD,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SOURCEFA(IQUAD,ITAU,M)%VRAD-SRC0)/RTMP
ENDIF

IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/XJA(IQUAD))/XJA(IQUAD)  
  INTCOEFF1=INTCOEFF1*EXPTAUADW(ITAU-1,IQUAD)
  INTCOEFF2=0.5D0*RTMP1*RTMP1/XJA(IQUAD)
  INTCOEFF2=INTCOEFF2*EXPTAUADW(ITAU-1,IQUAD)
ELSE
  RTMP3=RTMP2*RTMP1/XJA(IQUAD)
  INTCOEFF1=(EXPTAUADW(ITAU-1,IQUAD)-EXP(-COEFALDW(ITAU)*RTMP1))/RTMP2 
  INTCOEFF2=XJA(IQUAD)*(EXPTAUADW(ITAU-1,IQUAD) &
                       -EXP(-COEFALDW(ITAU)*RTMP1)*(1+RTMP3))/RTMP2/RTMP2
ENDIF
   LSPMNA(IQUAD,ITAU-1,M)%VRAD(:)=    &
      EXPTAUADW(ITAU-1,IQUAD)*LSPMNA(IQUAD,ITAU-2,M)%VRAD(:)   - &
      (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

   LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
     EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:)   - &
     EXP(-COEFALDW(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
                     SRC1*RTMP1*INTCOEFF1 )

ENDDO   ! LOOP IQUAD
ENDDO   !LOOP ITAU WITHIN LAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0

! LINEAR - EXPONENTIAL APPROXIMATION FOR ATMOSPHER MU>0
DO N=NALYR,1,-1
!DO ITAU=ALYR(NALYR)%ITAUE-2,ALYR(1)%ITAUS,-2
IF(N==NALYR)THEN
  ITAUEND=ALYR(N)%ITAUE-2
ELSE
  ITAUEND=ALYR(N)%ITAUE-1
ENDIF

DO ITAU=ITAUEND,ALYR(N)%ITAUS,-2
DO IQUAD=NQDAD2+1,NQUADA
IF(M==0)THEN
RTMP=SOURCEFA(IQUAD,ITAU,M)%VRAD(1)
RTMP1=SOURCEFA(IQUAD,ITAU+1,M)%VRAD(1)
IF(ITAU==ITAUEND)THEN
  RTMP2=SRCFAP(IQUAD,N,M)%VRAD(1)
ELSE
  RTMP2=SOURCEFA(IQUAD,ITAU+2,M)%VRAD(1)
ENDIF
RTMP3=RTMP1*RTMP1-RTMP*RTMP2
IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF
IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
COEFALUP(ITAU)=0.0D0
ELSE IF(RTMP<TINY2)THEN
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG(RTMP/RTMP1)
ELSE
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP2)
ENDIF

IF(COEFALUP(ITAU)>LARGERN)COEFALUP(ITAU)=0.0D0
IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
  COEFALUP(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!  WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP004',RTMP, RTMP1, RTMP2
  COEFALUP(ITAU)=0.0D0
ENDIF

ENDIF              ! M==0
RTMP=TAU(ITAU+2)-TAU(ITAU)
RTMP1=TAU(ITAU+1)-TAU(ITAU)



RTMP2=1.0D0+COEFALUP(ITAU)*XJA(IQUAD)
SRC0=SOURCEFA(IQUAD,ITAU,M)%VRAD
IF(ITAU==ITAUEND)THEN
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFAP(IQUAD,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SOURCEFA(IQUAD,ITAU+2,M)%VRAD-SRC0)/RTMP
ENDIF
IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/XJA(IQUAD))/XJA(IQUAD)  
  INTCOEFF2=0.5D0*RTMP1*RTMP1/XJA(IQUAD)
ELSE
  RTMP3=RTMP2*RTMP1/XJA(IQUAD)
  INTCOEFF1=(1-EXP(-RTMP3))/RTMP2  
  INTCOEFF2=XJA(IQUAD)*(1-EXP(-RTMP3)-RTMP3*EXP(-RTMP3))/RTMP2/RTMP2
ENDIF

    LSPMNA(IQUAD,ITAU+1,M)%VRAD(:)=    &
      EXPTAUAUP(ITAU+1,IQUAD)*LSPMNA(IQUAD,ITAU+2,M)%VRAD(:)   + &
                          (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUAUP(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU+1,M)%VRAD(:)   + &
      EXP(-COEFALUP(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
	                      SRC1*RTMP1*INTCOEFF1 )
ENDDO   ! LOOP IQUAD
ENDDO   !ITAU LOOP WITHIN LAYER
ENDDO    ! LAYER LOOP FOR ATMOSPHERE MU>0

ELSE   ! USE LINEAR APPROXIMATION

DO IQUAD=1,NQDAD2
DO I=1,NALYR
DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  IF(ITAU>1)THEN
    IF(ITAU==ALYR(I)%ITAUS)THEN
       ARRY1=SRCFAP(IQUAD,I,M)%VRAD(:)
    ELSE
       ARRY1=SOURCEFA(IQUAD,ITAU,M)%VRAD(:)
    ENDIF

    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:)   + &
    ( EXPTAUADW(ITAU,IQUAD)*SOURCEFA(IQUAD,ITAU-1,M)%VRAD(:) + &
      ARRY1 ) * DTAUMUADW(ITAU,IQUAD) 
  ENDIF
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0
ENDDO   ! LOOP IQUAD

! ATMOSPHERE MU>0

DO IQUAD=NQDAD2+1,NQUADA
DO I=NALYR,1,-1
DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
  IF(ITAU<ALYR(NALYR)%ITAUE)THEN
    IF(ITAU==ALYR(I)%ITAUE)THEN
      ARRY1=SRCFAP(IQUAD,I,M)%VRAD(:)
    ELSE
      ARRY1=SOURCEFA(IQUAD,ITAU+1,M)%VRAD(:)
    ENDIF  
    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUAUP(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU+1,M)%VRAD(:)   + &
    ( EXPTAUAUP(ITAU,IQUAD)*ARRY1 + &
      SOURCEFA(IQUAD,ITAU,M)%VRAD(:) ) * DTAUMUAUP(ITAU,IQUAD) 
  ENDIF
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU>0
ENDDO   ! LOOP IQUAD

ENDIF  ! LINEAR - EXPONENTIAL APPROXIMATION IF.

END SUBROUTINE SOURCEFUNC_INTEGRATION_ATMOS


SUBROUTINE RADOUT_MAPPING(MU_IN,IRRAD,IRRAD_A,IRRAD_O,NMUOUTSHFLA,&
             MUOUTSHFLA, NMUOUTSHFLO,MUOUTSHFLO,NPHIOUT,PHIOUT,MPLIN)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE SnowBRDF
USE RossLiBRDF

implicit none

REAL*8,INTENT(IN):: MU_IN
REAL(DP),DIMENSION(4),INTENT(IN) :: IRRAD,IRRAD_A,IRRAD_O

INTEGER(I4B),INTENT(IN) :: NMUOUTSHFLA,NMUOUTSHFLO,NPHIOUT,MPLIN
REAL*8,DIMENSION(NMUOUTSHFLA),INTENT(IN) :: MUOUTSHFLA
REAL*8,DIMENSION(NMUOUTSHFLO),INTENT(IN) :: MUOUTSHFLO
REAL*8,DIMENSION(NPHIOUT),INTENT(IN) :: PHIOUT

INTEGER :: NUMPHI,IPHI_TMP
REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP

TYPE(ARRAY4),DIMENSION(:,:,:),ALLOCATABLE :: SRCFA_LOCAL,SRCFAP_LOCAL
TYPE(ARRAY4),DIMENSION(:,:,:),ALLOCATABLE :: LSPA_OUT
REAL(DP),DIMENSION(:,:),ALLOCATABLE :: EXPTAUADW_LOCAL,EXPTAUAUP_LOCAL

TYPE(ARRAY4),DIMENSION(:,:,:),ALLOCATABLE :: SRCFO_LOCAL,SRCFOP_LOCAL
TYPE(ARRAY4),DIMENSION(:,:,:),ALLOCATABLE :: LSPO_OUT
REAL(DP),DIMENSION(:,:),ALLOCATABLE :: EXPTAUODW_LOCAL,EXPTAUOUP_LOCAL

INTEGER :: M,ITHETA,IPHI,I,N,ITAU,ITAUEND,ICOM1,IMIE,IDTAU,IQUAD,JQUAD,IMU
REAL*8 :: SIGN,RTMP, RTMP1,RTMP2,RTMP3,INTCOEFF1,INTCOEFF2
REAL(DP),DIMENSION(4) :: SRC0,SRC1,ARRY1,ARRY2,ARRY3
REAL(DP),DIMENSION(4,4) :: MTRX1,FRES_MTRX

REAL*8,DIMENSION(:),ALLOCATABLE :: XJAD2,XJOD2
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADATMP,RADATMP1,RADOUTTMP,RADOTMP,RADOTMP1

TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADATMP,LSPATMP,LRADATMP1,&
                        LSPATMP1,LSPOTMP, LRADOTMP
REAL*8,DIMENSION(:),ALLOCATABLE :: MUTMP

REAL*8 :: COST1,COST2,MUSCAT,SINT1,SINT2,THETA1,THETA2
LOGICAL :: FLAG1,FLAG2
REAL*8,PARAMETER :: SLOPE_CUTOFF=100.0D0

INTEGER,DIMENSION(1):: INTARR

!integer time_array_0(8), time_array_1(8)
!real start_time, finish_time

!  call date_and_time(values=time_array_0)
!  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
!           + time_array_0 (7) + 0.001 * time_array_0 (8)

!NUMPHI=100
!ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
!CALL gauleg(-PI,PI,PHI_TMP,WPHI_TMP,NUMPHI)

ALLOCATE(LSPA_OUT(1:NMUOUTSHFLA,1:ALYR(NALYR)%ITAUE,0:MAXMORD))
DO ICOM1=1,4
  LSPA_OUT(1:NMUOUTSHFLA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1)=0.0D0
ENDDO

IF ((DETA .AND. (.NOT.(WLR_FLAG .AND. OCEAN))) .OR. (DETO .AND. FLATO) )THEN
ALLOCATE(EXPTAUADW_LOCAL(ALYR(1)%ITAUS+1:ALYR(NALYR)%ITAUE,NMUOUTSHFLA),&
         EXPTAUAUP_LOCAL(ALYR(1)%ITAUS:ALYR(NALYR)%ITAUE-1,NMUOUTSHFLA))
DO ITHETA=1,NMUOUTSHFLA
 DO ITAU=ALYR(1)%ITAUS+1,ALYR(NALYR)%ITAUE
   EXPTAUADW_LOCAL(ITAU,ITHETA)=   &
       EXP(-(TAU(ITAU)-TAU(ITAU-1))/DABS(MUOUTSHFLA(ITHETA)))
 ENDDO

 DO ITAU=ALYR(NALYR)%ITAUE-1,ALYR(1)%ITAUS,-1
   EXPTAUAUP_LOCAL(ITAU,ITHETA)=  &
       EXP(-DABS(TAU(ITAU+1)-TAU(ITAU))/DABS(MUOUTSHFLA(ITHETA)))
 ENDDO
ENDDO

ALLOCATE(SRCFA_LOCAL(NMUOUTSHFLA,ALYR(NALYR)%ITAUE,0:MAXMORD), &
         SRCFAP_LOCAL(NMUOUTSHFLA,NALYR,0:MAXMORD)     )

!testing
!write(*,*)'pma local list'
!do m=0,MAXMORD
!DO Itheta=1,NMUOUTSHFLA
!DO JQUAD=1,NQUADA
!write(*,*)MUOUTSHFLA(itheta),xja(jquad),m
!write(*,*)PMAX(Itheta,jQUAD,1,M)%PHMX(1,1),PMAX(Itheta,jQUAD,1,M)%PHMX(1,2),&
!          PMAX(Itheta,jQUAD,1,M)%PHMX(1,3),PMAX(Itheta,jQUAD,1,M)%PHMX(1,4)
!write(*,*)PMAX(Itheta,jQUAD,1,M)%PHMX(2,1),PMAX(Itheta,jQUAD,1,M)%PHMX(2,2),&
!          PMAX(Itheta,jQUAD,1,M)%PHMX(2,3),PMAX(Itheta,jQUAD,1,M)%PHMX(2,4)
!write(*,*)PMAX(Itheta,jQUAD,1,M)%PHMX(3,1),PMAX(Itheta,jQUAD,1,M)%PHMX(3,2),&
!          PMAX(Itheta,jQUAD,1,M)%PHMX(3,3),PMAX(Itheta,jQUAD,1,M)%PHMX(3,4)
!write(*,*)PMAX(Itheta,jQUAD,1,M)%PHMX(4,1),PMAX(Itheta,jQUAD,1,M)%PHMX(4,2),&
!          PMAX(Itheta,jQUAD,1,M)%PHMX(4,3),PMAX(Itheta,jQUAD,1,M)%PHMX(4,4)
!enddo
!enddo
!enddo


DO ICOM1=1,4
  SRCFA_LOCAL(1:NMUOUTSHFLA,1:ALYR(NALYR)%ITAUE,0:MAXMORD)%VRAD(ICOM1)=0.0D0
  SRCFAP_LOCAL(1:NMUOUTSHFLA,1:NALYR,0:MAXMORD)%VRAD(ICOM1)=0.0D0
ENDDO

DO M=0,MAXMORD
DO ITHETA=1,NMUOUTSHFLA
DO JQUAD=1,NQUADA
DO I=1,NALYR
  IMIE=ALYR(I)%IPT
  MTRX1=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX
  DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
     ARRY1=LSPA(JQUAD,ITAU,M)%VRAD
     ARRY2=MATMUL(MTRX1,ARRY1)
     SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD= SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD + &
                    0.5D0*ALYR(I)%LBDOM*WTA(JQUAD)*ARRY2
  ENDDO  ! LOOP SUBLAYERS
  IF(I==NALYR)THEN
    ITAU=ALYR(I)%ITAUE
  ELSE
    ITAU=ALYR(I)%ITAUE+1
  ENDIF
  ARRY1=LSPA(JQUAD,ITAU,M)%VRAD
  ARRY2=MATMUL(MTRX1,ARRY1)
  SRCFAP_LOCAL(ITHETA,I,M)%VRAD=SRCFAP_LOCAL(ITHETA,I,M)%VRAD + &
                  0.5D0*ALYR(I)%LBDOM*WTA(JQUAD)*ARRY2

ENDDO   !LOOP ATMOSPHERE LAYERS FOR SOURCE FUCTION
ENDDO   !LOOP JQUAD
ENDDO   ! LOOP ITHETA
ENDDO   !LOOP M

! UPDATE L^M_N FOR MU<0.0D0
! _________ATMOSPHERE___________ 
DO M=0,MAXMORD
DO ITHETA=1,NMUOUTSHFLA
IF(MUOUTSHFLA(ITHETA)<0.0D0) THEN
DO N=1,NALYR

IF(N==NALYR)THEN
  ITAUEND=ALYR(N)%ITAUE
ELSE
  ITAUEND=ALYR(N)%ITAUE+1
ENDIF
DO ITAU=ALYR(N)%ITAUS+2,ITAUEND,2

IF(M==0)THEN
  IF( ITAU== ITAUEND)THEN
    RTMP=SRCFAP_LOCAL(ITHETA,N,M)%VRAD(1)
  ELSE
    RTMP=SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD(1)
  ENDIF
  RTMP1=SRCFA_LOCAL(ITHETA,ITAU-1,M)%VRAD(1)
  RTMP2=SRCFA_LOCAL(ITHETA,ITAU-2,M)%VRAD(1)
  RTMP3=RTMP1*RTMP1-RTMP*RTMP2

  IF(RTMP>RTMP2) THEN
     SIGN=1.0D0
  ELSE
     SIGN=-1.0D0
  ENDIF
  IF(RTMP3<0.0D0)RTMP3=0.0D0
  IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
    COEFALDW(ITAU)=0.0D0
  ELSEIF(RTMP<TINY2)THEN
    COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
        DLOG(RTMP2/RTMP1)
  ELSE
  COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
        DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP)
  ENDIF

  IF(COEFALDW(ITAU)>LARGERN)COEFALDW(ITAU)=0.0D0
  IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
    COEFALDW(ITAU)=0.0D0
  ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!    WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP001',RTMP, RTMP1, RTMP2
    COEFALDW(ITAU)=0.0D0
  ENDIF

ENDIF ! M==0

  RTMP=TAU(ITAU)-TAU(ITAU-2)
  RTMP1=TAU(ITAU-1)-TAU(ITAU-2)

RTMP2=1.0D0+COEFALDW(ITAU)*MUOUTSHFLA(ITHETA)
SRC0=SRCFA_LOCAL(ITHETA,ITAU-2,M)%VRAD
IF( ITAU== ITAUEND)THEN
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFAP_LOCAL(ITHETA,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD-SRC0)/RTMP
ENDIF

IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/MUOUTSHFLA(ITHETA))/MUOUTSHFLA(ITHETA)
  INTCOEFF1=INTCOEFF1*EXPTAUADW_LOCAL(ITAU-1,ITHETA)
  INTCOEFF2=0.5D0*RTMP1*RTMP1/MUOUTSHFLA(ITHETA)
  INTCOEFF2=INTCOEFF2*EXPTAUADW_LOCAL(ITAU-1,ITHETA)
ELSE
  RTMP3=RTMP2*RTMP1/MUOUTSHFLA(ITHETA)
  INTCOEFF1=(EXPTAUADW_LOCAL(ITAU-1,ITHETA)-EXP(-COEFALDW(ITAU)*RTMP1))/RTMP2 
  INTCOEFF2=MUOUTSHFLA(ITHETA)*(EXPTAUADW_LOCAL(ITAU-1,ITHETA) &
                       -EXP(-COEFALDW(ITAU)*RTMP1)*(1+RTMP3))/RTMP2/RTMP2
ENDIF
   LSPA_OUT(ITHETA,ITAU-1,M)%VRAD(:)=    &
      EXPTAUADW_LOCAL(ITAU-1,ITHETA)*LSPA_OUT(ITHETA,ITAU-2,M)%VRAD(:)   - &
      (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

   LSPA_OUT(ITHETA,ITAU,M)%VRAD(:)=    &
     EXPTAUADW_LOCAL(ITAU,ITHETA)*LSPA_OUT(ITHETA,ITAU-1,M)%VRAD(:)   - &
     EXP(-COEFALDW(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
                     SRC1*RTMP1*INTCOEFF1 )

ENDDO   !LOOP ITAU WITHIN LAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0

ELSEIF(.NOT.WLR_FLAG)THEN ! MUOUTSHFLA(ITHETA)>0

! LINEAR - EXPONENTIAL APPROXIMATION FOR ATMOSPHER MU>0
DO N=NALYR,1,-1
!DO ITAU=ALYR(NALYR)%ITAUE-2,ALYR(1)%ITAUS,-2
IF(N==NALYR)THEN
  ITAUEND=ALYR(N)%ITAUE-2
ELSE
  ITAUEND=ALYR(N)%ITAUE-1
ENDIF

DO ITAU=ITAUEND,ALYR(N)%ITAUS,-2
IF(M==0)THEN
RTMP=SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD(1)
RTMP1=SRCFA_LOCAL(ITHETA,ITAU+1,M)%VRAD(1)
IF(ITAU==ITAUEND)THEN
  RTMP2=SRCFAP_LOCAL(ITHETA,N,M)%VRAD(1)
ELSE
  RTMP2=SRCFA_LOCAL(ITHETA,ITAU+2,M)%VRAD(1)
ENDIF
RTMP3=RTMP1*RTMP1-RTMP*RTMP2
IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF
IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
COEFALUP(ITAU)=0.0D0
ELSE IF(RTMP<TINY2)THEN
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG(RTMP/RTMP1)
ELSE
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP2)
ENDIF

IF(COEFALUP(ITAU)>LARGERN)COEFALUP(ITAU)=0.0D0

IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
  COEFALUP(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!  WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP002',RTMP, RTMP1, RTMP2
  COEFALUP(ITAU)=0.0D0
ENDIF

ENDIF !M==0
RTMP=TAU(ITAU+2)-TAU(ITAU)
RTMP1=TAU(ITAU+1)-TAU(ITAU)

RTMP2=1.0D0+COEFALUP(ITAU)*MUOUTSHFLA(ITHETA)
SRC0=SRCFA_LOCAL(ITHETA,ITAU,M)%VRAD
IF(ITAU==ITAUEND)THEN
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFAP_LOCAL(ITHETA,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFA_LOCAL(ITHETA,ITAU+2,M)%VRAD-SRC0)/RTMP
ENDIF
IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/MUOUTSHFLA(ITHETA))/MUOUTSHFLA(ITHETA)  
  INTCOEFF2=0.5D0*RTMP1*RTMP1/MUOUTSHFLA(ITHETA)
ELSE
  RTMP3=RTMP2*RTMP1/MUOUTSHFLA(ITHETA)
  INTCOEFF1=(1-EXP(-RTMP3))/RTMP2  
  INTCOEFF2=MUOUTSHFLA(ITHETA)*(1-EXP(-RTMP3)-RTMP3*EXP(-RTMP3))/RTMP2/RTMP2
ENDIF

    LSPA_OUT(ITHETA,ITAU+1,M)%VRAD(:)=    &
      EXPTAUAUP_LOCAL(ITAU+1,ITHETA)*LSPA_OUT(ITHETA,ITAU+2,M)%VRAD(:) + &
                          (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

    LSPA_OUT(ITHETA,ITAU,M)%VRAD(:)=    &
      EXPTAUAUP_LOCAL(ITAU,ITHETA)*LSPA_OUT(ITHETA,ITAU+1,M)%VRAD(:)   + &
      EXP(-COEFALUP(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
	                      SRC1*RTMP1*INTCOEFF1 )
ENDDO   !ITAU LOOP WITHIN LAYER
ENDDO    ! LAYER LOOP FOR ATMOSPHERE MU>0
ENDIF

ENDDO   ! LOOP ITHETA
ENDDO   ! LOOP M
DEALLOCATE(EXPTAUADW_LOCAL,EXPTAUAUP_LOCAL,SRCFA_LOCAL,SRCFAP_LOCAL)
ENDIF ! IF ((DETA .AND. (.NOT.(WLR_FLAG .AND. OCEAN))) .OR. (DETO .AND. FLATO) )

IF(OCEAN.AND. WCFLG .AND. DETA) THEN
  DO ITHETA=1,NMUOUTSHFLA
  IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
  DO N=NALYR,0,-1
  IF(N==NALYR)THEN
    ITAU=ALYR(N)%ITAUE
  ELSEIF(N==0)THEN
    ITAU=ALYR(1)%ITAUS
  ELSE  
    ITAU=ALYR(N)%ITAUE+1
  ENDIF
     RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLA(ITHETA))
     IF(WLR_FLAG .AND. OCEAN)THEN
       LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)= &
            LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)+  &
            EXP(-RTMP)*FWC*(IRRAD_O(1)*(1.0D0-WCLBDO))
     ELSE
       LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)= &
            LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)+  &
            EXP(-RTMP)*FWC*(IRRAD_A(1)*WCLBDO+IRRAD_O(1)*(1.0D0-WCLBDO))
     ENDIF
  ENDDO ! NALYR 
  
  ENDDO ! ITHETA LOOP
ENDIF

IF(OCEAN.AND. RSRADDFLG .AND. DETA) THEN
  DO ITHETA=1,NMUOUTSHFLA
  IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
  DO N=NALYR,0,-1
  IF(N==NALYR)THEN
    ITAU=ALYR(N)%ITAUE
  ELSEIF(N==0)THEN
    ITAU=ALYR(1)%ITAUS
  ELSE
    ITAU=ALYR(N)%ITAUE+1
  ENDIF
     RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLA(ITHETA))
	 LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)= &
            LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)+EXP(-RTMP)*IRRAD_A(1)*RSR0P*PI
  ENDDO ! NALYR
  
  ENDDO ! ITHETA LOOP
ENDIF

IF((.NOT.OCEAN).AND. LAMB .AND. DETA) THEN
  DO ITHETA=1,NMUOUTSHFLA
  IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
  DO N=NALYR,0,-1 
  IF(N==NALYR)THEN
    ITAU=ALYR(N)%ITAUE
  ELSEIF(N==0)THEN
    ITAU=ALYR(1)%ITAUS
  ELSE  
    ITAU=ALYR(N)%ITAUE+1
  ENDIF
    RTMP=DABS((TOTALTAU-TAU(ITAU))/MUOUTSHFLA(ITHETA))
    LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)= &
          LSPA_OUT(ITHETA,ITAU,0)%VRAD(1)+EXP(-RTMP)*IRRAD(1)
  ENDDO !NALYR
  ENDDO !ITHETA LOOP
ENDIF

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  ALLOCATE(LSPO_OUT(1:NMUOUTSHFLO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD))
  DO ICOM1=1,4
    LSPO_OUT(1:NMUOUTSHFLO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM1)=0.0D0
  ENDDO
ENDIF

IF((OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) .AND. (DETO .OR. FLATO)) THEN


ALLOCATE(EXPTAUODW_LOCAL(OLYR(1)%ITAUS+1:OLYR(NOLYR)%ITAUE,NMUOUTSHFLO),&
         EXPTAUOUP_LOCAL(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE-1,NMUOUTSHFLO))

DO ITHETA=1,NMUOUTSHFLO
 DO ITAU=OLYR(1)%ITAUS+1,OLYR(NOLYR)%ITAUE
   EXPTAUODW_LOCAL(ITAU,ITHETA)=   &
       EXP(-(TAU(ITAU)-TAU(ITAU-1))/DABS(MUOUTSHFLO(ITHETA)))
 ENDDO

 DO ITAU=OLYR(NOLYR)%ITAUE-1,OLYR(1)%ITAUS,-1
   EXPTAUOUP_LOCAL(ITAU,ITHETA)=  &
       EXP(-DABS(TAU(ITAU+1)-TAU(ITAU))/DABS(MUOUTSHFLO(ITHETA)))
 ENDDO
ENDDO

ALLOCATE(SRCFO_LOCAL(NMUOUTSHFLO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD), &
         SRCFOP_LOCAL(NMUOUTSHFLO,NOLYR,0:MAXMORD)     )

!testing
!write(*,*)'PMOX list'
!do m=0,MAXMORD
!DO Itheta=1,NMUOUTSHFLO
!DO JQUAD=1,NQUADA
!write(*,*)MUOUTSHFLO(itheta),xja(jquad),m
!write(*,*)PMOX(Itheta,jQUAD,1,M)%PHMX(1,1),PMOX(Itheta,jQUAD,1,M)%PHMX(1,2),&
!          PMOX(Itheta,jQUAD,1,M)%PHMX(1,3),PMOX(Itheta,jQUAD,1,M)%PHMX(1,4)
!write(*,*)PMOX(Itheta,jQUAD,1,M)%PHMX(2,1),PMOX(Itheta,jQUAD,1,M)%PHMX(2,2),&
!          PMOX(Itheta,jQUAD,1,M)%PHMX(2,3),PMOX(Itheta,jQUAD,1,M)%PHMX(2,4)
!write(*,*)PMOX(Itheta,jQUAD,1,M)%PHMX(3,1),PMOX(Itheta,jQUAD,1,M)%PHMX(3,2),&
!          PMOX(Itheta,jQUAD,1,M)%PHMX(3,3),PMOX(Itheta,jQUAD,1,M)%PHMX(3,4)
!write(*,*)PMOX(Itheta,jQUAD,1,M)%PHMX(4,1),PMOX(Itheta,jQUAD,1,M)%PHMX(4,2),&
!          PMOX(Itheta,jQUAD,1,M)%PHMX(4,3),PMOX(Itheta,jQUAD,1,M)%PHMX(4,4)
!enddo
!enddo
!enddo

DO ICOM1=1,4
  SRCFO_LOCAL(1:NMUOUTSHFLO,OLYR(1)%ITAUS:NTTAU,0:MAXMORD)%VRAD(ICOM1)=0.0D0
  SRCFOP_LOCAL(1:NMUOUTSHFLO,1:NOLYR,0:MAXMORD)%VRAD(ICOM1)=0.0D0
ENDDO

DO M=0,MAXMORD
DO ITHETA=1,NMUOUTSHFLO
DO JQUAD=1,NQUADO
DO I=1,NOLYR
  IMIE=OLYR(I)%IPT
  MTRX1=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX
  DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
     ARRY1=LSPO(JQUAD,ITAU,M)%VRAD
     ARRY2=MATMUL(MTRX1,ARRY1)
     SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD= SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD + &
                    0.5D0*OLYR(I)%LBDOM*WTO(JQUAD)*ARRY2
  ENDDO  ! LOOP SUBLAYERS
  IF(I==NOLYR)THEN
    ITAU=OLYR(I)%ITAUE
  ELSE
    ITAU=OLYR(I)%ITAUE+1
  ENDIF
  ARRY1=LSPO(JQUAD,ITAU,M)%VRAD
  ARRY2=MATMUL(MTRX1,ARRY1)
  SRCFOP_LOCAL(ITHETA,I,M)%VRAD=SRCFOP_LOCAL(ITHETA,I,M)%VRAD + &
                  0.5D0*OLYR(I)%LBDOM*WTO(JQUAD)*ARRY2

ENDDO   !LOOP ATMOSPHERE LAYERS FOR SOURCE FUCTION
ENDDO   !LOOP JQUAD
ENDDO   ! LOOP ITHETA
ENDDO   !LOOP M

! UPDATE L^M_N FOR MU<0.0D0
! _________OCEAN___________ 
DO M=0,MAXMORD
DO ITHETA=1,NMUOUTSHFLO
IF(MUOUTSHFLO(ITHETA)<0.0D0) THEN
DO N=1,NOLYR

IF(N==NOLYR)THEN
  ITAUEND=OLYR(N)%ITAUE
ELSE
  ITAUEND=OLYR(N)%ITAUE+1
ENDIF
DO ITAU=OLYR(N)%ITAUS+2,ITAUEND,2

IF(M==0)THEN
  IF( ITAU== ITAUEND)THEN
    RTMP=SRCFOP_LOCAL(ITHETA,N,M)%VRAD(1)
  ELSE
    RTMP=SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD(1)
  ENDIF
  RTMP1=SRCFO_LOCAL(ITHETA,ITAU-1,M)%VRAD(1)
  RTMP2=SRCFO_LOCAL(ITHETA,ITAU-2,M)%VRAD(1)
  RTMP3=RTMP1*RTMP1-RTMP*RTMP2

  IF(RTMP>RTMP2) THEN
     SIGN=1.0D0
  ELSE
     SIGN=-1.0D0
  ENDIF
  IF(RTMP3<0.0D0)RTMP3=0.0D0
  IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
    COEFALDW(ITAU)=0.0D0
  ELSEIF(RTMP<TINY2)THEN
    COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
        DLOG(RTMP2/RTMP1)
  ELSE
  COEFALDW(ITAU)=2.0D0/(TAU(ITAU)-TAU(ITAU-2))* &
        DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP)
  ENDIF

  IF(COEFALDW(ITAU)>LARGERN)COEFALDW(ITAU)=0.0D0
  IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
     COEFALDW(ITAU)=0.0D0
  ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!     WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP001',RTMP, RTMP1, RTMP2
     COEFALDW(ITAU)=0.0D0
  ENDIF
ENDIF ! M==0

  RTMP=TAU(ITAU)-TAU(ITAU-2)
  RTMP1=TAU(ITAU-1)-TAU(ITAU-2)

RTMP2=1.0D0+COEFALDW(ITAU)*MUOUTSHFLO(ITHETA)
SRC0=SRCFO_LOCAL(ITHETA,ITAU-2,M)%VRAD
IF( ITAU== ITAUEND)THEN
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFOP_LOCAL(ITHETA,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALDW(ITAU)*RTMP)*SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD-SRC0)/RTMP
ENDIF

IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/MUOUTSHFLO(ITHETA))/MUOUTSHFLO(ITHETA)
  INTCOEFF1=INTCOEFF1*EXPTAUODW_LOCAL(ITAU-1,ITHETA)
  INTCOEFF2=0.5D0*RTMP1*RTMP1/MUOUTSHFLO(ITHETA)
  INTCOEFF2=INTCOEFF2*EXPTAUODW_LOCAL(ITAU-1,ITHETA)
ELSE
  RTMP3=RTMP2*RTMP1/MUOUTSHFLO(ITHETA)
  INTCOEFF1=(EXPTAUODW_LOCAL(ITAU-1,ITHETA)-EXP(-COEFALDW(ITAU)*RTMP1))/RTMP2 
  INTCOEFF2=MUOUTSHFLO(ITHETA)*(EXPTAUODW_LOCAL(ITAU-1,ITHETA) &
                       -EXP(-COEFALDW(ITAU)*RTMP1)*(1+RTMP3))/RTMP2/RTMP2
ENDIF
   LSPO_OUT(ITHETA,ITAU-1,M)%VRAD(:)=    &
      EXPTAUODW_LOCAL(ITAU-1,ITHETA)*LSPO_OUT(ITHETA,ITAU-2,M)%VRAD(:)   - &
      (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

   LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)=    &
     EXPTAUODW_LOCAL(ITAU,ITHETA)*LSPO_OUT(ITHETA,ITAU-1,M)%VRAD(:)   - &
     EXP(-COEFALDW(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
                     SRC1*RTMP1*INTCOEFF1 )

ENDDO   !LOOP ITAU WITHIN LAYERS
ENDDO   !LOOP OCEAN LAYERS FOR MU<0


ELSE ! MUOUTSHFLO(ITHETA)>0

! LINEAR - EXPONENTIAL APPROXIMATION FOR OCEAN MU>0
DO N=NOLYR,1,-1
IF(N==NOLYR)THEN
  ITAUEND=OLYR(N)%ITAUE-2
ELSE
  ITAUEND=OLYR(N)%ITAUE-1
ENDIF

DO ITAU=ITAUEND,OLYR(N)%ITAUS,-2
IF(M==0)THEN
RTMP=SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD(1)
RTMP1=SRCFO_LOCAL(ITHETA,ITAU+1,M)%VRAD(1)
IF(ITAU==ITAUEND)THEN
  RTMP2=SRCFOP_LOCAL(ITHETA,N,M)%VRAD(1)
ELSE
  RTMP2=SRCFO_LOCAL(ITHETA,ITAU+2,M)%VRAD(1)
ENDIF
RTMP3=RTMP1*RTMP1-RTMP*RTMP2
IF(RTMP>RTMP2) THEN
   SIGN=1.0D0
ELSE
   SIGN=-1.0D0
ENDIF
IF(RTMP3<0.0D0)RTMP3=0.0D0
IF(RTMP<TINY2 .AND. RTMP1<TINY2)THEN
COEFALUP(ITAU)=0.0D0
ELSE IF(RTMP<TINY2)THEN
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG(RTMP/RTMP1)
ELSE
COEFALUP(ITAU)=2.0D0/(TAU(ITAU+2)-TAU(ITAU))* &
      DLOG((RTMP1+SIGN*DSQRT(RTMP3))/RTMP2)
ENDIF

IF(COEFALUP(ITAU)>LARGERN)COEFALUP(ITAU)=0.0D0
IF(RTMP < 1.0D-64 .or. RTMP1 < 1.0D-64 .OR. RTMP2 < 1.0D-64 )THEN
  COEFALUP(ITAU)=0.0D0
ELSEIF(RTMP1*RTMP1/RTMP/RTMP2>SLOPE_CUTOFF .OR. RTMP*RTMP2/RTMP1/RTMP1>SLOPE_CUTOFF)THEN
!  WRITE(*,*)'SLOPE_CUTOFF EXCEEDED TSP002',RTMP, RTMP1, RTMP2
  COEFALUP(ITAU)=0.0D0
ENDIF


ENDIF !M==0
RTMP=TAU(ITAU+2)-TAU(ITAU)
RTMP1=TAU(ITAU+1)-TAU(ITAU)

RTMP2=1.0D0+COEFALUP(ITAU)*MUOUTSHFLO(ITHETA)
SRC0=SRCFO_LOCAL(ITHETA,ITAU,M)%VRAD
IF(ITAU==ITAUEND)THEN
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFOP_LOCAL(ITHETA,N,M)%VRAD-SRC0)/RTMP
ELSE
SRC1=(EXP(COEFALUP(ITAU)*RTMP)*SRCFO_LOCAL(ITHETA,ITAU+2,M)%VRAD-SRC0)/RTMP
ENDIF
IF(ABS(RTMP2)<TINY2)THEN
  INTCOEFF1=(RTMP1-0.5D0*RTMP2*RTMP1*RTMP1/MUOUTSHFLO(ITHETA))/MUOUTSHFLO(ITHETA)  
  INTCOEFF2=0.5D0*RTMP1*RTMP1/MUOUTSHFLO(ITHETA)
ELSE
  RTMP3=RTMP2*RTMP1/MUOUTSHFLO(ITHETA)
  INTCOEFF1=(1-EXP(-RTMP3))/RTMP2  
  INTCOEFF2=MUOUTSHFLO(ITHETA)*(1-EXP(-RTMP3)-RTMP3*EXP(-RTMP3))/RTMP2/RTMP2
ENDIF

    LSPO_OUT(ITHETA,ITAU+1,M)%VRAD(:)=    &
      EXPTAUOUP_LOCAL(ITAU+1,ITHETA)*LSPO_OUT(ITHETA,ITAU+2,M)%VRAD(:) + &
                          (SRC0*INTCOEFF1 + SRC1*INTCOEFF2)

    LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)=    &
      EXPTAUOUP_LOCAL(ITAU,ITHETA)*LSPO_OUT(ITHETA,ITAU+1,M)%VRAD(:)   + &
      EXP(-COEFALUP(ITAU)*RTMP1)*( SRC0*INTCOEFF1 + SRC1*INTCOEFF2 +  &
	                      SRC1*RTMP1*INTCOEFF1 )

ENDDO   !ITAU LOOP WITHIN LAYER
ENDDO    ! LAYER LOOP FOR OCEAN MU>0
ENDIF

ENDDO   ! LOOP ITHETA
ENDDO   ! LOOP M

IF(LAMB)THEN
  DO ITHETA=1,NMUOUTSHFLO
  IF(MUOUTSHFLO(ITHETA)<0.0D0)CYCLE
  DO N=NOLYR,0,-1
    IF(N==NOLYR)THEN
      ITAU=OLYR(N)%ITAUE
    ELSEIF(N==0)THEN
      ITAU=OLYR(1)%ITAUS
    ELSE
      ITAU=OLYR(N)%ITAUE+1
    ENDIF 
     RTMP=DABS((TOTALTAU-TAU(ITAU))/MUOUTSHFLO(ITHETA))
     LSPO_OUT(ITHETA,ITAU,0)%VRAD(1)= &
       LSPO_OUT(ITHETA,ITAU,0)%VRAD(1)+ EXP(-RTMP)*IRRAD(1)

  ENDDO 
  ENDDO ! ITHETA LOOP
ENDIF
DEALLOCATE(EXPTAUOUP_LOCAL,EXPTAUODW_LOCAL,&
           SRCFO_LOCAL,SRCFOP_LOCAL)

ENDIF !(OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) .AND. (DETO .OR. FLATO))

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. WCFLG)THEN
  DO ITHETA=1,NMUOUTSHFLO
  IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
  DO N=NOLYR,0,-1
    IF(N==NOLYR)THEN
      ITAU=OLYR(N)%ITAUE
    ELSEIF(N==0)THEN
      ITAU=OLYR(1)%ITAUS
    ELSE
      ITAU=OLYR(N)%ITAUE+1
    ENDIF 

     RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLO(ITHETA))
     LSPO_OUT(ITHETA,ITAU,0)%VRAD(1)= &
           LSPO_OUT(ITHETA,ITAU,0)%VRAD(1)+  &
            EXP(-RTMP)*FWC*(IRRAD_A(1)*(1.0D0-WCLBDO)+IRRAD_O(1)*WCLBDO)

  ENDDO  ! OCEAN LAYER LOOP
  ENDDO  ! ITHETA LOOP
ENDIF


ALLOCATE(XJOD2(NQDOD2),XJAD2(NQDAD2))
ALLOCATE(RADATMP(NQDAD2,4),RADATMP1(NQDAD2,4),RADOUTTMP(NMUOUTSHFLA,4))
ALLOCATE(RADOTMP(NQDOD2,4),RADOTMP1(NQDOD2,4))

! ATMOSPHERE LAYERS MU>0 BOUNDARY CONDITION  
! OCEAN LIGHT TRANSMITTANCE for rough ocean surface
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .and. (.NOT. FLATO) .AND. DETA)THEN
  DO M=0,MAXMORD
    RADATMP=0.0D0
    ITAU=OLYR(1)%ITAUS

    DO IQUAD=NQDOD2+1,NQUADO
      RADOTMP1(IQUAD-NQDOD2,:)=LSPO(IQUAD,ITAU,M)%VRAD(:)
    ENDDO
    DO JQUAD=NQDAD2+1,NQUADA
      DO IQUAD=NQDOD2+1,NQUADO
        XJOD2(IQUAD-NQDOD2)=XJOT(IQUAD,JQUAD)
      ENDDO
    CALL RADINTPL2(MPLIN,NQDOD2,XJO(NQDOD2+1),RADOTMP1,NQDOD2, &
                XJOD2,RADOTMP)
    DO IQUAD=NQDOD2+1,NQUADO
        ARRY1=RADOTMP(IQUAD-NQDOD2,:)
        MTRX1=FRES_TRANO(IQUAD,JQUAD,M)%PHMX
        ARRY2=MATMUL(MTRX1,ARRY1)
        RADATMP(JQUAD-NQDAD2,:)=RADATMP(JQUAD-NQDAD2,:)+ &
               2.0D0*ARRY2*WTOT(IQUAD,JQUAD)
    ENDDO ! QUAD LOOP
    ENDDO ! QUAD LOOP

    IF(WCFLG)RADATMP=RADATMP*(1.0D0-FWC)

! UPDATE LSPA_OUT
    CALL RADINTPL2(MPLIN,NQDAD2,XJA(NQDAD2+1),RADATMP,&
                   NMUOUTSHFLA,MUOUTSHFLA,RADOUTTMP)

    DO ITHETA=1,NMUOUTSHFLA
    IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE

    DO N=NALYR,0,-1 
      IF(N==NALYR)THEN
        ITAU=ALYR(N)%ITAUE
      ELSEIF(N==0)THEN
        ITAU=ALYR(1)%ITAUS
      ELSE
        ITAU=ALYR(N)%ITAUE+1
      ENDIF

      RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLA(ITHETA))
      ARRY1=EXP(-RTMP)*RADOUTTMP(ITHETA,:)

      LSPA_OUT(ITHETA,ITAU,M)%VRAD(:)=&
         LSPA_OUT(ITHETA,ITAU,M)%VRAD(:)+ARRY1(:)
    ENDDO ! ALYR LOOP
    ENDDO ! ITHETA
  ENDDO ! M LOOP
ENDIF ! (OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .and. (.NOT. FLATO) .AND. DETA)
DEALLOCATE(RADOUTTMP)

! OCEAN LAYERS MU<0 BOUNDARY CONDITION  
! OCEAN LIGHT reflectance for rough ocean surface
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .and. (.NOT. FLATO) .AND. DETO)THEN
  ALLOCATE(RADOUTTMP(NMUOUTSHFLO,4))

  RADATMP=0.0d0
  RADATMP1=0.0d0
  RADOTMP=0.0d0
  RADOTMP1=0.0d0
  RADOUTTMP=0.0d0
! OCEAN LIGHT REFLECTED BY THE AIR - SEA INTERFACE
  DO M=0,MAXMORD
    RADOTMP=0.0D0
    ITAU=OLYR(1)%ITAUS
  DO IQUAD=NQDOD2+1,NQUADO
  DO JQUAD=1,NQDOD2
    ARRY1=LSPO(IQUAD,ITAU,M)%VRAD
    MTRX1=FRES_REFLO(IQUAD,JQUAD,M)%PHMX
    ARRY2=MATMUL(MTRX1,ARRY1)
    RADOTMP(JQUAD,:)=RADOTMP(JQUAD,:)+ARRY2*WTO(IQUAD)
  ENDDO ! QUAD LOOP
  ENDDO ! QUAD LOOP
  RADOTMP=2.0D0*RADOTMP

  IF(WCFLG)RADOTMP=RADOTMP*(1.0D0-FWC)

  CALL RADINTPL2(2,NQDOD2,XJO,RADOTMP,NMUOUTSHFLO,MUOUTSHFLO,RADOUTTMP)

! UPDATE LSPO_OUT

  DO ITHETA=1,NMUOUTSHFLO
     IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
     DO N=NOLYR,0,-1
       IF(N==NOLYR)THEN
         ITAU=OLYR(N)%ITAUE
       ELSEIF(N==0)THEN
         ITAU=OLYR(1)%ITAUS
       ELSE
         ITAU=OLYR(N)%ITAUE+1
       ENDIF

       RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLO(ITHETA))
       LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)= &
       LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)+&
             EXP(-RTMP)*RADOUTTMP(ITHETA,:)

     ENDDO ! ITAU LOOP
  ENDDO ! ITHETA LOOP
  ENDDO ! M LOOP
  DEALLOCATE(RADOUTTMP)
ENDIF !(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .and. (.NOT. FLATO) .AND. DETO)

! ATMOSPHERE LAYERS MU>0 resultant from sky light diffuse reflectance
IF((OCEAN .AND. (.NOT. FLATO) .AND. DETA .AND. (.NOT.WLR_FLAG)) &
						.or. pBRDF .or. fSnowBRDF .or. fRossLiBRDF)THEN
  ALLOCATE(RADOUTTMP(NMUOUTSHFLA,4))
  RADOUTTMP=0.0d0
  DO M=0,MAXMORD
    RADATMP=0.0D0
    ITAU=ALYR(NALYR)%ITAUE
    DO IQUAD=1,NQDAD2
      ARRY1=LSPA(IQUAD,ITAU,M)%VRAD
	    DO JQUAD=NQDAD2+1,NQUADA
          MTRX1=FRES_REFLA(IQUAD,JQUAD,M)%PHMX
          ARRY2=MATMUL(MTRX1,ARRY1)
          RADATMP(JQUAD-NQDAD2,:)=RADATMP(JQUAD-NQDAD2,:)+2.0d0*ARRY2*WTA(IQUAD)
        ENDDO ! QUAD LOOP
    ENDDO ! QUAD LOOP

    IF(WCFLG)RADATMP=RADATMP*(1.0D0-FWC)

    CALL RADINTPL2(MPLIN,NQDAD2,XJA(NQDAD2+1),RADATMP,NMUOUTSHFLA,MUOUTSHFLA,RADOUTTMP)

! UPDATE LSPA_OUT

    DO IDTAU=1,NDTAUA
    DO ITHETA=1,NMUOUTSHFLA
      IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
     IF(pBRDF .or. fSnowBRDF .or. fRossLiBRDF)THEN
         RTMP=DABS((TAU(INDXDETA(IDTAU))-TOTALTAU)/MUOUTSHFLA(ITHETA))
     ELSE
		 RTMP=DABS((TAU(INDXDETA(IDTAU))-OITAU)/MUOUTSHFLA(ITHETA))
     ENDIF
     LSPA_OUT(ITHETA,INDXDETA(IDTAU),M)%VRAD(:)= &
         LSPA_OUT(ITHETA,INDXDETA(IDTAU),M)%VRAD(:)+&
                      EXP(-RTMP)*RADOUTTMP(ITHETA,:)
    ENDDO ! ITHETA LOOP
    ENDDO ! IDTAU
  ENDDO ! M LOOP
  DEALLOCATE(RADOUTTMP)
ENDIF ! ROUGH OCEAN IF FOR SKY LIGHT REFLECTANCE
!
! OCEAN LAYERS MU<0 BOUNDARY CONDITION
! ATMOSPHERE DIFFUSE LIGHT TRANSMITTANCE for rough ocean surface
IF(OCEAN .AND. (.NOT. FLATO) .AND. DETO)THEN
  ALLOCATE(RADOUTTMP(NMUOUTSHFLO,4))
  RADOUTTMP=0.0d0
  DO M=0,MAXMORD
    RADATMP=0.0D0
    ITAU=ALYR(NALYR)%ITAUE
    RADOTMP=0.0D0
    DO IQUAD=1,NQDAD2
      RADATMP1(IQUAD,:)=LSPA(IQUAD,ITAU,M)%VRAD(:)
    ENDDO

    DO JQUAD=1,NQDOD2
      DO IQUAD=1,NQDAD2
        XJAD2(IQUAD)=XJAT(IQUAD,JQUAD)
      ENDDO
      CALL RADINTPL2(MPLIN,NQDAD2,XJA,RADATMP1,NQDAD2,XJAD2,RADATMP)

      DO IQUAD=1,NQDAD2
        ARRY1(:)=RADATMP(IQUAD,:)
        MTRX1=FRES_TRANA(IQUAD,JQUAD,M)%PHMX
        ARRY2=MATMUL(MTRX1,ARRY1)
        RADOTMP(JQUAD,:)=RADOTMP(JQUAD,:)+ARRY2*WTAT(IQUAD,JQUAD)
      ENDDO ! QUAD LOOP
    ENDDO ! QUAD LOOP
    RADOTMP=2.0d0*RADOTMP
    IF(WCFLG)RADOTMP=RADOTMP*(1.0D0-FWC)

    CALL RADINTPL2(2,NQDOD2,XJO,RADOTMP,NMUOUTSHFLO,MUOUTSHFLO,RADOUTTMP)

! UPDATE LSPO_OUT

  DO ITHETA=1,NMUOUTSHFLO
     IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
     DO N=NOLYR,0,-1
       IF(N==NOLYR)THEN
         ITAU=OLYR(N)%ITAUE
       ELSEIF(N==0)THEN
         ITAU=OLYR(1)%ITAUS
       ELSE
         ITAU=OLYR(N)%ITAUE+1
       ENDIF

       RTMP=DABS((TAU(ITAU)-OITAU)/MUOUTSHFLO(ITHETA))
       LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)= &
             LSPO_OUT(ITHETA,ITAU,M)%VRAD(:)+ &
                   EXP(-RTMP)*RADOUTTMP(ITHETA,:)
     ENDDO ! ITAU LOOP
  ENDDO ! ITHETA LOOP

  ENDDO ! M LOOP
  DEALLOCATE(RADOUTTMP)
ENDIF ! ROUGH OCEAN IF FOR SKY LIGHT transmittance

IF(DETA)THEN
ALLOCATE(LRADA(NMUOUTSHFLA,1:NDTAUA,NPHIOUT))
ALLOCATE(LSPATMP(NMUOUTSHFLA,0:MAXMORD), LRADATMP(NMUOUTSHFLA,NPHIOUT))
DO IDTAU=1,NDTAUA  
    LSPATMP(1:NMUOUTSHFLA,0:MAXMORD)= &
          LSPA_OUT(1:NMUOUTSHFLA,INDXDETA(IDTAU),0:MAXMORD)
    CALL RAD_FOURIER_INVERSE(NMUOUTSHFLA,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPATMP,LRADATMP)
    LRADA(1:NMUOUTSHFLA,IDTAU,1:NPHIOUT)= LRADATMP(1:NMUOUTSHFLA,1:NPHIOUT)
 
  IF(.NOT. WLR_FLAG) THEN
    DO ITHETA=NMUOUTSHFLA,1,-1
    DO IPHI=1,NPHIOUT

	  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)THEN
         IF(LRADA_SNG_SPSH(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)>1.0E-6)THEN

			 ARRY1=LRADA(ITHETA,IDTAU,IPHI)%VRAD(:) + &
					LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)

			 ARRY2=ARRY1/ARRY1(1)

			 RTMP=LRADA(ITHETA,IDTAU,IPHI)%VRAD(1) / &
				  LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)
			 RTMP1=(1.0D0+RTMP)*LRADA_SNG_SPSH(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)
			 ARRY3=ARRY2*RTMP1

			 LRADA(ITHETA,IDTAU,IPHI)%VRAD=ARRY3
         ELSE
			 LRADA(ITHETA,IDTAU,IPHI)%VRAD(:)= &
				 LRADA(ITHETA,IDTAU,IPHI)%VRAD(:) + &
				 LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)

         ENDIF
	  ELSE
		 LRADA(ITHETA,IDTAU,IPHI)%VRAD(:)= &
			  LRADA(ITHETA,IDTAU,IPHI)%VRAD(:) + &
			  LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)
      ENDIF

    ENDDO
    ENDDO
  ENDIF
ENDDO ! IDTAU LOOP
DEALLOCATE(LRADATMP,LSPATMP)
ENDIF


IF(DETO)THEN
ALLOCATE(LRADO(NMUOUTSHFLO,NDTAUO,NPHIOUT))
ALLOCATE(LSPOTMP(NMUOUTSHFLO,0:MAXMORD), LRADOTMP(NMUOUTSHFLO,NPHIOUT))
DO IDTAU=1,NDTAUO
  LSPOTMP(1:NMUOUTSHFLO,0:MAXMORD)= &
  LSPO_OUT(1:NMUOUTSHFLO,INDXDETO(IDTAU),0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NMUOUTSHFLO,MAXMORD,NPHIOUT,PHIOUT,&
                           LSPOTMP,LRADOTMP)
  DO ICOM1=1,4
  LRADO(1:NMUOUTSHFLO,IDTAU,1:NPHIOUT)%VRAD(ICOM1)= &
       LRADOTMP(1:NMUOUTSHFLO,1:NPHIOUT)%VRAD(ICOM1)+ &
       LRADO_SNG(1:NMUOUTSHFLO,INDXDETO_SNGSCAT(IDTAU),1:NPHIOUT)%VRAD(ICOM1)
  ENDDO

ENDDO ! IDTAU LOOP
DEALLOCATE(LRADOTMP,LSPOTMP)
ENDIF


!! OCEAN LAYERS MU<0 BOUNDARY CONDITION
!! ATMOSPHERE DIFFUSE LIGHT TRANSMITTANCE for rough ocean surface
!
!IF(DETO .AND. (.NOT. FLATO))THEN
!  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
!  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NUMPHI),&
!           LSPATMP1(NQDAD2,0:MAXMORD),LRADATMP1(NQDAD2,NUMPHI))
!
!  LSPATMP(1:NQDAD2,0:MAXMORD)= &
!        LSPA(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                            LSPATMP,LRADATMP)
!
!  LSPATMP1(1:NQDAD2,0:MAXMORD)= &
!        LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                           LSPATMP1,LRADATMP1)
!
!  COST1=MU_IN
!  SINT1=SQRT(1.0D0-COST1*COST1)
!  DO ITHETA=1,NMUOUTSHFLO
!     IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
!  DO IPHI=1,NPHIOUT
!     ARRY3=0.0D0
!  DO IQUAD=1,NQDAD2
!
!     COST2=XJA(IQUAD)
!     SINT2=SQRT(1.0D0-COST2*COST2)
!     DO IPHI_TMP=1,NUMPHI
!       ARRY1(:)=LRADATMP(IQUAD,IPHI_TMP)%VRAD(:)
!!       MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI_TMP(IPHI_TMP))
!!       IF(MUSCAT>MINMUFWDCN)THEN
!!          ARRY1(:)=ARRY1(:)- LRADATMP1(IQUAD,IPHI_TMP)%VRAD(:)
!!! SEARCH LRAD FROM FORWARD CONE
!!          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHI_TMP(IPHI_TMP),ARRY2)
!!          ARRY1=ARRY1+ARRY2
!!       ENDIF
!       CALL BTDM_AT_OCEAN(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLO(ITHETA),&
!                  PHIOUT(IPHI),NWRE,NWIM,MTRX1)
!       IF(SCL)THEN
!        ARRY3(1)=ARRY3(1)+MTRX1(1,1)*ARRY1(1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ELSE
!        ARRY3=ARRY3+MATMUL(MTRX1,ARRY1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!       ENDIF
!     ENDDO
!  ENDDO
!  IF(WCFLG)ARRY3=ARRY3*(1.0D0-FWC)
!  DO IDTAU=1,NDTAUO
!     RTMP=DABS((TAU(INDXDETO(IDTAU))-OITAU)/MUOUTSHFLO(ITHETA))
!     LRADO(ITHETA,IDTAU,IPHI)%VRAD=LRADO(ITHETA,IDTAU,IPHI)%VRAD+ &
!                  EXP(-RTMP)*ARRY3
!  ENDDO ! IDTAU LOOP
!
!  ENDDO
!  ENDDO
!
!  DEALLOCATE(LSPATMP,LRADATMP,LSPATMP1,LRADATMP1,MUTMP,RADOUTTMP)
!ENDIF ! (DETO .AND. (.NOT. FLATO))
!! ATMOSPHERE LAYERS MU>0 resultant from Sky light reflectance, ROUGH OCEAN
!IF((OCEAN .AND. (.NOT. FLATO) .AND. DETA .AND. (.NOT.WLR_FLAG)) &
!                         .or. pBRDF .or. fSnowBRDF .or. fRossLiBRDF)THEN
!  ALLOCATE(MUTMP(1),RADOUTTMP(1,4))
!  ALLOCATE(LSPATMP(NQDAD2,0:MAXMORD),LRADATMP(NQDAD2,NUMPHI),&
!           LSPATMP1(NQDAD2,0:MAXMORD),LRADATMP1(NQDAD2,NUMPHI))
!
!  LSPATMP(1:NQDAD2,0:MAXMORD)= &
!          LSPA(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                             LSPATMP,LRADATMP)
!
!  LSPATMP1(1:NQDAD2,0:MAXMORD)= &
!          LSPMNA_SNG(1:NQDAD2,ALYR(NALYR)%ITAUE,0:MAXMORD)
!  CALL RAD_FOURIER_INVERSE(NQDAD2,MAXMORD,NUMPHI,PHI_TMP,&
!                             LSPATMP1,LRADATMP1)
!
!  COST1=MU_IN
!  SINT1=SQRT(1.0D0-COST1*COST1)
!
!  DO ITHETA=1,NMUOUTSHFLA
!  IF(MUOUTSHFLA(ITHETA)<0.0D0)CYCLE
!  DO IPHI=1,NPHIOUT
!     ARRY3=0.0D0
!     DO IQUAD=1,NQDAD2
!
!        COST2=XJA(IQUAD)
!        SINT2=SQRT(1.0D0-COST2*COST2)
!
!     DO IPHI_TMP=1,NUMPHI
!       ARRY1(:)=LRADATMP(IQUAD,IPHI_TMP)%VRAD(:)
!!       MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI_TMP(IPHI_TMP))
!!       IF(MUSCAT>MINMUFWDCN)THEN
!!          ARRY1(:)=ARRY1(:)- LRADATMP1(IQUAD,IPHI_TMP)%VRAD(:)
!!      ! SEARCH LRAD FROM FORWARD CONE
!!          CALL RAD_FWDCN_SEARCH(MU_IN,COST2,PHI_TMP(IPHI_TMP),ARRY2)
!!          ARRY1=ARRY1+ARRY2
!!       ENDIF
!       IF(pBRDF)THEN
!         CALL pBRDM_LAND(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),&
!                       PHIOUT(IPHI),MTRX1)
!		ELSEIF(fSnowBRDF)THEN
!		  WAVELENGTH_MICRON=ALYR(1)%WAVELENGTH
!		  CALL pBRDM_Snow(WAVELENGTH_MICRON,COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),&
!						PHIOUT(IPHI),MTRX1,GLBDO)
!		ELSEIF(fRossLiBRDF)THEN
!         CALL pBRDM_RossLi(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),PHIOUT(IPHI),MTRX1)
!       ELSE
!         CALL BRDM_OCEAN(COST2,PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),&
!                       PHIOUT(IPHI),NWRE,NWIM,MTRX1)
!       ENDIF
!       IF(SCL)THEN
!          RTMP=MTRX1(1,1)
!          MTRX1=0.0D0
!          MTRX1(1,1)=RTMP
!       ENDIF
!
!       ARRY3=ARRY3+MATMUL(MTRX1,ARRY1)*WPHI_TMP(IPHI_TMP)*WTA(IQUAD)/PI
!
!     ENDDO
!     ENDDO
!     IF(WCFLG)ARRY3=ARRY3*(1.0D0-FWC)
!     IF(pBRDF .OR. fSnowBRDF .OR. fRossLiBRDF)THEN
!        RTMP3=TOTALTAU
!     ELSE
!        RTMP3=OITAU
!     ENDIF
!     DO IDTAU=1,NDTAUA
!         RTMP=DABS((TAU(INDXDETA(IDTAU))-RTMP3)/MUOUTSHFLA(ITHETA))
!         LRADA(ITHETA,IDTAU,IPHI)%VRAD=LRADA(ITHETA,IDTAU,IPHI)%VRAD+ &
!                                EXP(-RTMP)*ARRY3
!     ENDDO ! IDTAU LOOP
!
!  ENDDO
!  ENDDO
!
!  DEALLOCATE(LSPATMP,LRADATMP,LSPATMP1,LRADATMP1,MUTMP,RADOUTTMP)
!ENDIF ! ROUGH OCEAN IF FOR SKY LIGHT REFLECTANCE
!DEALLOCATE(PHI_TMP,WPHI_TMP)
DEALLOCATE(XJOD2,XJAD2,RADATMP,RADATMP1,RADOTMP,RADOTMP1)

IF(OCEAN .AND. (.NOT. FLATO))THEN 
   DEALLOCATE(LSPA_OUT)
   IF(.NOT. OCEAN_NO_TRAN)DEALLOCATE(LSPO_OUT)
   RETURN
ENDIF

FLAG1=OCEAN .AND. FLATO 
FLAG2=(.NOT. OCEAN) .AND. LAMB .AND. (FLAM<1.0D0)

IF(FLAG1 .OR. FLAG2)THEN
! ATMOSPHERE LAYERS MU>0 resultant from Sky light reflectance, FLAT LOWER BOUNDARY
  ALLOCATE(LSPATMP(NMUOUTSHFLA,0:MAXMORD), LRADATMP(NMUOUTSHFLA,NPHIOUT))
  LSPATMP(1:NMUOUTSHFLA,0:MAXMORD)= &
      LSPA_OUT(1:NMUOUTSHFLA,ALYR(NALYR)%ITAUE,0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NMUOUTSHFLA,MAXMORD,NPHIOUT,PHIOUT,&
                              LSPATMP,LRADATMP)
  DO ITHETA=1,NMUOUTSHFLA/2
    THETA1=ACOS(-MUOUTSHFLA(ITHETA))
    IF(FLAG1 .AND. (.NOT. WLR_FLAG) .AND. DETA)THEN
      CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)
    ELSEIF(FLAG2)THEN
      CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)
      FRES_MTRX=FRES_MTRX*(1.0D0-FLAM)
    ELSE
      FRES_MTRX=0.0D0
    ENDIF

    DO IPHI=1,NPHIOUT
	   IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)THEN
			ARRY1 =  LRADATMP(ITHETA,IPHI)%VRAD+ &
					 LRADA_SNG_SPSH(ITHETA,NALYR,IPHI)%VRAD
	   ELSE
			ARRY1 =  LRADATMP(ITHETA,IPHI)%VRAD+ &
					 LRADA_SNG(ITHETA,NALYR,IPHI)%VRAD
	   ENDIF
       ARRY2=MATMUL(FRES_MTRX,ARRY1)

       DO IDTAU=1,NDTAUA
         IF(FLAG1)THEN
            RTMP1=OITAU
         ELSE
            RTMP1=TOTALTAU
         ENDIF
         RTMP=DABS((TAU(INDXDETA(IDTAU))-RTMP1)/MUOUTSHFLA(ITHETA))
         LRADA(NMUOUTSHFLA-ITHETA+1,IDTAU,IPHI)%VRAD=&
             LRADA(NMUOUTSHFLA-ITHETA+1,IDTAU,IPHI)%VRAD+ &
                                 EXP(-RTMP)*ARRY2
       ENDDO ! IDTAU LOOP
    ENDDO
    ENDDO
ENDIF    !(FLAG1 .OR. FLAG2) 

! ocean LAYERS MU<0 resultant from Sky light transmittance, FLAT LOWER BOUNDARY
IF(FLAG1 .AND. DETO .AND. (.NOT. OCEAN_NO_TRAN))THEN
  DO ITHETA=1,NMUOUTSHFLO
    IF(MUOUTSHFLO(ITHETA)>0.0D0)CYCLE
    THETA2=ACOS(-MUOUTSHFLO(ITHETA))
    THETA1=SIN(THETA2)*NWRE
    IF(THETA1>1.0D0)CYCLE
    THETA1=ASIN(THETA1)
    
    CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_MTRX)

!    DO IMU=1,NMUOUTSHFLA/2
!       IF(ABS(COS(THETA1)+MUOUTSHFLA(IMU))<1.0E-4) EXIT
!    ENDDO
	INTARR=MINLOC(ABS(COS(THETA1)+MUOUTSHFLA))
	IMU=INTARR(1)

    IF(IMU>NMUOUTSHFLA/2)CYCLE
    IF(ABS(COS(THETA1)+MUOUTSHFLA(IMU))>1.0E-5) CYCLE

    DO IPHI=1,NPHIOUT
	  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)THEN
			ARRY1 =  LRADATMP(IMU,IPHI)%VRAD + &
					 LRADA_SNG_SPSH(IMU,NALYR,IPHI)%VRAD
	  ELSE
			ARRY1 =  LRADATMP(IMU,IPHI)%VRAD + &
					 LRADA_SNG(IMU,NALYR,IPHI)%VRAD
	  ENDIF
      ARRY2=MATMUL(FRES_MTRX,ARRY1)
      ARRY2=ARRY2*NSQW
     
      DO IDTAU=1,NDTAUO
         RTMP=DABS((TAU(INDXDETO(IDTAU))-OITAU)/MUOUTSHFLO(ITHETA))
         LRADO(ITHETA,IDTAU,IPHI)%VRAD=LRADO(ITHETA,IDTAU,IPHI)%VRAD+ &
                   EXP(-RTMP)*ARRY2
      ENDDO ! IDTAU LOOP
    ENDDO   
  ENDDO
ENDIF

IF(FLAG1 .OR. FLAG2) DEALLOCATE(LRADATMP,LSPATMP)

! OCEAN DIFFUSE LIGHT REFLECTANCE FOR FLAT OCEAN
IF(FLAG1 .AND. (.NOT. OCEAN_NO_TRAN))THEN
  ALLOCATE(LSPOTMP(NMUOUTSHFLO,0:MAXMORD), LRADOTMP(NMUOUTSHFLO,NPHIOUT))
  LSPOTMP(1:NMUOUTSHFLO,0:MAXMORD)= &
        LSPO_OUT(1:NMUOUTSHFLO,OLYR(1)%ITAUS,0:MAXMORD)
  CALL RAD_FOURIER_INVERSE(NMUOUTSHFLO,MAXMORD,NPHIOUT,PHIOUT,&
                           LSPOTMP,LRADOTMP)
  IF(DETO) THEN
  DO ITHETA=1,NMUOUTSHFLO
    IF(MUOUTSHFLO(ITHETA)<0.0D0)CYCLE
    THETA1=ACOS(MUOUTSHFLO(ITHETA))
    CALL FRSNL_R2(NRELRE,NRELIM,THETA1,FRES_MTRX)

    DO IPHI=1,NPHIOUT
       ARRY1 =  LRADOTMP(ITHETA,IPHI)%VRAD+ &
                LRADO_SNG(ITHETA,0,IPHI)%VRAD
       ARRY2=MATMUL(FRES_MTRX,ARRY1)
       DO IDTAU=1,NDTAUO
         RTMP=DABS((TAU(INDXDETO(IDTAU))-OITAU)/MUOUTSHFLO(ITHETA))
         LRADO(NMUOUTSHFLO-ITHETA+1,IDTAU,IPHI)%VRAD=&
             LRADO(NMUOUTSHFLO-ITHETA+1,IDTAU,IPHI)%VRAD+ &
                                 EXP(-RTMP)*ARRY2
       ENDDO ! IDTAU LOOP
    ENDDO
  ENDDO
  ENDIF
  
! OCEAN DIFFUSE LIGHT TRANSMITTANCE FOR FLAT OCEAN
  IF(DETA) THEN
  DO ITHETA=NMUOUTSHFLA/2+1,NMUOUTSHFLA
    THETA2=ACOS(MUOUTSHFLA(ITHETA))
    THETA1=ASIN(SIN(THETA2)/NWRE)

    CALL FRSNL_T2(NRELRE,NRELIM,THETA1,FRES_MTRX)

!    DO IMU=NMUOUTSHFLO/2+1,NMUOUTSHFLO
!      IF(ABS(COS(THETA1)-MUOUTSHFLO(IMU))<1.0E-4) EXIT
!    ENDDO

	INTARR=MINLOC(ABS(COS(THETA1)-MUOUTSHFLO))
	IMU=INTARR(1)
	IF(ABS(COS(THETA1)-MUOUTSHFLO(IMU))>1.0E-5) stop 'check imu search 6'

DO IPHI=1,NPHIOUT
       ARRY1 =  LRADOTMP(IMU,IPHI)%VRAD+ &
                LRADO_SNG(IMU,0,IPHI)%VRAD
       ARRY2=MATMUL(FRES_MTRX,ARRY1)
       ARRY2=ARRY2*NSQA
       DO IDTAU=1,NDTAUA
         RTMP=DABS((TAU(INDXDETA(IDTAU))-OITAU)/MUOUTSHFLA(ITHETA))
         LRADA(ITHETA,IDTAU,IPHI)%VRAD=&
             LRADA(ITHETA,IDTAU,IPHI)%VRAD+EXP(-RTMP)*ARRY2
       ENDDO ! IDTAU LOOP
    ENDDO
  ENDDO
  ENDIF
DEALLOCATE(LRADOTMP,LSPOTMP)
ENDIF         

DEALLOCATE(LSPA_OUT)
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))DEALLOCATE(LSPO_OUT)

END SUBROUTINE RADOUT_MAPPING


SUBROUTINE SINGLE_SCATTERING(M,MU_IN)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE SnowBRDF
USE RossLiBRDF

implicit none
INTEGER,INTENT(IN) :: M
REAL*8,INTENT(IN) ::MU_IN

DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: SURF_EMIS_ARR,SURF_EMIS_QARR
DOUBLE PRECISION :: WAVELENGTH_MICRON
INTEGER :: IMIE,IQUAD,JQUAD,I,N,ITAU,ICOM1
REAL*8 :: RTMP, RTMP1,RTMP2,RTMP3,THETA1,THETA_IN
REAL*8,DIMENSION(4)   :: Thermal_Arry,ARRY1,ARRY2,ARRY3,ARRY4
REAL*8,DIMENSION(4,4) :: FRES_MTRX,MTRX1,MTRX2
LOGICAL :: FLAG1,FLAG2,emiss_lut_outside=.false.
ALLOCATE(SURF_EMIS_ARR(NQUADA))
WAVELENGTH_MICRON=ALYR(1)%WAVELENGTH
IF(OCEAN) THEN
   CALL cal_seaemis2(WAVELENGTH_MICRON,WNDSPD,NQUADA,XJA,SURF_EMIS_ARR,emiss_lut_outside)
   if(emiss_lut_outside) then
!      write(*,*) 'wavelength outside of the ocean emissivity LUT, use Fresnel instead'
      ALLOCATE(SURF_EMIS_QARR(NQUADA))
      call cal_seaemis_flat(NWRE,NWIM,NQUADA,XJA,SURF_EMIS_ARR,SURF_EMIS_QARR)
   endif
ELSE
   SURF_EMIS_ARR=SURFACE_EMISSIVITY
ENDIF

THETA_IN=ACOS(MU_IN)
Thermal_Arry=0.0D0
DO IQUAD=1,NQUADA
DO N=1,ALYR(NALYR)%ITAUE
   LSPMNA(IQUAD,N,M)%VRAD(:)=0.0D0
ENDDO
ENDDO

FLAG1=OCEAN .AND. FLATO
FLAG2=(.NOT. OCEAN).AND. LAMB .AND. (FLAM<1.0D0)

IF(FLAG1)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)
ELSE IF(FLAG2)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)
  FRES_MTRX=FRES_MTRX*(1.0D0-FLAM)
ENDIF

! SINGLE SCATTERED LIGHT CAUSED BY DIRECT SUN LIGHT
DO IQUAD=1,NQDAD2
DO I=1,NALYR
DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  IF(ITAU==1 .AND. M==0) LSPMNA(IQUAD,1,0)%VRAD(1)=CMB_Rad
  IF(ITAU==1)   CYCLE

  IF(M==0) THEN
     Thermal_Arry(1)=(1.0D0-ALYR(I)%LBDOM)*BT_Planck(I)
  ELSE
     Thermal_Arry(1)=0.0D0
  ENDIF

  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT
  MTRX1=ALYR(I)%LBDOM*SPMA(IQUAD,IMIE,M)%PHMX
  ARRY2=MATMUL(MTRX1,ARRY1)
  IF(SCL) ARRY2(2:4)=0.0D0
  RTMP1=TAU(ITAU)-TAU(ITAU-1)

  IF(ABS(XJA(IQUAD)-MU_IN)<TINY2)THEN

    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:) + &
       2.0D0*EXP(-ABS(TAU(ITAU)*SECANT_THETAL(ITAU)))           &
            *DTAUMUADW(ITAU,IQUAD)* ARRY2(:) +               &
			Thermal_Arry*(1.0d0 - EXP(-ABS(RTMP1/XJA(IQUAD))))

  ELSE

    RTMP=-MU_IN/(XJA(IQUAD)-MU_IN)

    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:) + &
        RTMP * EXP(-TAU(ITAU)*SECANT_THETAL(ITAU))*(1.0d0 -    &
          EXP(-RTMP1*(1.0D0/MU_IN-1.0D0/XJA(IQUAD)))) * ARRY2(:) +  &
		Thermal_Arry(:)*(1.0d0 - EXP(-ABS(RTMP1/XJA(IQUAD))))

!    LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
!      EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:) + &
!                    RTMP * (EXP(-TAU(ITAU)*SECANT_THETAL(ITAU)) -    &
!         EXP(RTMP1/XJA(IQUAD))*EXP(-TAU(ITAU-1)*SECANT_THETAL(ITAU-1)))  * ARRY2(:)
  ENDIF
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0
ENDDO   ! LOOP IQUAD

! ATMOSPHERE MU>0

DO IQUAD=NQDAD2+1,NQUADA
DO I=NALYR,1,-1
DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
  IF(ITAU==ALYR(NALYR)%ITAUE .AND. M==0) THEN
      LSPMNA(IQUAD,ITAU,M)%VRAD(1)=SURF_EMIS_ARR(IQUAD)*SURFACE_RAD
	  if(emiss_lut_outside) &
          LSPMNA(IQUAD,ITAU,M)%VRAD(2)=SURF_EMIS_QARR(IQUAD)*SURFACE_RAD
  ENDIF
  IF(ITAU==ALYR(NALYR)%ITAUE)CYCLE

  IF(M==0) THEN
	  Thermal_Arry(1)=(1.0D0-ALYR(I)%LBDOM)*BT_Planck(I)
  ELSE
	  Thermal_Arry(1)=0.0D0
  ENDIF

  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT
  MTRX1=ALYR(I)%LBDOM*SPMA(IQUAD,IMIE,M)%PHMX
  ARRY2=MATMUL(MTRX1,ARRY1)
  IF(SCL) ARRY2(2:4)=0.0D0

  RTMP=ABS(MU_IN/(XJA(IQUAD)-MU_IN))
  RTMP1=TAU(ITAU+1)-TAU(ITAU)
  LSPMNA(IQUAD,ITAU,M)%VRAD(:)=                              &
    EXPTAUAUP(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU+1,M)%VRAD(:)   + &
     RTMP* EXP(-ABS(TAU(ITAU)*SECANT_THETAL(ITAU))) *            &
     (1.0D0 - EXP(-RTMP1/RTMP/ABS(XJA(IQUAD))))  * ARRY2(:) + &
     Thermal_Arry(:)*(1.0d0 - EXP(-ABS(RTMP1/XJA(IQUAD))))

ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU>0
ENDDO   ! LOOP IQUAD

LSPMNA_SNG(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)= &
          LSPMNA(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)
DO ICOM1=1,4
  LSPMNA(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)%VRAD(ICOM1)=0.0D0
ENDDO

! DIRECT OVER
! testing
!write(*,*)'lspmna_sngl tst'
!do Icom1=1,NDTAUA
!DO IQUAD=1,NQUADA
! write(*,*)xja(iquad),m,LSPMNA_SNG(iquad,INDXDETA(Icom1),M)%vrad(1:4)
!enddo
!enddo

!testing
!write(*,*)'pma list'
!DO IQUAD=1,NQUADA
!DO JQUAD=1,NQUADA
!write(*,*)xja(iquad),xja(jquad),m
!write(*,*)PMA(IQUAD,JQUAD,1,M)%PHMX(1,1),PMA(IQUAD,JQUAD,1,M)%PHMX(1,2),&
!          PMA(IQUAD,JQUAD,1,M)%PHMX(1,3),PMA(IQUAD,JQUAD,1,M)%PHMX(1,4)
!write(*,*)PMA(IQUAD,JQUAD,1,M)%PHMX(2,1),PMA(IQUAD,JQUAD,1,M)%PHMX(2,2),&
!          PMA(IQUAD,JQUAD,1,M)%PHMX(2,3),PMA(IQUAD,JQUAD,1,M)%PHMX(2,4)
!write(*,*)PMA(IQUAD,JQUAD,1,M)%PHMX(3,1),PMA(IQUAD,JQUAD,1,M)%PHMX(3,2),&
!          PMA(IQUAD,JQUAD,1,M)%PHMX(3,3),PMA(IQUAD,JQUAD,1,M)%PHMX(3,4)
!write(*,*)PMA(IQUAD,JQUAD,1,M)%PHMX(4,1),PMA(IQUAD,JQUAD,1,M)%PHMX(4,2),&
!          PMA(IQUAD,JQUAD,1,M)%PHMX(4,3),PMA(IQUAD,JQUAD,1,M)%PHMX(4,4)
!enddo
!enddo

DO IQUAD=1,NQDAD2
DO I=1,NALYR
DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  IF(ITAU==1)CYCLE
  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT
  LSPMNA(IQUAD,ITAU,M)%VRAD(:)=    &
      EXPTAUADW(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU-1,M)%VRAD(:)
      
IF(FLAG1 .OR. FLAG2)THEN
   MTRX2=ALYR(I)%LBDOM*SRPMA(IQUAD,IMIE,M)%PHMX
   ARRY3=MATMUL(FRES_MTRX,ARRY1)
   IF(SCL) ARRY3(2:4)=0.0D0
   ARRY4=MATMUL(MTRX2,ARRY3)

   RTMP=ABS(MU_IN/(XJA(IQUAD)+MU_IN))
   RTMP1=TAU(ITAU)-TAU(ITAU-1)
   
   IF(FLAG1)RTMP2=OITAU
   IF(FLAG2)RTMP2=TOTALTAU
   
   LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) +      &
              ABS(RTMP)* EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR))*      &
              EXP(-ABS((RTMP2-TAU(ITAU))/MU_IN))*                    &
       ABS(1.0D0 - EXP(-RTMP1/RTMP/ABS(XJA(IQUAD)))) * ARRY4(:)

ENDIF

IF((OCEAN .AND. (.NOT.FLATO)) .OR. pBRDF .or. fSnowBRDF .OR. fRossLiBRDF)THEN
  IF(pBRDF .or. fSnowBRDF .OR. fRossLiBRDF) THEN
    RTMP3=TOTALTAU
  ELSE
    RTMP3=OITAU
  ENDIF
  ARRY1=ESUN*EXP(-RTMP3*SECANT_THETAL_PRSV(NALYR))/PI
  DO JQUAD=NQDAD2+1,NQUADA
    MTRX1=SFRES_REFLA(JQUAD,M)%PHMX
    ARRY2=MATMUL(MTRX1,ARRY1)
!    first order white cap correction
    IF(WCFLG) ARRY2=ARRY2*(1.0D0-FWC)
    IF(SCL) ARRY2(2:4)=0.0D0    
    IMIE=ALYR(I)%IPT
    MTRX1=0.5d0*ALYR(I)%LBDOM*WTA(JQUAD)*&
           PMA(IQUAD,JQUAD,IMIE,M)%PHMX
    ARRY3=MATMUL(MTRX1,ARRY2)

    RTMP=XJA(JQUAD)/(XJA(JQUAD)-XJA(IQUAD))
    IF(RTMP<0.0D0)STOP 'CHECK SINGLE SCATTERING POINT 2'
    RTMP1=EXP(-ABS((TAU(ITAU)-RTMP3)/XJA(JQUAD)))
    RTMP2=TAU(ITAU)-TAU(ITAU-1)
    LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) + &
          ARRY3*RTMP*RTMP1*(1.0D0-EXP(-ABS(RTMP2/RTMP/XJA(IQUAD))))

  ENDDO
ENDIF !OCEAN IF

ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0
ENDDO   ! LOOP IQUAD

! ATMOSPHERE MU>0

DO IQUAD=NQDAD2+1,NQUADA
DO I=NALYR,1,-1
DO ITAU=ALYR(I)%ITAUE,ALYR(I)%ITAUS,-1
  IF(ITAU==ALYR(NALYR)%ITAUE)CYCLE

  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT
  MTRX1=ALYR(I)%LBDOM*SPMA(IQUAD,IMIE,M)%PHMX
  ARRY2=MATMUL(MTRX1,ARRY1)
  IF(SCL) ARRY2(2:4)=0.0D0

  LSPMNA(IQUAD,ITAU,M)%VRAD(:)=                              &
    EXPTAUAUP(ITAU,IQUAD)*LSPMNA(IQUAD,ITAU+1,M)%VRAD(:)
    
IF(FLAG1 .OR. FLAG2)THEN
   MTRX2=ALYR(I)%LBDOM*SRPMA(IQUAD,IMIE,M)%PHMX
   ARRY3=MATMUL(FRES_MTRX,ARRY1)
   IF(SCL) ARRY3(2:4)=0.0D0
   ARRY4=MATMUL(MTRX2,ARRY3)

   IF(FLAG1)RTMP2=OITAU
   IF(FLAG2)RTMP2=TOTALTAU
   RTMP1=TAU(ITAU+1)-TAU(ITAU)

   IF(ABS(XJA(IQUAD)+MU_IN)<TINY2)THEN
     LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) +   &
       EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR)) *                      &
       EXP(-ABS((RTMP2-TAU(ITAU))/MU_IN))    *                      &
       RTMP1*ARRY4(:)/XJA(IQUAD)
   ELSE
     RTMP=-MU_IN/(XJA(IQUAD)+MU_IN)
     LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) +   &
       RTMP* EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR))* &
			(EXP(-RTMP1/XJA(IQUAD))*                &
             EXP(-ABS((RTMP2-TAU(ITAU+1))/MU_IN))-  &
             EXP(-ABS((RTMP2-TAU(ITAU))/MU_IN)))*ARRY4(:)
   ENDIF
ENDIF

IF((OCEAN .AND. (.NOT.FLATO)) .or. pBRDF .or. fSnowBRDF .OR. fRossLiBRDF)THEN
  IF(pBRDF .or. fSnowBRDF .OR. fRossLiBRDF) THEN
    RTMP3=TOTALTAU
  ELSE
    RTMP3=OITAU
  ENDIF
  ARRY1=ESUN*EXP(-RTMP3*SECANT_THETAL_PRSV(NALYR))/PI
  DO JQUAD=NQDAD2+1,NQUADA
    MTRX1=SFRES_REFLA(JQUAD,M)%PHMX
    ARRY2=MATMUL(MTRX1,ARRY1)
!    first order white cap correction
    IF(WCFLG) ARRY2=ARRY2*(1.0D0-FWC)
    IF(SCL) ARRY2(2:4)=0.0D0    
    IMIE=ALYR(I)%IPT
    MTRX1=0.5d0*ALYR(I)%LBDOM*WTA(JQUAD)*&
           PMA(IQUAD,JQUAD,IMIE,M)%PHMX
    ARRY3=MATMUL(MTRX1,ARRY2)

    RTMP1=EXP(-ABS((TAU(ITAU)-RTMP3)/XJA(JQUAD)))
    RTMP2=TAU(ITAU+1)-TAU(ITAU)

    IF(IQUAD==JQUAD)THEN
      LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) + &
          ARRY3*RTMP1*RTMP2/XJA(IQUAD)
    ELSE
      RTMP=XJA(JQUAD)/(XJA(IQUAD)-XJA(JQUAD))
      LSPMNA(IQUAD,ITAU,M)%VRAD(:)= LSPMNA(IQUAD,ITAU,M)%VRAD(:) + &
        ARRY3*RTMP*(EXP((TAU(ITAU+1)-RTMP3)/XJA(JQUAD))*EXP(-RTMP2/XJA(IQUAD))-RTMP1)
    ENDIF
  ENDDO
ENDIF !OCEAN IF

ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU>0
ENDDO   ! LOOP IQUAD

LSPA_SNG_RO(1:NQUADA,1:ALYR(NALYR)%ITAUE,M) = &
           LSPMNA(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)

DO ICOM1=1,4
LSPMNA(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)%VRAD(ICOM1) =        &
       LSPMNA(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)%VRAD(ICOM1) + &
       LSPMNA_SNG(1:NQUADA,1:ALYR(NALYR)%ITAUE,M)%VRAD(ICOM1)
ENDDO

 ! LSPMNA NOW ACTUALLY INCLUDE DOUBLE SCATTERING.
 ! OF SUN DIRECT LIGHT, SCATTERING CAUSED BY SUN GLINT.

!_______OCEAN_______
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN

  DO IQUAD=1,NQUADO
  DO N=OLYR(1)%ITAUS,NTTAU
     LSPMNO(IQUAD,N,M)%VRAD(:)=0.0D0
  ENDDO
  ENDDO

IF(FLAG1)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_MTRX)
ENDIF

ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))/PI
DO IQUAD=1,NQDOD2
DO I=1,NOLYR
DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
  IF(ITAU==OLYR(1)%ITAUS)CYCLE
  LSPMNO(IQUAD,ITAU,M)%VRAD(:)=                          &
     EXPTAUODW(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU-1,M)%VRAD(:)
       
  DO JQUAD=1, NQUADSO
    IF(FLAG1)THEN
      IF(NQUADSO>1)STOP 'SINGLE SCATTERING CHECK POINT 5'
      MTRX1=FRES_MTRX*abs(MU_IN/XJSO(JQUAD))/4.0d0
    ELSE
      MTRX1=SFRES_TRANA(JQUAD,M)%PHMX
    ENDIF
    ARRY2=MATMUL(MTRX1,ARRY1)

    IF(WCFLG)ARRY2=ARRY2*(1.0D0-FWC)
    IMIE=OLYR(I)%IPT
    MTRX1=0.5d0*OLYR(I)%LBDOM*WTSO(JQUAD)*&
	          SPMO(JQUAD,IQUAD,IMIE,M)%PHMX
    IF(FLAG1)MTRX1=2.0D0*MTRX1
    ARRY3=MATMUL(MTRX1,ARRY2)

    RTMP1=EXP(-ABS((TAU(ITAU)-OITAU)/XJSO(JQUAD)))
    RTMP2=TAU(ITAU)-TAU(ITAU-1)
    IF(ABS(XJSO(JQUAD)-XJO(IQUAD))<TINY2)THEN
     LSPMNO(IQUAD,ITAU,M)%VRAD(:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:) + &
       ARRY3*RTMP1*RTMP2/ABS(XJO(IQUAD))
    ELSE
     RTMP=-XJSO(JQUAD)/(XJO(IQUAD)-XJSO(JQUAD))
     LSPMNO(IQUAD,ITAU,M)%VRAD(:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:) + &
       ARRY3*RTMP*(RTMP1-EXP((TAU(ITAU-1)-OITAU)/XJSO(JQUAD))*EXP(RTMP2/XJO(IQUAD)))
! IF(RTMP*(RTMP1-EXP((TAU(ITAU-1)-OITAU)/XJSO(JQUAD))*EXP(RTMP2/XJO(IQUAD)))<0.0D0)
!       STOP 'CHK 6'
    ENDIF
  ENDDO
ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP OCEAN LAYERS FOR MU<0
ENDDO   ! LOOP IQUAD

! UPDATE L^M_N FOR MU>0.0D0

! OCEAN MU>0
ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))/PI
DO IQUAD=NQDOD2+1,NQUADO
DO I=NOLYR,1,-1
DO ITAU=OLYR(I)%ITAUE,OLYR(I)%ITAUS,-1
  IF(ITAU==NTTAU)CYCLE
  LSPMNO(IQUAD,ITAU,M)%VRAD(:)=                               &
        EXPTAUOUP(ITAU,IQUAD)*LSPMNO(IQUAD,ITAU+1,M)%VRAD(:)
  DO JQUAD=1, NQUADSO
    IF(FLAG1)THEN
      MTRX1=FRES_MTRX*abs(MU_IN/XJSO(JQUAD))/4.0d0
    ELSE
      MTRX1=SFRES_TRANA(JQUAD,M)%PHMX
    ENDIF
    ARRY2=MATMUL(MTRX1,ARRY1)

    IF(WCFLG)ARRY2=ARRY2*(1.0D0-FWC)
    IMIE=OLYR(I)%IPT
    MTRX1=0.5d0*OLYR(I)%LBDOM*WTSO(JQUAD)*&
	          SPMO(JQUAD,IQUAD,IMIE,M)%PHMX
    IF(FLAG1)MTRX1=2.0D0*MTRX1
    ARRY3=MATMUL(MTRX1,ARRY2)
   
    RTMP=-XJSO(JQUAD)/(XJO(IQUAD)-XJSO(JQUAD))
    RTMP1=EXP(-ABS((TAU(ITAU)-OITAU)/XJSO(JQUAD)))
    IF(RTMP1<1.0D-307)RTMP1=0.0D0
    RTMP2=TAU(ITAU+1)-TAU(ITAU)

      LSPMNO(IQUAD,ITAU,M)%VRAD(:)=LSPMNO(IQUAD,ITAU,M)%VRAD(:) + &
        ARRY3*RTMP*RTMP1*(1.0D0-EXP(-RTMP2/RTMP/XJO(IQUAD)))
  ENDDO

ENDDO  ! LOOP SUBLAYERS
ENDDO   !LOOP OCEAN LAYERS FOR MU>0
ENDDO   ! LOOP IQUAD

LSPMNO_SNG(1:NQUADO,OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,M)= &
         LSPMNO(1:NQUADO,OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE,M)

IF((RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG) .AND. M<=2)THEN
  DO IQUAD=1,NQUADO
  DO ITAU=OLYR(1)%ITAUS,NTTAU
    LSPMNO(IQUAD,ITAU,M)%VRAD(1:4)=LSPMNO(IQUAD,ITAU,M)%VRAD(1:4)+&
       LSPMNO_INELASTIC_SNG(IQUAD,ITAU,M)%VRAD(1:4)
  ENDDO
  ENDDO
ENDIF

ENDIF  !OCEAN IF
DEALLOCATE(SURF_EMIS_ARR)
if(OCEAN .AND. emiss_lut_outside)DEALLOCATE(SURF_EMIS_QARR)
END SUBROUTINE SINGLE_SCATTERING

SUBROUTINE ATMOS_OCEAN_CONFIG
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none

INTEGER :: I,ITAU, N,IALYR,IOLYR
REAL*8 :: RTMP

TAU=0.0D0
TAU_PRSV=0.0D0
LBDO_A_PRSV=0.0D0
LBDO_O_PRSV=0.0D0
DO I=1,NALYR
   ALYR(I)%DTAU=DABS(ALYR(I)%TAUT-ALYR(I)%TAUB)/DFLOAT(ALYR(I)%NTAU)
   LBDO_A_PRSV(I)=ALYR(I)%LBDOM
   DO N=ALYR(I)%ITAUS,ALYR(I)%ITAUE
    ITAU=N
    IF(ITAU>1) THEN
	   IF(N==ALYR(I)%ITAUS)THEN
	      TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+ALYR(I-1)%DTAU
	   ELSE
          TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+ALYR(I)%DTAU
	   ENDIF
	ENDIF
   ENDDO
ENDDO
TOTALTAU_PRSV=TOTALTAU
IF(OCEAN)OITAU_PRSV=OITAU
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  DO I=1,NOLYR
    OLYR(I)%DTAU=DABS(OLYR(I)%TAUT-OLYR(I)%TAUB)/DFLOAT(OLYR(I)%NTAU)
    LBDO_O_PRSV(I)=OLYR(I)%LBDOM
    DO N=OLYR(I)%ITAUS,OLYR(I)%ITAUE
      ITAU=N
      IF(ITAU==OLYR(1)%ITAUS) THEN
	    TAU_PRSV(ITAU)=OITAU+TINY2
	  ELSE IF(ITAU==OLYR(I)%ITAUS) THEN
	    TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+OLYR(I-1)%DTAU
      ELSE
        TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+OLYR(I)%DTAU
	  ENDIF
    ENDDO
  ENDDO  !NOLYR LOOP
ENDIF


DO I=1,NALYR
   IF(TRUC_FLAG .AND. FTRUNC(ALYR(I)%IPT)>0.0D0) THEN  
    !RESCALE OPTICAL DEPTH AND SINGLE SCATTERING ALBEDO
	!FOR DELTA FIT TRUNCATION

	RTMP=ALYR(I)%TAUT-ALYR(I)%TAUB
	ALYR(I)%DTAU=RTMP*(1.0D0-ALYR(I)%LBDOM*FTRUNC(ALYR(I)%IPT))
    ALYR(I)%LBDOM=ALYR(I)%LBDOM*(1.0D0-FTRUNC(ALYR(I)%IPT))  &
	              /(1.0D0-ALYR(I)%LBDOM*FTRUNC(ALYR(I)%IPT))
    ALYR(I)%TAUT=ALYR(I)%TAUB + ALYR(I)%DTAU
	RTMP=RTMP - ALYR(I)%DTAU
	DO IALYR=I+1,NALYR
       ALYR(IALYR)%TAUB=ALYR(IALYR)%TAUB-RTMP
       ALYR(IALYR)%TAUT=ALYR(IALYR)%TAUT-RTMP
	ENDDO
    IF(OCEAN .AND. (.NOT.OCEAN_NO_TRAN))THEN
      DO IOLYR=1,NOLYR
         OLYR(IOLYR)%TAUB=OLYR(IOLYR)%TAUB-RTMP
         OLYR(IOLYR)%TAUT=OLYR(IOLYR)%TAUT-RTMP
      ENDDO
    ENDIF
    IF(OCEAN)OITAU=OITAU-RTMP
    TOTALTAU=TOTALTAU-RTMP
   ENDIF

   ALYR(I)%DTAU=DABS(ALYR(I)%TAUT-ALYR(I)%TAUB)/DFLOAT(ALYR(I)%NTAU)

   DO N=ALYR(I)%ITAUS,ALYR(I)%ITAUE
    ITAU=N
    IF(ITAU>1) THEN
	   IF(N==ALYR(I)%ITAUS)THEN
	      TAU(ITAU)=TAU(ITAU-1)+ALYR(I-1)%DTAU
	   ELSE
          TAU(ITAU)=TAU(ITAU-1)+ALYR(I)%DTAU
	   ENDIF
	ENDIF
   ENDDO
ENDDO
IF(OCEAN .AND. ABS(OITAU-TAU(ITAU))>4.0d0*TINY2)THEN
  WRITE(*,*)'OITAU, Atmospherie TAU=',OITAU,TAU(ITAU)
  STOP 'ERROR: CHECK ATMOSPHERE CONFIGRATION'
ENDIF
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  DO I=1,NOLYR
    IF(TRUC_FLAG .AND. FTRUNC(OLYR(I)%IPT)>0.0D0) THEN  
     !RESCALE OPTICAL DEPTH AND SINGLE SCATTERING ALBEDO
	 !FOR DELTA FIT TRUNCATION
	  RTMP=OLYR(I)%TAUT-OLYR(I)%TAUB
	  OLYR(I)%DTAU=RTMP*(1.0D0-OLYR(I)%LBDOM*FTRUNC(OLYR(I)%IPT))
      OLYR(I)%LBDOM=OLYR(I)%LBDOM*(1.0D0-FTRUNC(OLYR(I)%IPT))  &
	              /(1.0D0-OLYR(I)%LBDOM*FTRUNC(OLYR(I)%IPT))
      OLYR(I)%TAUT=OLYR(I)%TAUB + OLYR(I)%DTAU
      RTMP=RTMP - OLYR(I)%DTAU
	  DO IOLYR=I+1,NOLYR
         OLYR(IOLYR)%TAUB=OLYR(IOLYR)%TAUB-RTMP
         OLYR(IOLYR)%TAUT=OLYR(IOLYR)%TAUT-RTMP
      ENDDO
	  TOTALTAU=TOTALTAU-RTMP
    ENDIF
    OLYR(I)%DTAU=DABS(OLYR(I)%TAUT-OLYR(I)%TAUB)/DFLOAT(OLYR(I)%NTAU)
    DO N=OLYR(I)%ITAUS,OLYR(I)%ITAUE
      ITAU=N
      IF(ITAU==OLYR(1)%ITAUS) THEN
	    TAU(ITAU)=OITAU+TINY2
	  ELSE IF(ITAU==OLYR(I)%ITAUS) THEN
	    TAU(ITAU)=TAU(ITAU-1)+OLYR(I-1)%DTAU
      ELSE
        TAU(ITAU)=TAU(ITAU-1)+OLYR(I)%DTAU
	  ENDIF
    ENDDO
  ENDDO  !NOLYR LOOP
ENDIF

END SUBROUTINE ATMOS_OCEAN_CONFIG

SUBROUTINE SNGL_SCAT_CRRCT_ATMOS(MU_IN,NMUOUTSHFLA,&
         NPHIOUT,PHIOUT,MUOUTSHFLA,MPLIN)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE SnowBRDF
USE RossLiBRDF

implicit none
REAL*8,INTENT(IN) :: MU_IN

INTEGER(I4B),INTENT(IN) :: NMUOUTSHFLA,NPHIOUT,MPLIN
REAL*8,DIMENSION(NMUOUTSHFLA),INTENT(IN) :: MUOUTSHFLA
REAL*8,DIMENSION(NPHIOUT),INTENT(IN) :: PHIOUT

!TYPE(ARRAY4),DIMENSION(:,:,:,:),ALLOCATABLE :: SUNGLTA

INTEGER :: IMIE,IQUAD,I,IPHI,ITHETA,IDTAU,ILAYER,ILAYERSUB,JLAYER
REAL*8 :: RTMP, RTMP1,RTMP2,THETA1,COST1,COST2,PHI1,PHI2,&
          SINT1,SINT2,MUSCAT,RADCORR,THETA_IN
REAL*8,DIMENSION(4)   :: Thermal_Arry,ARRY1,ARRY2,ARRY3,ARRY4
REAL*8,DIMENSION(4,4) :: FRES_MTRX,MTRX1,MTRX2
LOGICAL :: FLAG1,FLAG2,EPSS_FARSIDE
!LOGICAL ::DIFF_FLG
DOUBLE PRECISION,DIMENSION(:),ALLOCATABLE :: SURF_EMIS_ARR,SURF_EMIS_QARR

TYPE(ARRAY4),DIMENSION(:),ALLOCATABLE :: LRADATMP1

TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADATMP,LSPATMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADATMP,RADATMP1

INTEGER :: NHEIGHTINT !SUB INTERVALS TO PERFORM HEIGHT INTEGRAL FOR
                      ! SINGLE SCATTERING SPHERICAL SHELL SOLUTION
REAL*8 :: SECANT_THETAL_VIEWB,SECANT_THETAL_VIEWT,SECANT_THETAL_LAYER,&
          SECANT_THETAL_LOCAL,SLANT_TAU_LOCAL
REAL*8 :: TAUTEMP,TAUTEMP1,TAU_INTERVAL,HEIGHT_TEMP,HEIGHT_INTERVAL,SINTV,&
          SOURCETEMP,WEIGHT,DIST0,LDIS
DOUBLE PRECISION :: WAVELENGTH_MICRON
logical :: emiss_lut_outside=.false.
!INTEGER :: NUMPHI,IPHI_TMP
!REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP
!REAL*8 :: XIFUNC
Thermal_Arry=0.0D0
ALLOCATE(SURF_EMIS_ARR(NMUOUTSHFLA))
WAVELENGTH_MICRON=ALYR(1)%WAVELENGTH
IF(OCEAN) THEN
   CALL cal_seaemis2(WAVELENGTH_MICRON,WNDSPD,NMUOUTSHFLA,MUOUTSHFLA,SURF_EMIS_ARR,emiss_lut_outside)
   if(emiss_lut_outside) then
		ALLOCATE(SURF_EMIS_QARR(NMUOUTSHFLA))
		call cal_seaemis_flat(NWRE,NWIM,NMUOUTSHFLA,MUOUTSHFLA,SURF_EMIS_ARR,SURF_EMIS_QARR)
   endif
ELSE
   SURF_EMIS_ARR=SURFACE_EMISSIVITY
ENDIF

THETA_IN=ACOS(MU_IN)
IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) NHEIGHTINT=5
DO I=1,4
  LRADA_SNG(1:NMUOUTSHFLA,0:NALYR,1:NPHIOUT)%VRAD(I)=0.0D0
  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)&
	  LRADA_SNG_SPSH(1:NMUOUTSHFLA,0:NALYR,1:NPHIOUT)%VRAD(I)=0.0D0
ENDDO

FLAG1=OCEAN .AND. FLATO
FLAG2=(.NOT. OCEAN).AND. LAMB .AND. (FLAM<1.0D0)

!NUMPHI=400
!ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
!CALL gauleg(-PI,PI,PHI_TMP,WPHI_TMP,NUMPHI)
!WPHI_TMP=WPHI_TMP/TWOPI

!IF(OCEAN .AND. (.NOT.FLATO))THEN
!  DIFF_FLG=.TRUE.
!  ALLOCATE(SUNGLTA(NUMMIE,NQDAD2+1:NQUADA,NMUOUTSHFLA,NPHIOUT))
!  DO IMIE=1,NUMMIE
!  DO ITHETA=1,NMUOUTSHFLA
!  DO IPHI=1,NPHIOUT
!  DO JQUAD=NQDAD2+1,NQUADA
!     SUNGLTA(IMIE,JQUAD,ITHETA,IPHI)%VRAD=0.0d0
!  DO IPHI_TMP=1,NUMPHI
!    CALL RADACMDRCT(MU_IN,OITAU,XJA(JQUAD), &
!                    PHI_TMP(IPHI_TMP),ARRY2,DIFF_FLG)
!    first order white cap correction
!    IF(WCFLG) ARRY2=ARRY2*(1.0D0-FWC)
! CREATE ARRARY TO STORE SUN GLINT
!    IF(SCL) ARRY2(2:4)=0.0D0

!    CALL PHASE_MATRIX_CALC(XJA(JQUAD),PHI_TMP(IPHI_TMP),MUOUTSHFLA(ITHETA),&
!                           PHIOUT(IPHI),IMIE,MTRX2)
!    MTRX1=0.5d0*WTA(JQUAD)*WPHI_TMP(IPHI_TMP)*MTRX2
!    ARRY3=MATMUL(MTRX1,ARRY2)
!    SUNGLTA(IMIE,JQUAD,ITHETA,IPHI)%VRAD=             &
!           SUNGLTA(IMIE,JQUAD,ITHETA,IPHI)%VRAD + ARRY3    
!  ENDDO
!  ENDDO
!  ENDDO
!  ENDDO
!  ENDDO
!ENDIF

IF(FLAG1)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)
ELSE IF(FLAG2)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)
  FRES_MTRX=FRES_MTRX*(1.0D0-FLAM)
ENDIF

DO IPHI=1,NPHIOUT
DO ITHETA=1,NMUOUTSHFLA

SINTV=SQRT(1.0D0-MUOUTSHFLA(ITHETA)*MUOUTSHFLA(ITHETA))

IF(MUOUTSHFLA(ITHETA)<0.0D0)THEN

DIST0=RADIUS_EARTH*SINTV

LRADA_SNG(ITHETA,0,IPHI)%VRAD(1)=CMB_Rad
IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
       LRADA_SNG_SPSH(ITHETA,0,IPHI)%VRAD(1)=CMB_Rad

DO I=1,NALYR

  Thermal_Arry(1)=(1.0D0-ALYR(I)%LBDOM)*BT_Planck(I)
  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT

  CALL PHASE_MATRIX_CALC(MU_IN,0.0d0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX1)
  MTRX1=LBDO_A_PRSV(I)*MTRX1/(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))

  ARRY2=MATMUL(MTRX1,ARRY1)
! convention sign changes.
  ARRY2(3)=-ARRY2(3)
  ARRY2(4)=-ARRY2(4)
  IF(SCL) ARRY2(2:4)=0.0D0

  RTMP2= EXP(-DABS((ALYR(I)%TAUT-ALYR(I)%TAUB)/MUOUTSHFLA(ITHETA)))

  IF(ABS(MUOUTSHFLA(ITHETA)-MU_IN)<TINY2)THEN

    LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
      RTMP2*LRADA_SNG(ITHETA,I-1,IPHI)%VRAD(:)   +          &
           EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I)) *          &
      (ALYR(I)%TAUT-ALYR(I)%TAUB)/DABS(MUOUTSHFLA(ITHETA))* ARRY2(:) +        &
      Thermal_Arry(:)*(1.0d0 - RTMP2)

  ELSE

    RTMP=-MU_IN/(MUOUTSHFLA(ITHETA)-MU_IN)
    RTMP1=ALYR(I)%TAUT-ALYR(I)%TAUB

    LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
	  RTMP2*LRADA_SNG(ITHETA,I-1,IPHI)%VRAD(:) + &
        RTMP * EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I))*(1.0D0 -       &
		  EXP(-RTMP1*(1.0D0/MU_IN-1.0D0/MUOUTSHFLA(ITHETA))) ) * ARRY2(:) +   &
        Thermal_Arry(:)*(1.0d0 - RTMP2)

  ENDIF

  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION)THEN

	RTMP=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - &
		 SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I))**2-DIST0**2)
	RTMP1=RTMP*(ALYR(I)%TAUT-ALYR(I)%TAUB) / &
		  (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))

    RTMP2= EXP(-RTMP1)

	HEIGHT_INTERVAL=(HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))/(NHEIGHTINT-1.0D0)

	SOURCETEMP=0.0D0
	DO ILAYERSUB=1,NHEIGHTINT
		IF(ILAYERSUB==1 .OR. ILAYERSUB==NHEIGHTINT) THEN
			WEIGHT=0.5D0
		ELSE
			WEIGHT=1.0D0
		ENDIF
		HEIGHT_TEMP=HEIGHT_ATMOSPHERE(I-1)-HEIGHT_INTERVAL*(ILAYERSUB-1)

		TAUTEMP1=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - &
				 SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)

		TAUTEMP1=TAUTEMP1*(ALYR(I)%TAUT-ALYR(I)%TAUB)/ &
				(HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))

        TAUTEMP1=RTMP1-TAUTEMP1

		CALL SLANT_PATH_SURF_FSS(HEIGHT_TEMP,I,MU_IN,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),&
								 SLANT_TAU_LOCAL)

		SOURCETEMP=SOURCETEMP+ WEIGHT*EXP(-SLANT_TAU_LOCAL)*EXP(-TAUTEMP1)
	ENDDO
	LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:)= RTMP2*LRADA_SNG_SPSH(ITHETA,I-1,IPHI)%VRAD(:) + &
           SOURCETEMP*RTMP1*ARRY2(:)/(NHEIGHTINT-1.0D0) + Thermal_Arry(:)*(1.0d0 - RTMP2)

  ENDIF

IF(FLAG1 .OR. FLAG2)THEN
  CALL PHASE_MATRIX_CALC(-MU_IN,0.0D0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)
  
  MTRX2=LBDO_A_PRSV(I)*MTRX2/(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))

  ARRY3=MATMUL(FRES_MTRX,ARRY1)
  IF(SCL) ARRY3(2:4)=0.0D0
  ARRY4=MATMUL(MTRX2,ARRY3)

! convention sign changes.
  ARRY4(3)=-ARRY4(3)
  ARRY4(4)=-ARRY4(4)

   RTMP=ABS(MU_IN/(MUOUTSHFLA(ITHETA)+MU_IN))
   RTMP1= ALYR(I)%TAUT-ALYR(I)%TAUB

   IF(FLAG1)RTMP2=OITAU
   IF(FLAG2)RTMP2=TOTALTAU

   ARRY3= ABS(RTMP)* EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR)) *                    &
		EXP(-ABS((RTMP2-ALYR(I)%TAUT)/MU_IN)) *                            &
		ABS(1.0D0 - EXP(-RTMP1/RTMP/ABS(MUOUTSHFLA(ITHETA)))) * ARRY4

   LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG(ITHETA,I,IPHI)%VRAD(:) + ARRY3(:)
   IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
      LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:) + ARRY3(:)

ENDIF
! TESING
!IF(OCEAN .AND. (.NOT.FLATO))THEN

!  DO JQUAD=NQDAD2+1,NQUADA
!    IMIE=ALYR(I)%IPT
!    ARRY3=LBDO_A_PRSV(I)*SUNGLTA(IMIE,JQUAD,ITHETA,IPHI)%VRAD &
!          /(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))
!    RTMP=XJA(JQUAD)/(XJA(JQUAD)-MUOUTSHFLA(ITHETA))
!    IF(RTMP<0.0D0)STOP 'CHECK SINGLE SCATTERING POINT 2'
!    RTMP1=EXP(-ABS((ALYR(I)%TAUT-OITAU)/XJA(JQUAD)))
!    RTMP2=ALYR(I)%TAUT-ALYR(I)%TAUB
!    LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG(ITHETA,I,IPHI)%VRAD(:) + &
!          ARRY3*RTMP*RTMP1*(1.0D0-EXP(-ABS(RTMP2/RTMP/MUOUTSHFLA(ITHETA))))
!  ENDDO
!ENDIF !OCEAN IF


ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0

ELSEIF(MUOUTSHFLA(ITHETA)>0.0D0)THEN
! ATMOSPHERE MU>0

ARRY1=ESUN/FOURPI

IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) THEN
	IF(IPSS_VIEWANGLE_GROUND==0)THEN
		DIST0=RADIUS_EARTH*SINTV
	ELSE
		DIST0=(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))*SINTV
	ENDIF
ENDIF

IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION .AND. DIST0>RADIUS_EARTH)THEN
! ONLY FOR (IPSS_VIEWANGLE_GROUND==1) AS DIST0<=RADIUS_EARTH FOR THE OTHER CASE.
	ALLOCATE(LRADATMP1(0:NALYR))
	DO JLAYER=0,NALYR
	  LRADATMP1(JLAYER)%VRAD(1:4)=0.0D0
	ENDDO
    LRADATMP1(0)%VRAD(1)=CMB_Rad
	DO JLAYER=1,NALYR
	   IF(RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER)<=DIST0)THEN
		   ILAYER=JLAYER
		   EXIT
	   ENDIF
	ENDDO

	DO I=1,ILAYER

      Thermal_Arry(1)=(1.0D0-ALYR(I)%LBDOM)*BT_Planck(I)

	  IMIE=ALYR(I)%IPT
	  CALL PHASE_MATRIX_CALC(MU_IN,0.0D0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)
	  MTRX1=LBDO_A_PRSV(I)*MTRX2/(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))
	  ARRY2=MATMUL(MTRX1,ARRY1)

	! convention sign changes.
	  ARRY2(3)=-ARRY2(3)
	  ARRY2(4)=-ARRY2(4)

	  IF(SCL) ARRY2(2:4)=0.0D0
	  
	  IF(I<ILAYER)THEN
          RTMP=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - &
               SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I))**2-DIST0**2)
          RTMP1=RTMP*(ALYR(I)%TAUT-ALYR(I)%TAUB) / &
	            (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))
          HEIGHT_INTERVAL=(HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I)) / &
                          (NHEIGHTINT-1.0D0)
	  ELSE
		  RTMP=2.0D0*SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2)
		  RTMP1=RTMP*(ALYR(I)%TAUT-ALYR(I)%TAUB) / &
				(HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))
	  ENDIF
      RTMP2=EXP(-RTMP1)
	  TAU_INTERVAL=RTMP1/(NHEIGHTINT-1.0D0)

	  SOURCETEMP=0.0D0
	  DO ILAYERSUB=1,NHEIGHTINT
		  IF(ILAYERSUB==1 .OR. ILAYERSUB==NHEIGHTINT) THEN
			  WEIGHT=0.5D0
		  ELSE
			  WEIGHT=1.0D0
		  ENDIF

		  IF(I<ILAYER)THEN
			  HEIGHT_TEMP=HEIGHT_ATMOSPHERE(I-1)-HEIGHT_INTERVAL*(ILAYERSUB-1)

			  TAUTEMP=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - &
					   SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I))**2-DIST0**2)

              TAUTEMP=TAUTEMP*(ALYR(I)%TAUT-ALYR(I)%TAUB)/ &
		                (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))

			  TAUTEMP1=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - &
					  SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)

			  TAUTEMP1=TAUTEMP1*(ALYR(I)%TAUT-ALYR(I)%TAUB)/ &
					  (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))

              TAUTEMP1=TAUTEMP-TAUTEMP1

			  EPSS_FARSIDE=.TRUE.
			  CALL SLANT_PATH_TOA_FSS(HEIGHT_TEMP,I,MU_IN,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),&
									  SLANT_TAU_LOCAL,EPSS_FARSIDE)
			  SOURCETEMP=SOURCETEMP+ WEIGHT*EXP(-SLANT_TAU_LOCAL)*EXP(-TAUTEMP1)
		  ELSE

              TAUTEMP=2.0d0*SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2)
              TAUTEMP=TAUTEMP*(ALYR(I)%TAUT-ALYR(I)%TAUB)/ &
		                       (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))

			  TAUTEMP1=TAU_INTERVAL*(ILAYERSUB-1)
			  LDIS=TAUTEMP1/(ALYR(I)%TAUT-ALYR(I)%TAUB) * &
                   (HEIGHT_ATMOSPHERE(I-1)-HEIGHT_ATMOSPHERE(I))
              LDIS=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I-1))**2-DIST0**2) - LDIS
              HEIGHT_TEMP=SQRT(LDIS**2+DIST0**2)-RADIUS_EARTH
              TAUTEMP1=TAUTEMP-TAUTEMP1

			  IF(ILAYERSUB<=(NHEIGHTINT-1)/2)THEN
				  EPSS_FARSIDE=.TRUE.
			  ELSE
				  EPSS_FARSIDE=.FALSE.
			  ENDIF
			  CALL SLANT_PATH_TOA_FSS(HEIGHT_TEMP,I,MU_IN,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),&
						SLANT_TAU_LOCAL,EPSS_FARSIDE)
			  SOURCETEMP=SOURCETEMP+ WEIGHT*EXP(-SLANT_TAU_LOCAL)*EXP(-TAUTEMP1)
		  ENDIF
	  ENDDO
	  LRADATMP1(I)%VRAD(:)= RTMP2*LRADATMP1(I-1)%VRAD(:)                  +   &
							SOURCETEMP*RTMP1*ARRY2(:)/(NHEIGHTINT-1.0D0)  +   &
                            Thermal_Arry(:)*(1.0d0 - RTMP2)
	ENDDO   !LOOP ATMOSPHERE LAYERS
	LRADA_SNG_SPSH(ITHETA,ILAYER-1,IPHI)%VRAD(:)=LRADATMP1(ILAYER)%VRAD(:)
	DEALLOCATE(LRADATMP1)

	EPSS_FARSIDE=.FALSE.
	DO I=ILAYER-2,0,-1
      Thermal_Arry(1)=(1.0D0-ALYR(I+1)%LBDOM)*BT_Planck(I+1)

	  IMIE=ALYR(I+1)%IPT
	  CALL PHASE_MATRIX_CALC(MU_IN,0.0D0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)
	  MTRX1=LBDO_A_PRSV(I+1)*MTRX2/(1.0D0-LBDO_A_PRSV(I+1)*FTRUNC(IMIE))
	  ARRY2=MATMUL(MTRX1,ARRY1)

	! convention sign changes.
	  ARRY2(3)=-ARRY2(3)
	  ARRY2(4)=-ARRY2(4)

	  IF(SCL) ARRY2(2:4)=0.0D0

	  RTMP1=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I))**2-DIST0**2)- &
			  SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I+1))**2-DIST0**2)
	  RTMP1=RTMP1*(ALYR(I+1)%TAUT-ALYR(I+1)%TAUB) / &
                  (HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))
	  RTMP2=EXP(-RTMP1)

	  HEIGHT_INTERVAL=(HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))/(NHEIGHTINT-1.0D0)
	  TAU_INTERVAL=(ALYR(I+1)%TAUT-ALYR(I+1)%TAUB)/(NHEIGHTINT-1.0D0)

	  SOURCETEMP=0.0D0
	  DO ILAYERSUB=1,NHEIGHTINT
		  IF(ILAYERSUB==1 .OR. ILAYERSUB==NHEIGHTINT) THEN
			  WEIGHT=0.5D0
		  ELSE
			  WEIGHT=1.0D0
		  ENDIF

		  HEIGHT_TEMP=HEIGHT_ATMOSPHERE(I+1)+HEIGHT_INTERVAL*(ILAYERSUB-1)

		  TAUTEMP=SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)- &
					SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I+1))**2-DIST0**2)
		  TAUTEMP=TAUTEMP*(ALYR(I+1)%TAUT-ALYR(I+1)%TAUB) / &
						(HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))

		  CALL SLANT_PATH_TOA_FSS(HEIGHT_TEMP,I+1,MU_IN,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),&
								  SLANT_TAU_LOCAL,EPSS_FARSIDE)
		  SOURCETEMP=SOURCETEMP+ WEIGHT*EXP(-SLANT_TAU_LOCAL)* &
								 EXP(-(RTMP1-TAUTEMP))
	  ENDDO
	  LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:)=                              &
			  RTMP2*LRADA_SNG_SPSH(ITHETA,I+1,IPHI)%VRAD(:)       +       &
					SOURCETEMP*RTMP1*ARRY2(:)/(NHEIGHTINT-1.0D0)  +       &
                    Thermal_Arry(:)*(1.0d0 - RTMP2)
	ENDDO   !LOOP ATMOSPHERE LAYERS

ENDIF  !EXACT IPSS CORRECTION FOR (VIEWING ZENITH ANGLE > CRITICAL ANGLE)
	   ! AND (IPSS_VIEWANGLE_GROUND==1 (Sensor viewing angles REFERENCED at TOA)

LRADA_SNG(ITHETA,NALYR,IPHI)%VRAD(1)=SURF_EMIS_ARR(ITHETA)*SURFACE_RAD
IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
	LRADA_SNG_SPSH(ITHETA,NALYR,IPHI)%VRAD(1)=SURF_EMIS_ARR(ITHETA)*SURFACE_RAD

if(emiss_lut_outside) then
	LRADA_SNG(ITHETA,NALYR,IPHI)%VRAD(2)=SURF_EMIS_QARR(ITHETA)*SURFACE_RAD
	IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
		LRADA_SNG_SPSH(ITHETA,NALYR,IPHI)%VRAD(2)=SURF_EMIS_QARR(ITHETA)*SURFACE_RAD
endif

ARRY1=ESUN/FOURPI
DO I=NALYR-1,0,-1

  Thermal_Arry(1)=(1.0D0-ALYR(I+1)%LBDOM)*BT_Planck(I+1)

  IMIE=ALYR(I+1)%IPT
  CALL PHASE_MATRIX_CALC(MU_IN,0.0D0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)
  MTRX1=LBDO_A_PRSV(I+1)*MTRX2/(1.0D0-LBDO_A_PRSV(I+1)*FTRUNC(IMIE))
  ARRY2=MATMUL(MTRX1,ARRY1)

! convention sign changes.
  ARRY2(3)=-ARRY2(3)
  ARRY2(4)=-ARRY2(4)

  IF(SCL) ARRY2(2:4)=0.0D0

  RTMP=ABS(MU_IN/(MUOUTSHFLA(ITHETA)-MU_IN))
  RTMP1= ALYR(I+1)%TAUT-ALYR(I+1)%TAUB
  RTMP2=EXP(-DABS(RTMP1/MUOUTSHFLA(ITHETA)))
  LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=                              &
    RTMP2*LRADA_SNG(ITHETA,I+1,IPHI)%VRAD(:)   + &
     RTMP* EXP(-ABS(ALYR(I+1)%TAUB*SECANT_THETAL_PRSV(I))) *            &
     (1.0D0 - EXP(-RTMP1/RTMP/ABS(MUOUTSHFLA(ITHETA))))  * ARRY2(:) +   &
     Thermal_Arry(:)*(1.0d0 - RTMP2)

  IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION .AND. DIST0<RADIUS_EARTH)THEN
      EPSS_FARSIDE=.FALSE.

	  RTMP1=SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I))**2-DIST0**2)- &
			SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I+1))**2-DIST0**2)
	  RTMP1=RTMP1*(ALYR(I+1)%TAUT-ALYR(I+1)%TAUB) / &
				  (HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))

	  RTMP2=EXP(-RTMP1)

      HEIGHT_INTERVAL=(HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))/(NHEIGHTINT-1.0D0)
      SOURCETEMP=0.0D0
      DO ILAYERSUB=1,NHEIGHTINT
          IF(ILAYERSUB==1 .OR. ILAYERSUB==NHEIGHTINT) THEN
              WEIGHT=0.5D0
          ELSE
              WEIGHT=1.0D0
          ENDIF
          HEIGHT_TEMP=HEIGHT_ATMOSPHERE(I+1)+HEIGHT_INTERVAL*(ILAYERSUB-1)

		  TAUTEMP=SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)- &
				  SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(I+1))**2-DIST0**2)
		  TAUTEMP=TAUTEMP*(ALYR(I+1)%TAUT-ALYR(I+1)%TAUB) / &
						  (HEIGHT_ATMOSPHERE(I)-HEIGHT_ATMOSPHERE(I+1))

		  TAUTEMP=RTMP1-TAUTEMP

		  CALL SLANT_PATH_TOA_FSS(HEIGHT_TEMP,I+1,MU_IN,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),&
								  SLANT_TAU_LOCAL,EPSS_FARSIDE)
		  SOURCETEMP=SOURCETEMP+ WEIGHT*EXP(-SLANT_TAU_LOCAL)* &
                                 EXP(-TAUTEMP)
      ENDDO
      LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:)=                              &
     	RTMP2*LRADA_SNG_SPSH(ITHETA,I+1,IPHI)%VRAD(:)      +              &
              SOURCETEMP*RTMP1*ARRY2(:)/(NHEIGHTINT-1.0D0) +              &
              Thermal_Arry(:)*(1.0d0 - RTMP2)

  ENDIF

IF(FLAG1 .OR. FLAG2)THEN
   CALL PHASE_MATRIX_CALC(-MU_IN,0.0D0,MUOUTSHFLA(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)

   MTRX2=LBDO_A_PRSV(I+1)*MTRX2/(1.0D0-LBDO_A_PRSV(I+1)*FTRUNC(IMIE))
   ARRY3=MATMUL(FRES_MTRX,ARRY1)
   IF(SCL) ARRY3(2:4)=0.0D0
   ARRY4=MATMUL(MTRX2,ARRY3)
! convention sign changes.
   ARRY4(3)=-ARRY4(3)
   ARRY4(4)=-ARRY4(4)

   IF(FLAG1)RTMP2=OITAU
   IF(FLAG2)RTMP2=TOTALTAU
   RTMP1=ALYR(I+1)%TAUT-ALYR(I+1)%TAUB
   IF(ABS(MUOUTSHFLA(ITHETA)+MU_IN)<TINY2)THEN
     ARRY3=EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR))*                       &
		   EXP(-ABS((RTMP2-ALYR(I+1)%TAUB)/MU_IN))*                     &
		   RTMP1*ARRY4/MUOUTSHFLA(ITHETA)
   ELSE
     RTMP=-MU_IN/(MUOUTSHFLA(ITHETA)+MU_IN)
     ARRY3=RTMP* EXP(-RTMP2*SECANT_THETAL_PRSV(NALYR))*                    &
                  (EXP(-RTMP1/MUOUTSHFLA(ITHETA)) * &
				   EXP(-ABS((RTMP2-ALYR(I+1)%TAUT)/MU_IN)) -&
				   EXP(-ABS((RTMP2-ALYR(I+1)%TAUB)/MU_IN)) )*ARRY4
   ENDIF
   LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG(ITHETA,I,IPHI)%VRAD(:) + ARRY3(:)

   IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
      LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG_SPSH(ITHETA,I,IPHI)%VRAD(:) + ARRY3(:)

ENDIF


!IF(OCEAN .AND. (.NOT.FLATO))THEN
!  DO JQUAD=NQDAD2+1,NQUADA
!    IMIE=ALYR(I+1)%IPT
!    ARRY3=LBDO_A_PRSV(I+1)*SUNGLTA(IMIE,JQUAD,ITHETA,IPHI)%VRAD &
!         /(1.0D0-LBDO_A_PRSV(I+1)*FTRUNC(IMIE))
!    RTMP1=EXP(-ABS((ALYR(I+1)%TAUB-OITAU)/XJA(JQUAD)))
!    RTMP2=ALYR(I+1)%TAUT-ALYR(I+1)%TAUB

!    IF(ABS(MUOUTSHFLA(ITHETA)-XJA(JQUAD))<TINY2)THEN
!      LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG(ITHETA,I,IPHI)%VRAD(:) + &
!          ARRY3*RTMP1*RTMP2/MUOUTSHFLA(ITHETA)
!    ELSE
!      RTMP=XJA(JQUAD)/(MUOUTSHFLA(ITHETA)-XJA(JQUAD))
!      LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)= LRADA_SNG(ITHETA,I,IPHI)%VRAD(:) +              &
!        ARRY3*RTMP*(EXP((ALYR(I+1)%TAUT-OITAU)/XJA(JQUAD))*EXP(-RTMP2/MUOUTSHFLA(ITHETA)) - &
!        RTMP1)
!    ENDIF
!  ENDDO
!ENDIF !OCEAN IF

ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU>0

ENDIF ! MUOUTSHFLA(ITHETA) IF

ENDDO   ! LOOP ITHETA
ENDDO  ! LOOP PHI

!IF(OCEAN .AND. (.NOT.FLATO))DEALLOCATE(SUNGLTA)
!DEALLOCATE(PHI_TMP,WPHI_TMP)
IF((OCEAN .AND. (.NOT.(FLATO))) .or. pBRDF .or. fSnowBRDF .OR. fRossLiBRDF) THEN

! ROUGH OCEAN SURFACE CONTRIBUTION TO SINGLE SCATTERING CORRECTION
  ALLOCATE(LSPATMP(NQUADA,0:MAXMORD),LRADATMP(NQUADA,NPHIOUT),&
         RADATMP(NQUADA,4),RADATMP1(NMUOUTSHFLA,4))

  DO IDTAU=1,NDTAUA
    LSPATMP(1:NQUADA,0:MAXMORD)= &
          LSPA_SNG_RO(1:NQUADA,INDXDETA(IDTAU),0:MAXMORD)
    CALL RAD_FOURIER_INVERSE(NQUADA,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPATMP,LRADATMP)
    DO IPHI=1,NPHIOUT
      DO IQUAD=1,NQUADA
        RADATMP(IQUAD,:)=LRADATMP(IQUAD,IPHI)%VRAD(:)
      ENDDO
      CALL RADINTPL2(MPLIN,NQUADA,XJA,RADATMP,NMUOUTSHFLA, &
	               MUOUTSHFLA,RADATMP1)
    DO ITHETA=1,NMUOUTSHFLA
      LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)=         &
         LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:) + &
         RADATMP1(ITHETA,:)
      IF(SPHERICAL_SHELL_SINGLESCATTERING_CORRECTION) &
		LRADA_SNG_SPSH(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)=         &
		   LRADA_SNG_SPSH(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:) + &
		   RADATMP1(ITHETA,:)
    ENDDO
    ENDDO
  ENDDO

  DEALLOCATE(LSPATMP,LRADATMP,RADATMP,RADATMP1)
ENDIF
IF(SEC_RAD_CORR .AND. FWDCN_CORR_FLAG)THEN
DO IDTAU=1,NDTAUA
DO IPHI=1,NPHIOUT
DO ITHETA=1,NMUOUTSHFLA

  COST1=MU_IN
  COST2=MUOUTSHFLA(ITHETA)
  PHI1=0.0D0
  PHI2=PHIOUT(IPHI)
  SINT1=SQRT(1.0D0-COST1*COST1)
  SINT2=SQRT(1.0D0-COST2*COST2)
  MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI2-PHI1)
  ILAYER=INDXDETA_SNGSCAT(IDTAU)

  IF(MUSCAT>MINMUFWDCN .AND. ILAYER>0)THEN
    CALL DBLE_SCAT_CORR_FWDCN(ILAYER,COST1,PHI1,COST2,PHI2,RADCORR)

    LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1)=         &
       LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(1) - RADCORR
  ENDIF
ENDDO
ENDDO
ENDDO
ENDIF ! SEC_RAD_CORR OPTION
DEALLOCATE(SURF_EMIS_ARR)
if(OCEAN .AND. emiss_lut_outside) DEALLOCATE(SURF_EMIS_QARR)

END SUBROUTINE SNGL_SCAT_CRRCT_ATMOS

SUBROUTINE SNGL_SCAT_CRRCT_OCEAN(MU_IN,NMUOUTSHFLO,&
         NPHIOUT,PHIOUT,MUOUTSHFLO)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
REAL*8,INTENT(IN) :: MU_IN

INTEGER(I4B),INTENT(IN) :: NMUOUTSHFLO,NPHIOUT
REAL*8,DIMENSION(NMUOUTSHFLO),INTENT(IN) :: MUOUTSHFLO
REAL*8,DIMENSION(NPHIOUT),INTENT(IN) :: PHIOUT

!TYPE(ARRAY4),DIMENSION(:,:,:,:),ALLOCATABLE :: SUNGLTO

INTEGER :: IMIE,IQUAD,I,IPHI,ITHETA,IDTAU
REAL*8 :: RTMP, RTMP1,RTMP2,THETA1,THETA_IN
REAL*8,DIMENSION(4)   :: ARRY1,ARRY2,ARRY3
REAL*8,DIMENSION(4,4) :: FRES_MTRX,MTRX1,MTRX2
LOGICAL :: FLAG1,FLAG2
!LOGICAL :: DIFF_FLG

TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADOTMP,LSPOTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADOTMP,RADOTMP1

!INTEGER :: NUMPHI,IPHI_TMP
!REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP

THETA_IN=ACOS(MU_IN)
FLAG1=OCEAN .AND. FLATO
FLAG2=(.NOT. OCEAN).AND. LAMB .AND. (FLAM<1.0D0)
!IF(OCEAN .AND. (.NOT.FLATO))THEN
!  DIFF_FLG=.TRUE.
!  NUMPHI=400
!  ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
!  CALL gauleg(-PI,PI,PHI_TMP,WPHI_TMP,NUMPHI)
!   WPHI_TMP=WPHI_TMP/TWOPI
!  ALLOCATE(SUNGLTO(NUMMIE,NQUADSO,NMUOUTSHFLO,NPHIOUT))
!  DO IMIE=1,NUMMIE
!  DO ITHETA=1,NMUOUTSHFLO
!  DO IPHI=1,NPHIOUT
!  DO JQUAD=1, NQUADSO
!     SUNGLTO(IMIE,JQUAD,ITHETA,IPHI)%VRAD=0.0D0
!  DO IPHI_TMP=1,NUMPHI
!     CALL RADOCMDRCT(MU_IN,OITAU,XJSO(JQUAD), &
!                   PHI_TMP(IPHI_TMP),ARRY2,DIFF_FLG)
!     IF(WCFLG)ARRY2=ARRY2*(1.0D0-FWC)
!     IF(SCL) ARRY2(2:4)=0.0D0
!     CALL PHASE_MATRIX_CALC(XJSO(JQUAD),PHI_TMP(IPHI_TMP),MUOUTSHFLO(ITHETA),&
!                            PHIOUT(IPHI),IMIE,MTRX2)
!     MTRX1=0.5d0*WTSO(JQUAD)*WPHI_TMP(IPHI_TMP)*MTRX2
!     ARRY3=MATMUL(MTRX1,ARRY2)
!     SUNGLTO(IMIE,JQUAD,ITHETA,IPHI)%VRAD=             &
!           SUNGLTO(IMIE,JQUAD,ITHETA,IPHI)%VRAD + ARRY3    
!   ENDDO
!   ENDDO
!   ENDDO
!   ENDDO
!   ENDDO
!ENDIF

!_______OCEAN_______
IF(.NOT. OCEAN ) STOP 'CALLING OCEAN CORRECTION WITHOUT OCEAN CONFIG'
IF(OCEAN_NO_TRAN) STOP 'CALLING OCEAN CORRECTION WITHOUT OCEAN CONFIG'

IF(FLAG1)THEN
  THETA1=PI-THETA_IN
  CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_MTRX)
ENDIF

DO I=1,4
  LRADO_SNG(1:NMUOUTSHFLO,0:NOLYR,1:NPHIOUT)%VRAD(I)=0.0D0
ENDDO

ARRY1=ESUN*EXP(-OITAU*SECANT_THETAL_PRSV(NALYR))/PI
DO IPHI=1,NPHIOUT
DO ITHETA=1,NMUOUTSHFLO

IF(MUOUTSHFLO(ITHETA)<0.0D0)THEN

DO I=1,NOLYR
  IMIE=OLYR(I)%IPT
  LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=                           &
     EXP(-(OLYR(I)%TAUT-OLYR(I)%TAUB)/DABS(MUOUTSHFLO(ITHETA)))* &
     LRADO_SNG(ITHETA,I-1,IPHI)%VRAD(:)
  IF(FLAG1)THEN

    IF(NQUADSO>1)STOP 'SINGLE SCATTERING CHECK POINT 5'
    MTRX1=FRES_MTRX*abs(MU_IN/XJSO(1))/4.0d0
    ARRY2=MATMUL(MTRX1,ARRY1)
    CALL PHASE_MATRIX_CALC(XJSO(1),0.0D0,MUOUTSHFLO(ITHETA),&
                          PHIOUT(IPHI),IMIE,MTRX2)
    MTRX1=LBDO_O_PRSV(I)*MTRX2/(1.0D0-LBDO_O_PRSV(I)*FTRUNC(IMIE))
    ARRY3=MATMUL(MTRX1,ARRY2)
    
! convention sign changes.
ARRY3(3)=-ARRY3(3)
ARRY3(4)=-ARRY3(4)
    
    RTMP1=EXP(-ABS((OLYR(I)%TAUT-OITAU)/XJSO(1)))
    RTMP2=OLYR(I)%TAUT-OLYR(I)%TAUB

    IF(ABS(XJSO(1)-MUOUTSHFLO(ITHETA))<TINY2)THEN
       LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) + &
             ARRY3*RTMP1*RTMP2/ABS(MUOUTSHFLO(ITHETA))
    ELSE
       RTMP=-XJSO(1)/(MUOUTSHFLO(ITHETA)-XJSO(1))
       LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) + &
             ARRY3*RTMP*(RTMP1-EXP((OLYR(I)%TAUB-OITAU)/XJSO(1))*       &
             EXP(RTMP2/MUOUTSHFLO(ITHETA)))
       IF(RTMP*(RTMP1-EXP((OLYR(I)%TAUB-OITAU)/XJSO(1))*&
            EXP(RTMP2/MUOUTSHFLO(ITHETA)))<0.0D0)STOP 'CHK 6'
    ENDIF

!  ELSE  !ROUGH OCEAN SURFACE OPTION

!    DO JQUAD=1, NQUADSO
!      ARRY3=LBDO_O_PRSV(I)*SUNGLTO(IMIE,JQUAD,ITHETA,IPHI)%VRAD &
!            /(1.0D0-LBDO_O_PRSV(I)*FTRUNC(IMIE))
!      RTMP=-XJSO(JQUAD)/(MUOUTSHFLO(ITHETA)-XJSO(JQUAD))
!      RTMP1=EXP(-ABS((OLYR(I)%TAUT-OITAU)/XJSO(JQUAD)))
!      RTMP2=OLYR(I)%TAUT-OLYR(I)%TAUB
!      IF(ABS(XJSO(JQUAD)-MUOUTSHFLO(ITHETA))<TINY2)THEN
!       LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) + &
!                                          ARRY3*RTMP1*RTMP2/ABS(MUOUTSHFLO(ITHETA))
!      ELSE
!       LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) +       &
!                     ARRY3*RTMP*(RTMP1-EXP((OLYR(I)%TAUB-OITAU)/XJSO(JQUAD))* &
!                     EXP(RTMP2/MUOUTSHFLO(ITHETA)))
!       IF(RTMP*(RTMP1-EXP((OLYR(I)%TAUB-OITAU)/XJSO(JQUAD))*&
!                     EXP(RTMP2/MUOUTSHFLO(ITHETA)))<0.0D0)STOP 'CHK 7'
!      ENDIF
!    ENDDO

  ENDIF
ENDDO   !LOOP OCEAN LAYERS FOR MU<0


! UPDATE L^M_N FOR MU>0.0D0
ELSE IF (MUOUTSHFLO(ITHETA)>0.0D0)THEN
! OCEAN MU>0

DO I=NOLYR-1,0,-1
  IMIE=OLYR(I+1)%IPT
  LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=                               &
        EXP(-DABS((OLYR(I+1)%TAUT-OLYR(I+1)%TAUB)/MUOUTSHFLO(ITHETA)))* &
        LRADO_SNG(ITHETA,I+1,IPHI)%VRAD(:)
  IF(FLAG1)THEN
      MTRX1=FRES_MTRX*abs(MU_IN/XJSO(1))/4.0d0
      ARRY2=MATMUL(MTRX1,ARRY1)
      CALL PHASE_MATRIX_CALC(XJSO(1),0.0D0,MUOUTSHFLO(ITHETA),&
                            PHIOUT(IPHI),IMIE,MTRX2)
      MTRX1=LBDO_O_PRSV(I+1)*MTRX2/(1.0D0-LBDO_O_PRSV(I+1)*FTRUNC(IMIE))
      ARRY3=MATMUL(MTRX1,ARRY2)
! convention sign changes.
ARRY3(3)=-ARRY3(3)
ARRY3(4)=-ARRY3(4)

      RTMP=-XJSO(1)/(MUOUTSHFLO(ITHETA)-XJSO(1))
      RTMP1=EXP(-ABS((OLYR(I+1)%TAUB-OITAU)/XJSO(1)))
      RTMP2=OLYR(I+1)%TAUT-OLYR(I+1)%TAUB

      LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) + &
             ARRY3*RTMP*RTMP1*(1.0D0-EXP(-RTMP2/RTMP/MUOUTSHFLO(ITHETA)))
!      IF(RTMP*RTMP1*(1.0D0-EXP(-RTMP2/RTMP/MUOUTSHFLO(ITHETA)))<0.0d0)then
!         WRITE(*,*)RTMP,RTMP1, RTMP2,MUOUTSHFLO(ITHETA)
!         stop 'chk 7'
!      ENDIF
!  ELSE ! ROUGH OCEAN SECTION
!    DO JQUAD=1, NQUADSO
!      ARRY3=LBDO_O_PRSV(I+1)*SUNGLTO(IMIE,JQUAD,ITHETA,IPHI)%VRAD &
!           /(1.0D0-LBDO_O_PRSV(I+1)*FTRUNC(IMIE))
!      RTMP=-XJSO(JQUAD)/(MUOUTSHFLO(ITHETA)-XJSO(JQUAD))
!      RTMP1=EXP(-ABS((OLYR(I+1)%TAUB-OITAU)/XJSO(JQUAD)))
!      RTMP2=OLYR(I+1)%TAUT-OLYR(I+1)%TAUB

!      LRADO_SNG(ITHETA,I,IPHI)%VRAD(:)=LRADO_SNG(ITHETA,I,IPHI)%VRAD(:) + &
!        ARRY3*RTMP*RTMP1*(1.0D0-EXP(-RTMP2/RTMP/MUOUTSHFLO(ITHETA)))
!        if(RTMP*RTMP1*(1.0D0-EXP(-RTMP2/RTMP/MUOUTSHFLO(ITHETA)))<0.0d0)stop 'chk 7'
!    ENDDO

  ENDIF ! FLAT OCEAN IF

ENDDO   !LOOP OCEAN LAYERS FOR MU>0

ENDIF

ENDDO   ! LOOP MUOUTSHFLO
ENDDO   ! LOOP PHIOUT
!IF(OCEAN .AND. (.NOT.FLATO))DEALLOCATE(PHI_TMP,WPHI_TMP,SUNGLTO)

IF(OCEAN .AND. (.NOT.(FLATO)))THEN
  ALLOCATE(LSPOTMP(NQUADO,0:MAXMORD),LRADOTMP(NQUADO,NPHIOUT),&
         RADOTMP(NQUADO,4),RADOTMP1(NMUOUTSHFLO,4))

  DO IDTAU=1,NDTAUO
    LSPOTMP(1:NQUADO,0:MAXMORD)= &
          LSPMNO_SNG(1:NQUADO,INDXDETO(IDTAU),0:MAXMORD)
    CALL RAD_FOURIER_INVERSE(NQUADO,MAXMORD,NPHIOUT,PHIOUT,&
                             LSPOTMP,LRADOTMP)
    DO IPHI=1,NPHIOUT
      DO IQUAD=1,NQUADO
        RADOTMP(IQUAD,:)=LRADOTMP(IQUAD,IPHI)%VRAD(:)
      ENDDO
      CALL RADINTPL2(2,NQUADO,XJO,RADOTMP,NMUOUTSHFLO, &
	               MUOUTSHFLO,RADOTMP1)
    DO ITHETA=1,NMUOUTSHFLO
      LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD(:)=         &
         LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD(:) + &
         RADOTMP1(ITHETA,:)
    ENDDO
    ENDDO
  ENDDO

  DEALLOCATE(LSPOTMP,LRADOTMP,RADOTMP,RADOTMP1)

ENDIF

IF(RAMAN_SOURCE_FLAG .OR. FLUORESCENCE_SOURCE_FLAG)THEN
  ALLOCATE(LSPOTMP(NQUADO,0:2),LRADOTMP(NQUADO,NPHIOUT),&
         RADOTMP(NQUADO,4),RADOTMP1(NMUOUTSHFLO,4))

  DO IDTAU=1,NDTAUO
    LSPOTMP(1:NQUADO,0:2)= &
          LSPMNO_INELASTIC_SNG(1:NQUADO,INDXDETO(IDTAU),0:2)
    CALL RAD_FOURIER_INVERSE(NQUADO,2,NPHIOUT,PHIOUT,&
                             LSPOTMP,LRADOTMP)
    DO IPHI=1,NPHIOUT
      DO IQUAD=1,NQUADO
        RADOTMP(IQUAD,:)=LRADOTMP(IQUAD,IPHI)%VRAD(:)
      ENDDO
      CALL RADINTPL2(2,NQUADO,XJO,RADOTMP,NMUOUTSHFLO, &
	               MUOUTSHFLO,RADOTMP1)
    DO ITHETA=1,NMUOUTSHFLO
      LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD(:)=         &
         LRADO_SNG(ITHETA,INDXDETO_SNGSCAT(IDTAU),IPHI)%VRAD(:) + &
         RADOTMP1(ITHETA,:)
    ENDDO
    ENDDO
  ENDDO

  DEALLOCATE(LSPOTMP,LRADOTMP,RADOTMP,RADOTMP1)

ENDIF

END SUBROUTINE SNGL_SCAT_CRRCT_OCEAN


SUBROUTINE PHASE_MATRIX_CALC(MU0,PHI0,MUVIEW,PHIVIEW,IMIE,PHASE_MATRIX)
USE RTUTILITY, ONLY : SCL
USE PHASE_MATRIX_TRUNCATION, ONLY : NUMMIEANG,MU_SNG,PM_AO_SNG,NUMMIE
IMPLICIT NONE

REAL*8,INTENT(IN) :: MU0,PHI0,MUVIEW,PHIVIEW
INTEGER,INTENT(IN)  :: IMIE
REAL*8,DIMENSION(4,4),INTENT(OUT)::PHASE_MATRIX

REAL*8 :: MUSCAT,PHMXELEM

REAL*8, DIMENSION(4,4)::SLI1,SLI2,TEM1,TEM2
REAL*8 :: COST1,SINT1,COST2,SINT2,RTMP
REAL*8 :: SA,SB,SC,SPHI,FA,FB,FC,FPHI
REAL*8, DIMENSION(:),ALLOCATABLE::VSK,XJMIE
INTEGER :: IMIEANG,ICOM1,ICOM2,MPL,IULO,KLO

ALLOCATE(VSK(NUMMIEANG(IMIE)),XJMIE(NUMMIEANG(IMIE)))

DO IMIEANG=1,NUMMIEANG(IMIE)
  XJMIE(IMIEANG)=MU_SNG(IMIE,IMIEANG)
ENDDO

COST1=MU0
COST2=MUVIEW
SINT1=SQRT(1.0D0-COST1*COST1)
SINT2=SQRT(1.0D0-COST2*COST2)

MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHIVIEW-PHI0)

TEM1=0.0d0
DO ICOM1=1,4
DO ICOM2=1,4
   IF(SCL .and. (ICOM1>1 .OR. ICOM2>1)) CYCLE
   DO IMIEANG=1,NUMMIEANG(IMIE)
      VSK(IMIEANG)=PM_AO_SNG(IMIE,IMIEANG)%PHMX(ICOM1,ICOM2)
   ENDDO
   MPL=2
 
   IULO=INT(FLOAT(NUMMIEANG(IMIE))*ABS((MUSCAT-XJMIE(1))/(XJMIE(NUMMIEANG(IMIE))-XJMIE(1))))
   call hunt(XJMIE,NUMMIEANG(IMIE),MUSCAT,IULO)
   KLO=min(max(IULO-(MPL-1)/2,1),NUMMIEANG(IMIE)+1-MPL)
   CALL POLINT(XJMIE(KLO),VSK(KLO),MPL,MUSCAT,PHMXELEM,RTMP)
   TEM1(ICOM1,ICOM2)=PHMXELEM
ENDDO
ENDDO
IF(SCL)THEN
  PHASE_MATRIX=TEM1
  RETURN
ENDIF
SPHI=PHI0
SA=SINT1*COS(SPHI)
SB=SINT1*SIN(SPHI)
SC=COST1

FPHI=PHIVIEW
FA=SINT2*COS(FPHI)
FB=SINT2*SIN(FPHI)
FC=COST2
CALL RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
TEM2=MATMUL(TEM1,SLI1)
PHASE_MATRIX=MATMUL(SLI2,TEM2)
!PHASE_MATRIX(3,1)=-PHASE_MATRIX(3,1)
!PHASE_MATRIX(3,2)=-PHASE_MATRIX(3,2)
!PHASE_MATRIX(4,1)=-PHASE_MATRIX(4,1)
!PHASE_MATRIX(4,2)=-PHASE_MATRIX(4,2)
DEALLOCATE(VSK,XJMIE)

ENDSUBROUTINE PHASE_MATRIX_CALC

SUBROUTINE SOURCEF_ATMOS(M)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
INTEGER,INTENT(IN):: M
INTEGER :: IQUAD,JQUAD,I,IMIE,ITAU
REAL*8,DIMENSION(4,4):: MTRX1
REAL*8,DIMENSION(4):: ARRY1,ARRY2

! ZERO OUT SOURCE TERM TO PREPARE THE NEXT COLLISON
DO IQUAD=1,NQUADA
DO I=1,NALYR
DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
  SOURCEFA(IQUAD,ITAU,M)%VRAD=0.0D0
ENDDO
SRCFAP(IQUAD,I,M)%VRAD=0.0D0
ENDDO
ENDDO

DO IQUAD=1,NQUADA
DO JQUAD=1,NQUADA
DO I=1,NALYR
  IMIE=ALYR(I)%IPT
  MTRX1=PMA(IQUAD,JQUAD,IMIE,M)%PHMX
  DO ITAU=ALYR(I)%ITAUS,ALYR(I)%ITAUE
     ARRY1=LSPMNA(JQUAD,ITAU,M)%VRAD
     ARRY2=MATMUL(MTRX1,ARRY1)
     SOURCEFA(IQUAD,ITAU,M)%VRAD= SOURCEFA(IQUAD,ITAU,M)%VRAD + &
                    0.5D0*ALYR(I)%LBDOM*WTA(JQUAD)*ARRY2
  ENDDO  ! LOOP SUBLAYERS
  IF(I==NALYR)THEN
    ITAU=ALYR(I)%ITAUE
  ELSE
    ITAU=ALYR(I)%ITAUE+1
  ENDIF
  ARRY1=LSPMNA(JQUAD,ITAU,M)%VRAD
  ARRY2=MATMUL(MTRX1,ARRY1)
  SRCFAP(IQUAD,I,M)%VRAD= SRCFAP(IQUAD,I,M)%VRAD + &
            0.5D0*ALYR(I)%LBDOM*WTA(JQUAD)*ARRY2

ENDDO   !LOOP ATMOSPHERE LAYERS FOR SOURCE FUCTION 
ENDDO !LOOP JQUAD
ENDDO   ! LOOP IQUAD

END SUBROUTINE SOURCEF_ATMOS

SUBROUTINE SOURCEF_OCEAN(M)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE SAVE_OCEAN_MOD
implicit none
INTEGER,INTENT(IN):: M
INTEGER :: IQUAD,JQUAD,I,IMIE,ITAU,ICOM
REAL*8,DIMENSION(4,4):: MTRX1
REAL*8,DIMENSION(4):: ARRY1,ARRY2

INTEGER :: IULO,MPL,KLO
REAL*8 :: RTMP,RTMP1,RTMP2
REAL*8,DIMENSION(:),ALLOCATABLE :: EXTARRYTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: SOURCEOTMP,SOURCEOM0TMP

REAL*8,DIMENSION(3)::QSRC,ELCOEFF
REAL*8 :: SQRTSIGN,TAUDIFF,TAUDIFF1,SRCTMP

  DO IQUAD=1,NQUADO
  DO I=1,NOLYR
    DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
      SOURCEFO(IQUAD,ITAU,M)%VRAD=0.0D0
    ENDDO
    SRCFOP(IQUAD,I,M)%VRAD=0.0D0
  ENDDO
  ENDDO

! FIND SOURCE FUNCTION FOR DIFFUSE LIGHT
  DO IQUAD=1,NQUADO
  DO JQUAD=1,NQUADO

  DO I=1,NOLYR
    IMIE=OLYR(I)%IPT
    MTRX1=PMO(IQUAD,JQUAD,IMIE,M)%PHMX
    DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
      ARRY1=LSPMNO(JQUAD,ITAU,M)%VRAD
      ARRY2=MATMUL(MTRX1,ARRY1)
      SOURCEFO(IQUAD,ITAU,M)%VRAD= SOURCEFO(IQUAD,ITAU,M)%VRAD + &
                       0.5D0*OLYR(I)%LBDOM*WTO(JQUAD)*ARRY2
    ENDDO  ! LOOP SUBLAYERS

    IF(I==NOLYR)THEN
      ITAU=OLYR(I)%ITAUE
    ELSE
      ITAU=OLYR(I)%ITAUE+1
    ENDIF
    ARRY1=LSPMNO(JQUAD,ITAU,M)%VRAD
    ARRY2=MATMUL(MTRX1,ARRY1)
    SRCFOP(IQUAD,I,M)%VRAD= SRCFOP(IQUAD,I,M)%VRAD + &
               0.5D0*OLYR(I)%LBDOM*WTO(JQUAD)*ARRY2
  ENDDO   !LOOP OCEAN LAYERS FOR SOURCE FUCTION 
  ENDDO !LOOP JQUAD
  ENDDO   ! LOOP IQUAD

ENDSUBROUTINE SOURCEF_OCEAN


SUBROUTINE SOURCEF_OCEAN_INELASTIC(M)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
USE SAVE_OCEAN_MOD
implicit none
INTEGER,INTENT(IN):: M
REAL*8, EXTERNAL :: POLINT_SIMPLE

INTEGER :: IQUAD,JQUAD,I,IMIE,ITAU,ICOM
REAL*8,DIMENSION(4,4):: MTRX1
REAL*8,DIMENSION(4):: ARRY1,ARRY2

INTEGER :: IULO,MPL,KLO
REAL*8 :: RTMP,RTMP1,RTMP2,RTMP3
REAL*8,DIMENSION(:),ALLOCATABLE :: EXTARRYTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: SOURCEOTMP,SOURCEOM0TMP

REAL*8,DIMENSION(3)::QSRC,ELCOEFF
REAL*8 :: SQRTSIGN,TAUDIFF,TAUDIFF1,SRCTMP

  DO IQUAD=1,NQUADO
  DO I=1,NOLYR
    DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
      SOURCEFO(IQUAD,ITAU,M)%VRAD=0.0D0
    ENDDO
    SRCFOP(IQUAD,I,M)%VRAD=0.0D0
  ENDDO
  ENDDO

IF((.NOT. RAMAN_SOURCE_FLAG) .AND. M>0)RETURN
! ASSUMES TAU_INELASTIC_AGD(1:NWATER_DEPTH) IS UNIFORM GRID FOR EXPONENTIAL - LINEAR INTERPOLATION
! IF NOT, NEED TO ADJUST.

ALLOCATE(EXTARRYTMP(OLYR(1)%ITAUS:OLYR(NOLYR)%ITAUE),&
         SOURCEOTMP(1:NWATER_DEPTH,1:4),SOURCEOM0TMP(1:NWATER_DEPTH,1:4))

MPL=2
DO I=1,NOLYR
DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
  RTMP1=TAU_PRSV(ITAU)-OITAU_PRSV
!  IULO=INT(FLOAT(NWATER_DEPTH)*ABS((RTMP1-TAU_INELASTIC_AGD(1))  &
!               /(TAU_INELASTIC_AGD(NWATER_DEPTH)-TAU_INELASTIC_AGD(1))))
!  call hunt(TAU_INELASTIC_AGD,NWATER_DEPTH,RTMP1,IULO)
!  KLO=min(max(IULO-(MPL-1)/2,1),NWATER_DEPTH-MPL)
!  CALL POLINT(TAU_INELASTIC_AGD(KLO),EXT_COEFF_INELASTIC_EM(KLO),MPL,RTMP1,EXTARRYTMP(ITAU),RTMP)

  EXTARRYTMP(ITAU)=POLINT_SIMPLE(NWATER_DEPTH,TAU_INELASTIC_AGD,EXT_COEFF_INELASTIC_EM,RTMP1,MPL)

  EXTARRYTMP(ITAU)=EXTARRYTMP(ITAU)*(1.0D0-LBDO_O_PRSV(I)*FTRUNC(OLYR(I)%IPT))
!  IF(EXTARRYTMP(ITAU)<0.0d0)THEN
!    write(*,*)'TSP1',itau,EXTARRYTMP(ITAU),TAU_INELASTIC_AGD(NWATER_DEPTH),RTMP1
!  ENDIF

ENDDO
ENDDO

DO IQUAD=1,NQUADO

  SOURCEOTMP=0.0D0
  SOURCEOM0TMP=0.0D0

  DO ITAU=1,NWATER_DEPTH
!write(*,*)'itau, tau_agd,ext_coeff_agd,RamanSource=',itau,TAU_INELASTIC_AGD(itau), &
!       EXT_COEFF_INELASTIC_EM(NWATER_DEPTH),SOURCEFO_RAMAN_AGD(IQUAD,ITAU,0)%VRAD(1)
   IF(RAMAN_SOURCE_FLAG)THEN
     DO ICOM=1,4
       SOURCEOTMP(ITAU,ICOM)  =SOURCEFO_RAMAN_AGD(IQUAD,ITAU,M)%VRAD(ICOM)
       SOURCEOM0TMP(ITAU,ICOM)=SOURCEFO_RAMAN_AGD(IQUAD,ITAU,0)%VRAD(ICOM)
!testing
!if(m==0 .and. icom==1 .and. iquad==1)then
!    rtmp=SOURCEOTMP(ITAU,ICOM)
!    write(*,*)'TSP2',TAU_INELASTIC_AGD(itau),rtmp
!endif
     ENDDO
   ENDIF

   IF(FLUORESCENCE_SOURCE_FLAG .AND. M==0)THEN
     SOURCEOTMP(ITAU,1)  =  SOURCEOTMP(ITAU,1)+SOURCEFO_FLUORESCENCE_AGD(ITAU)
     SOURCEOM0TMP(ITAU,1)=SOURCEOM0TMP(ITAU,1)+SOURCEFO_FLUORESCENCE_AGD(ITAU)
!testing
!if(iquad==1)then
!   rtmp=SOURCEOTMP(ITAU,1)
!   rtmp1=SOURCEFO_FLUORESCENCE_AGD(ITAU)
!   write(*,*)'TSP3',itau,rtmp,rtmp1
!endif

!write(*,*)'itau, tau_agd,ext_coeff_agd, FluoresenceSource=',itau,TAU_INELASTIC_AGD(itau), &
!EXT_COEFF_INELASTIC_EM(NWATER_DEPTH),SOURCEFO_FLUORESCENCE_AGD(ITAU)


   ENDIF
  ENDDO

DO I=1,NOLYR
DO ITAU=OLYR(I)%ITAUS,OLYR(I)%ITAUE
   RTMP1=TAU_PRSV(ITAU)-OITAU_PRSV
   IULO=INT(FLOAT(NWATER_DEPTH)*ABS((RTMP1-TAU_INELASTIC_AGD(1))  &
              /(TAU_INELASTIC_AGD(NWATER_DEPTH)-TAU_INELASTIC_AGD(1))))
   call hunt(TAU_INELASTIC_AGD,NWATER_DEPTH,RTMP1,IULO)
   KLO=min(max(IULO-(MPL-1)/2,1),NWATER_DEPTH-MPL)

   QSRC(1:3)=SOURCEOM0TMP(KLO:KLO+2,1)
   IF(QSRC(1)<1.0D-307 .OR. QSRC(2)<1.0D-307 .OR. QSRC(3)<1.0D-307)THEN
     SQRTSIGN=0.0D0
	 RTMP2=0.0D0
   ELSEIF(LOG(QSRC(2))-LOG(QSRC(3))>75.0d0 .OR. LOG(QSRC(1))-LOG(QSRC(3))>150.0d0)THEN
     SQRTSIGN=0.0D0
	 RTMP2=0.0D0
   ELSEIF(QSRC(1)<QSRC(2) .AND. QSRC(2)<QSRC(3))THEN
     SQRTSIGN=1.0D0
     RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   ELSE IF(QSRC(1)>QSRC(2) .AND. QSRC(2)>QSRC(3))THEN
     SQRTSIGN=-1.0D0
     RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   ELSE
     IF(VERBOSE_FLAG) WRITE(*,*)'SOURCEF_OCEAN_INELASTIC, Check 1, QSRC=',QSRC
     SQRTSIGN=0.0D0
     RTMP2=0.0D0
   ENDIF
   TAUDIFF=TAU_INELASTIC_AGD(KLO+2)-TAU_INELASTIC_AGD(KLO)

!   RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   IF(RTMP2<0.0D0)RTMP2=0.0D0
!testing inelastic source
!IF(QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)<=0)THEN
!rtmp=QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)
!write(*,*)'TSP4',itau,QSRC,rtmp,rtmp2
!ENDIF
   IF(QSRC(3)<1.0D-307)THEN
       RTMP3=0.0D0
   ELSE
       RTMP3=QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)
   ENDIF

   IF(ABS(SQRTSIGN)<1.0D-6 .OR. RTMP3<=0.0D0)THEN
     ELCOEFF(1)=0.0D0
   ELSE
     ELCOEFF(1)=2.0d0/TAUDIFF * LOG(RTMP3)
   ENDIF

   IF(ELCOEFF(1)>1.0D32)ELCOEFF(1)=0.0D0
   TAUDIFF1=RTMP1-TAU_INELASTIC_AGD(KLO)
   DO ICOM=1,4
! commented out on Oct. 13 for better stability
!      IF(QSRC(2)/QSRC(1)<1.0D-6 .OR. QSRC(3)/QSRC(2)<1.0D-6)THEN
!         ELCOEFF(1)=2.0D0*LOG(QSRC(1)/QSRC(2))/TAUDIFF
!         ELCOEFF(2)=0.0D0
!      ELSE
         ELCOEFF(2)=SOURCEOTMP(KLO+2,ICOM)*EXP(ELCOEFF(1)*TAUDIFF) - SOURCEOTMP(KLO,ICOM)
         ELCOEFF(2)=ELCOEFF(2)/TAUDIFF
!      ENDIF
      ELCOEFF(3)=SOURCEOTMP(KLO,ICOM)
      SRCTMP=EXP(-ELCOEFF(1)*TAUDIFF1)*(ELCOEFF(3)+ELCOEFF(2)*TAUDIFF1)
      SOURCEFO(IQUAD,ITAU,M)%VRAD(ICOM)= SOURCEFO(IQUAD,ITAU,M)%VRAD(ICOM) + &
                             SRCTMP/EXTARRYTMP(ITAU)

!testing
!if(m==0 .and. icom==1 .and. iquad==1)then
!   rtmp=SOURCEFO(IQUAD,ITAU,M)%VRAD(ICOM)
!   write(*,*)'TSP5',TAU_PRSV(ITAU)-OITAU_PRSV,SOURCEFO(IQUAD,ITAU,M)%VRAD(ICOM)
!ENDIF

   ENDDO

ENDDO
   IF(I==NOLYR)THEN
      ITAU=OLYR(I)%ITAUE
   ELSE
      ITAU=OLYR(I)%ITAUE+1
   ENDIF
   RTMP1=TAU_PRSV(ITAU)-OITAU_PRSV
   IULO=INT(FLOAT(NWATER_DEPTH)*ABS((RTMP1-TAU_INELASTIC_AGD(1))  &
              /(TAU_INELASTIC_AGD(NWATER_DEPTH)-TAU_INELASTIC_AGD(1))))
   call hunt(TAU_INELASTIC_AGD,NWATER_DEPTH,RTMP1,IULO)
   KLO=min(max(IULO-(MPL-1)/2,1),NWATER_DEPTH-MPL)

   QSRC(1:3)=SOURCEOM0TMP(KLO:KLO+2,1)
   IF(QSRC(1)<1.0D-307 .OR. QSRC(2)<1.0D-307 .OR. QSRC(3)<1.0D-307)THEN
        SQRTSIGN=0.0D0
        RTMP2=0.0D0
   ELSEIF(LOG(QSRC(2))-LOG(QSRC(3))>150 .OR. LOG(QSRC(1))-LOG(QSRC(3))>300)THEN
        SQRTSIGN=0.0D0
        RTMP2=0.0D0
   ELSEIF(QSRC(1)<QSRC(2) .AND. QSRC(2)<QSRC(3))THEN
     SQRTSIGN=1.0D0
     RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   ELSE IF(QSRC(1)>QSRC(2) .AND. QSRC(2)>QSRC(3))THEN
     SQRTSIGN=-1.0D0
     RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   ELSE
     IF(VERBOSE_FLAG) WRITE(*,*)'SOURCEF_OCEAN_INELASTIC, Check 2, QSRC=',QSRC
     SQRTSIGN=0.0D0
     RTMP2=0.0D0
   ENDIF
   TAUDIFF=TAU_INELASTIC_AGD(KLO+2)-TAU_INELASTIC_AGD(KLO)
!   RTMP2=(QSRC(2)/QSRC(3))**2-QSRC(1)/QSRC(3)
   IF(RTMP2<0.0D0)RTMP2=0.0D0
!testing inelastic source
!IF(QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)<=0)THEN
!rtmp=QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)
!write(*,*)'TSP6',itau,QSRC,rtmp,rtmp2
!ENDIF
   IF(QSRC(3)<1.0D-307)THEN
       RTMP3=0.0D0
   ELSE
       RTMP3=QSRC(2)/QSRC(3) + SQRTSIGN*SQRT(RTMP2)
   ENDIF

   IF(ABS(SQRTSIGN)<1.0D-6 .OR. RTMP3<=0.0D0)THEN
       ELCOEFF(1)=0.0D0
   ELSE
       ELCOEFF(1)=2.0d0/TAUDIFF * LOG(RTMP3)
   ENDIF
   IF(ELCOEFF(1)>1.0D32)ELCOEFF(1)=0.0D0
   TAUDIFF1=RTMP1-TAU_INELASTIC_AGD(KLO)
   DO ICOM=1,4
! commented out on Oct. 13 for better stability
!      IF(QSRC(2)/QSRC(1)<1.0D-6 .OR. QSRC(3)/QSRC(2)<1.0D-6)THEN
!         ELCOEFF(1)=2.0D0*LOG(QSRC(1)/QSRC(2))/TAUDIFF
!         ELCOEFF(2)=0.0D0
!      ELSE
         ELCOEFF(2)=SOURCEOTMP(KLO+2,ICOM)*EXP(ELCOEFF(1)*TAUDIFF) - SOURCEOTMP(KLO,ICOM)
         ELCOEFF(2)=ELCOEFF(2)/TAUDIFF
!      ENDIF
      ELCOEFF(3)=SOURCEOTMP(KLO,ICOM)
      SRCTMP=EXP(-ELCOEFF(1)*TAUDIFF1)*(ELCOEFF(3)+ELCOEFF(2)*TAUDIFF1)

      SRCFOP(IQUAD,I,M)%VRAD(ICOM)= SRCFOP(IQUAD,I,M)%VRAD(ICOM) + &
                             SRCTMP/EXTARRYTMP(ITAU)

!testing
!if(m==0 .and. icom==1)then
!  rtmp=SRCFOP(IQUAD,I,M)%VRAD(ICOM)
!  write(*,*)'TSP7',TAU_PRSV(ITAU)-OITAU_PRSV,SRCFOP(IQUAD,I,M)%VRAD(ICOM)
!  stop
!endif
   ENDDO

ENDDO
ENDDO
DEALLOCATE(EXTARRYTMP)
DEALLOCATE(SOURCEOTMP,SOURCEOM0TMP)
ENDSUBROUTINE SOURCEF_OCEAN_INELASTIC


SUBROUTINE IRRAD_UPDATE(IRRAD_SNGL,IRRAD_A_SNGL,IRRAD_O_SNGL,IRRAD,IRRAD_A,IRRAD_O)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

REAL(DP),DIMENSION(4),INTENT(IN) :: IRRAD_SNGL,IRRAD_O_SNGL,IRRAD_A_SNGL
REAL(DP),DIMENSION(4),INTENT(OUT) ::IRRAD,IRRAD_O,IRRAD_A

INTEGER :: JQUAD,ITAU

IRRAD=0.0D0
IRRAD_A=0.0D0
IRRAD_O=0.0D0
  
IF((.NOT. OCEAN) .AND. LAMB)THEN
  ITAU=ALYR(NALYR)%ITAUE
  DO JQUAD=1,NQDAD2
    IRRAD(1)=IRRAD(1)+2.0D0*GLBDO*WTA(JQUAD)*  &
		LSPA(JQUAD,ITAU,0)%VRAD(1)*DABS(XJA(JQUAD))
  ENDDO
ENDIF

IF(OCEAN .AND. LAMB)THEN
  DO JQUAD=1,NQDOD2
    IRRAD(1)=IRRAD(1)+2.0D0*GLBDO*WTO(JQUAD)*  &
		LSPO(JQUAD,NTTAU,0)%VRAD(1)*DABS(XJO(JQUAD))
  ENDDO
ENDIF

IF(OCEAN .AND. (WCFLG .OR. RSRADDFLG))THEN
    ITAU=ALYR(NALYR)%ITAUE
    DO JQUAD=1,NQDAD2
      IRRAD_A(1)=IRRAD_A(1)+2.0D0*WTA(JQUAD)*  &
			LSPA(JQUAD,ITAU,0)%VRAD(1)*DABS(XJA(JQUAD))
    ENDDO

    IF(.NOT.OCEAN_NO_TRAN)THEN
      ITAU=OLYR(1)%ITAUS
      DO JQUAD=NQDOD2+1,NQUADO
        IRRAD_O(1)=IRRAD_O(1)+2.0D0*WTO(JQUAD)*  &
	       LSPO(JQUAD,ITAU,0)%VRAD(1)*DABS(XJO(JQUAD))
      ENDDO
    ENDIF
ENDIF
IRRAD=IRRAD+IRRAD_SNGL
IRRAD_A=IRRAD_A+IRRAD_A_SNGL
IRRAD_O=IRRAD_O+IRRAD_O_SNGL

END SUBROUTINE IRRAD_UPDATE

SUBROUTINE pBRDM_LAND(COST1,PHI1,COST2,PHI2,BRDML)
USE RTUTILITY, only : PI,SCL,NMBRE,NMBIM,pBRDFa,pBRDFk,pBRDFb,pBRDFe
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BRDML

REAL*8 :: SINT1,SINT2,COST,THETA1,THETA2,SHDWFCT,&
          SPHI,FPHI,SA,SB,SC,FA,FB,FC,NTGFCT,RTMP
REAL*8,DIMENSION(4,4) :: TEM1,TEM2,FRES_MTRX,SLI1,SLI2
SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)

COST=COST1*COST2+SINT1*SINT2*DCOS(PHI2-PHI1)
IF(DABS(COST)>1.0D0)COST=COST/ABS(COST)

SHDWFCT= 2.0D0/(1.0D0/ABS(COST1)+1.0d0/ABS(COST2)) ! 1.0d0

NTGFCT=0.25D0*pBRDFe*SHDWFCT/ABS(COST2)
! DESERT SURFACE AS IN LENOBLE, JQSRT, 107, 479-507 (2007)

! NTGFCT=0.25D0*pBRDFe*ABS(COST1)/(ABS(COST1)+ABS(COST2))
! VEGETATION SURFACE AS IN LENOBLE

THETA1=(PI-DACOS(COST))/2.0d0
THETA2=THETA1

CALL FRSNL_R2(NMBRE,NMBIM,THETA1,FRES_MTRX)

SPHI=PHI1
FPHI=PHI2
SA=SINT1*COS(SPHI)
SB=SINT1*SIN(SPHI)
SC=COST1

FA=SINT2*COS(FPHI)
FB=SINT2*SIN(FPHI)
FC=COST2

CALL RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
TEM2=MATMUL(FRES_MTRX,SLI1)
TEM1=MATMUL(SLI2,TEM2)
BRDML=TEM1*NTGFCT

BRDML(3,1)=-BRDML(3,1)
BRDML(3,2)=-BRDML(3,2)
BRDML(4,1)=-BRDML(4,1)
BRDML(4,2)=-BRDML(4,2)

BRDML(1,1)=BRDML(1,1)+pBRDFa*ABS(COST1)*exp(pBRDFb*COST)* &
       (ABS(COST1*COST2)*(ABS(COST1)+ABS(COST2)))**(pBRDFk-1)
IF(SCL)THEN
  RTMP=BRDML(1,1)
  BRDML=0.0D0
  BRDML(1,1)=RTMP
ENDIF
END SUBROUTINE pBRDM_LAND


SUBROUTINE BRDM_OCEAN(COST1,PHI1,COST2,PHI2,NWRE,NWIM,BRDMO)
USE RTUTILITY, only : SIGMASQ,SHDWFLG,PI,SCL
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NWRE,NWIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BRDMO

REAL*8 :: SINT1,SINT2,CAPA,MUDIFFSQ,LITA,LITB,SHDWFCT,EXPBA,&
          MUNSQINV,COST,NTGFCT,THETA1,THETA2,SPHI,FPHI,SA,SB,SC,&
          FA,FB,FC,RTMP
REAL*8,DIMENSION(4,4) :: TEM1,TEM2,FRES_MTRX,SLI1,SLI2

REAL*8 :: SHADOW
  IF(COST1*COST2>0.0D0)THEN
      BRDMO=0.0D0
      RETURN
  ENDIF
  SINT1=DSQRT(1.0D0-COST1*COST1)
  SINT2=DSQRT(1.0D0-COST2*COST2)
  CAPA=0.25D0/SIGMASQ/ABS(COST2)

  MUDIFFSQ=(COST2-COST1)*(COST2-COST1)

  LITA=(SINT1*SINT1+SINT2*SINT2)/SIGMASQ/MUDIFFSQ
  LITB=2.0D0*SINT1*SINT2/SIGMASQ/MUDIFFSQ
  IF(SHDWFLG)THEN
    SHDWFCT=1.0D0/(1.0D0+SHADOW(COST1,SIGMASQ)+SHADOW(COST2,SIGMASQ))
  ELSE
    SHDWFCT=1.0D0
  ENDIF

  EXPBA=exp(LITB-LITA)

  COST=COST1*COST2+SINT1*SINT2*DCOS(PHI2-PHI1)
  IF(DABS(COST)>1.0D0)COST=COST/ABS(COST)
  MUNSQINV=2.0D0*(1.0D0-COST)/MUDIFFSQ

  NTGFCT=MUNSQINV*MUNSQINV*CAPA*&
            EXP(-(MUNSQINV-1.0D0)/SIGMASQ)*SHDWFCT

  THETA1=(PI-DACOS(COST))/2.0d0
  THETA2=THETA1

  CALL FRSNL_R2(NWRE,NWIM,THETA1,FRES_MTRX)
  IF(SCL)THEN
    BRDMO=0.0D0
    BRDMO(1,1)=FRES_MTRX(1,1)*NTGFCT
    RETURN
  ENDIF
  SPHI=PHI1
  FPHI=PHI2
  SA=SINT1*COS(SPHI)
  SB=SINT1*SIN(SPHI)
  SC=COST1
  
  FA=SINT2*COS(FPHI)
  FB=SINT2*SIN(FPHI)
  FC=COST2

  CALL RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
  TEM2=MATMUL(FRES_MTRX,SLI1)
  TEM1=MATMUL(SLI2,TEM2)
  BRDMO=TEM1*NTGFCT
      
  BRDMO(3,1)=-BRDMO(3,1)
  BRDMO(3,2)=-BRDMO(3,2)
  BRDMO(4,1)=-BRDMO(4,1)
  BRDMO(4,2)=-BRDMO(4,2)


END SUBROUTINE BRDM_OCEAN


SUBROUTINE BRDM_DS_OCEAN(COST1,PHI1,COST2,PHI2,NWRE,NWIM,BRDMO)
USE RTUTILITY, only : PI,SCL
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NWRE,NWIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BRDMO

INTEGER :: NUMPHI,NUMXJ,IPHI,IXJ
REAL*8,DIMENSION(:),ALLOCATABLE :: XJINT,WJINT,PHI,WPHI

REAL*8,DIMENSION(4,4) :: TEM1,TEM2
  NUMPHI=40
  NUMXJ=40
  ALLOCATE(XJINT(NUMXJ),WJINT(NUMXJ),PHI(NUMPHI),WPHI(NUMPHI))
  CALL gauleg(-PI/6,PI/6,PHI,WPHI,NUMPHI)
  CALL gauleg(-0.4D0,0.4D0,XJINT,WJINT,NUMXJ)
  BRDMO=0.0D0
  DO IPHI=1,NUMPHI
  DO IXJ=1,NUMXJ
   
     CALL BRDM_OCEAN(COST1,PHI1,XJINT(IXJ),PHI1+PHI(IPHI),NWRE,NWIM,TEM1)
     CALL BRDM_OCEAN(XJINT(IXJ),PHI1+PHI(IPHI),COST2,PHI2,NWRE,NWIM,TEM2)
     IF(SCL)THEN
       BRDMO(1,1)=BRDMO(1,1)+TEM2(1,1)*TEM1(1,1)*WJINT(IXJ)*WPHI(IPHI)
     ELSE
       BRDMO=BRDMO+MATMUL(TEM2,TEM1)*WJINT(IXJ)*WPHI(IPHI)
     ENDIF
  ENDDO
  ENDDO
  BRDMO=BRDMO/PI

DEALLOCATE(XJINT,WJINT,PHI,WPHI)
END SUBROUTINE BRDM_DS_OCEAN


SUBROUTINE BTDM_AT_OCEAN(COST1,PHI1,COST2,PHI2,NWRE,NWIM,BTDMO)
USE RTUTILITY, only : SIGMASQ,SHDWFLG,NSQW,PI,SCL
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NWRE,NWIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BTDMO

REAL*8 :: SINT1,SINT2,CAPA,MUDIFFSQ,LITA,LITB,SHDWFCT,EXPBA,&
          MUNSQINV,COST,NTGFCT,THETA1,THETA2,SPHI,FPHI,SA,SB,SC,&
          FA,FB,FC,TWOCOS,COSINOM,COSTNOM,RTMP,RTMP1,RTMP2
REAL*8,DIMENSION(4,4) :: TEM1,TEM2,FRES_MTRX,SLI1,SLI2

REAL*8 :: SHADOW

MUDIFFSQ=COST1-NWRE*COST2
SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)

MUDIFFSQ=MUDIFFSQ*MUDIFFSQ

IF(MUDIFFSQ<1.0D-24)THEN
  BTDMO=0.0D0
  RETURN
ENDIF

CAPA=NSQW/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
TWOCOS=1.0D0-COST1*COST1+NSQW*(1.0D0-COST2*COST2)
LITA=TWOCOS/SIGMASQ/MUDIFFSQ
LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ

IF(SHDWFLG)THEN
!    SHDWFCT=beta(1.0D0+SHADOW(COST1,SIGMASQ),1.0d0+SHADOW(COST2,SIGMASQ))
!test shadowing fucntion
   SHDWFCT=1.0d0/(1.0D0+SHADOW(COST1,SIGMASQ)+SHADOW(COST2,SIGMASQ))
ELSE
   SHDWFCT=1.0D0
ENDIF

EXPBA=EXP(LITB-LITA)
COST=COST1*COST2+SINT1*SINT2*DCOS(PHI2-PHI1)
IF(DABS(COST)>1.0D0)COST=COST/ABS(COST)
COSINOM=NWRE*COST-1.0D0
IF(COSINOM<0.0D0)THEN
  BTDMO=0.0D0
  RETURN
ENDIF
COSTNOM=NWRE-COST
RTMP=NSQW+1.0D0-2.0D0*NWRE*COST
MUNSQINV=RTMP/MUDIFFSQ

NTGFCT=SHDWFCT*COSINOM*COSTNOM*CAPA    &
			 *EXP(-(MUNSQINV-1.0D0)/SIGMASQ)

RTMP=SQRT(RTMP)
RTMP1=COSINOM/RTMP
RTMP2=COSTNOM/RTMP
IF(ABS(RTMP1)>1.0D0)RTMP1=RTMP1/ABS(RTMP1)
IF(ABS(RTMP2)>1.0D0)RTMP2=RTMP2/ABS(RTMP2)
THETA1=ACOS(RTMP1)
THETA2=ACOS(RTMP2)
CALL FRSNL_T2(NWRE,NWIM,THETA1,FRES_MTRX)
IF(SCL)THEN
  BTDMO=0.0D0
  BTDMO(1,1)=FRES_MTRX(1,1)*NTGFCT
  RETURN
ENDIF

SPHI=PHI1
FPHI=PHI2
SA=SINT1*COS(SPHI)
SB=SINT1*SIN(SPHI)
SC=COST1
 
FA=SINT2*COS(FPHI)
FB=SINT2*SIN(FPHI)
FC=COST2

CALL RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
TEM2=MATMUL(FRES_MTRX,SLI1)
TEM1=MATMUL(SLI2,TEM2)
BTDMO=TEM1*NTGFCT

BTDMO(3,1)=-BTDMO(3,1)
BTDMO(3,2)=-BTDMO(3,2)
BTDMO(4,1)=-BTDMO(4,1)
BTDMO(4,2)=-BTDMO(4,2)

END SUBROUTINE BTDM_AT_OCEAN

SUBROUTINE BTDM_DS_AT_OCEAN(COST1,PHI1,COST2,PHI2,NRELRE,NRELIM,BTDMO)
USE RTUTILITY, only : PI,NWRE,NWIM,SCL
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NRELRE,NRELIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BTDMO

INTEGER :: NUMPHI,NUMXJ,IPHI,IXJ
REAL*8,DIMENSION(:),ALLOCATABLE :: XJINT,WJINT,PHI,WPHI

REAL*8,DIMENSION(4,4) :: TEM1,TEM2
  NUMPHI=40
  NUMXJ=40
  ALLOCATE(XJINT(NUMXJ),WJINT(NUMXJ),PHI(NUMPHI),WPHI(NUMPHI))
  CALL gauleg(-PI/6,PI/6,PHI,WPHI,NUMPHI)
  CALL gauleg(-0.4D0,0.4D0,XJINT,WJINT,NUMXJ)

  BTDMO=0.0D0
  DO IPHI=1,NUMPHI
  DO IXJ=1,NUMXJ
   
     CALL BTDM_AT_OCEAN(COST1,PHI1,XJINT(IXJ),PHI1+PHI(IPHI),NWRE,NWIM,TEM1)
     CALL BRDM_OCEAN(XJINT(IXJ),PHI1+PHI(IPHI),COST2,PHI2,NRELRE,NRELIM,TEM2)
     IF(SCL)THEN
       BTDMO(1,1)=BTDMO(1,1)+TEM2(1,1)*TEM1(1,1)*WJINT(IXJ)*WPHI(IPHI)
     ELSE
       BTDMO=BTDMO+MATMUL(TEM2,TEM1)*WJINT(IXJ)*WPHI(IPHI)
     ENDIF
  ENDDO
  ENDDO
  BTDMO=BTDMO/PI
DEALLOCATE(XJINT,WJINT,PHI,WPHI)
END SUBROUTINE BTDM_DS_AT_OCEAN

SUBROUTINE BTDM_OT_OCEAN(COST1,PHI1,COST2,PHI2,NRELRE,NRELIM,BTDMO)
USE RTUTILITY, only : SIGMASQ,SHDWFLG,NSQW,NWRE,PI,SCL
IMPLICIT none
REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NRELRE,NRELIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BTDMO

REAL*8 :: SINT1,SINT2,CAPA,MUDIFFSQ,LITA,LITB,SHDWFCT,EXPBA,&
          MUNSQINV,COST,NTGFCT,THETA1,THETA2,SPHI,FPHI,SA,SB,SC,&
          FA,FB,FC,TWOCOS,COSINOM,COSTNOM,RTMP,RTMP1,RTMP2
REAL*8,DIMENSION(4,4) :: TEM1,TEM2,FRES_MTRX,SLI1,SLI2

REAL*8 :: SHADOW

MUDIFFSQ=NWRE*COST1-COST2
IF(MUDIFFSQ<1.0D-12)THEN
  BTDMO=0.0D0
  RETURN
ENDIF
SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)

MUDIFFSQ=MUDIFFSQ*MUDIFFSQ
CAPA=1.0D0/SIGMASQ/ABS(COST2)/(MUDIFFSQ*MUDIFFSQ)
TWOCOS=NSQW*(1.0D0-COST1*COST1)+(1.0D0-COST2*COST2)
LITA=TWOCOS/SIGMASQ/MUDIFFSQ
LITB=2.0D0*NWRE*SINT1*SINT2/SIGMASQ/MUDIFFSQ

  IF(SHDWFLG)THEN
!     SHDWFCT=beta(1.0D0+SHADOW(COST1,SIGMASQ),1.0d0+SHADOW(COST2,SIGMASQ))
     SHDWFCT=1.0d0/(1.0D0+SHADOW(COST1,SIGMASQ)+SHADOW(COST2,SIGMASQ) )
  ELSE
     SHDWFCT=1.0D0
  ENDIF
  EXPBA=EXP(LITB-LITA)
  COST=COST1*COST2+SINT1*SINT2*DCOS(PHI2-PHI1)
     IF(DABS(COST)>1.0D0)COST=COST/ABS(COST)
     COSTNOM=NWRE*COST-1.0D0
	 IF(COSTNOM<0.0D0)THEN
       BTDMO=0.0D0
       RETURN
     ENDIF
     COSINOM=NWRE-COST
	 RTMP=NSQW+1.0D0-2.0D0*NWRE*COST
     MUNSQINV=RTMP/MUDIFFSQ

     NTGFCT=SHDWFCT*COSINOM*COSTNOM*CAPA    &
			 *EXP(-(MUNSQINV-1.0D0)/SIGMASQ)

	 RTMP=SQRT(RTMP)
     RTMP1=COSINOM/RTMP
     RTMP2=COSTNOM/RTMP

     IF(ABS(RTMP1)>1.0D0)RTMP1=RTMP1/ABS(RTMP1)
     IF(ABS(RTMP2)>1.0D0)RTMP2=RTMP2/ABS(RTMP2)

     THETA1=ACOS(RTMP1)
     THETA2=ACOS(RTMP2)
     CALL FRSNL_T2(NRELRE,NRELIM,THETA1,FRES_MTRX)
IF(SCL)THEN
  BTDMO=0.0D0
  BTDMO(1,1)=FRES_MTRX(1,1)*NTGFCT
  RETURN
ENDIF
     SPHI=PHI1
     FPHI=PHI2
     SA=SINT1*COS(SPHI)
     SB=SINT1*SIN(SPHI)
     SC=COST1
 
     FA=SINT2*COS(FPHI)
     FB=SINT2*SIN(FPHI)
     FC=COST2

     CALL RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
     TEM2=MATMUL(FRES_MTRX,SLI1)
     TEM1=MATMUL(SLI2,TEM2)
     BTDMO=TEM1*NTGFCT
     
BTDMO(3,1)=-BTDMO(3,1)
BTDMO(3,2)=-BTDMO(3,2)
BTDMO(4,1)=-BTDMO(4,1)
BTDMO(4,2)=-BTDMO(4,2)

END SUBROUTINE BTDM_OT_OCEAN

SUBROUTINE BTDM_DS_OT_OCEAN(COST1,PHI1,COST2,PHI2,NRELRE,NRELIM,BTDMO)
USE RTUTILITY, only : PI,NWRE,NWIM,SCL
IMPLICIT none

REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2,NRELRE,NRELIM
REAL*8,DIMENSION(4,4),INTENT(OUT) :: BTDMO

INTEGER :: NUMPHI,NUMXJ,IPHI,IXJ
REAL*8,DIMENSION(:),ALLOCATABLE :: XJINT,WJINT,PHI,WPHI

REAL*8,DIMENSION(4,4) :: TEM1,TEM2
  NUMPHI=40
  NUMXJ=40
  ALLOCATE(XJINT(NUMXJ),WJINT(NUMXJ),PHI(NUMPHI),WPHI(NUMPHI))
  CALL gauleg(-PI/6,PI/6,PHI,WPHI,NUMPHI)
  CALL gauleg(-0.4D0,0.4D0,XJINT,WJINT,NUMXJ)

  BTDMO=0.0D0
  DO IPHI=1,NUMPHI
  DO IXJ=1,NUMXJ
   
     CALL BTDM_OT_OCEAN(COST1,PHI1,XJINT(IXJ),PHI1+PHI(IPHI),NRELRE,NRELIM,TEM1)
     CALL BRDM_OCEAN(XJINT(IXJ),PHI1+PHI(IPHI),COST2,PHI2,NWRE,NWIM,TEM2)
     IF(SCL)THEN
       BTDMO(1,1)=BTDMO(1,1)+TEM2(1,1)*TEM1(1,1)*WJINT(IXJ)*WPHI(IPHI)
     ELSE
       BTDMO=BTDMO+MATMUL(TEM2,TEM1)*WJINT(IXJ)*WPHI(IPHI)
     ENDIF
  ENDDO
  ENDDO
  BTDMO=BTDMO/PI
DEALLOCATE(XJINT,WJINT,PHI,WPHI)

END SUBROUTINE BTDM_DS_OT_OCEAN

SUBROUTINE FWDCN_CONFIG(MU_IN)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
REAL*8,INTENT(IN) :: MU_IN

INTEGER :: IMU,IPHI
REAL*8 :: RTMP,THETA_IN
REAL*8,DIMENSION(3,3):: MTRX_LCL2GLB
REAL*8,DIMENSION(3):: VEC1,VEC2

REAL*8,DIMENSION(NMUFWDCN):: WMU_LCL
REAL*8,DIMENSION(NPHIFWDCN):: WPHI_LCL

REAL*8 :: PHI_UPDT

THETA_IN=ACOS(MU_IN)
MUFWDCN_LCL=0.0D0

RTMP=0.01D0
DO IMU=2,11
  MUFWDCN_LCL(IMU)=MUFWDCN_LCL(IMU-1)+RTMP
ENDDO
RTMP=0.02D0
DO IMU=12,26
  MUFWDCN_LCL(IMU)=MUFWDCN_LCL(IMU-1)+RTMP
ENDDO
RTMP=0.2D0
DO IMU=27,29
  MUFWDCN_LCL(IMU)=MUFWDCN_LCL(IMU-1)+RTMP
ENDDO
RTMP=1.0D0
DO IMU=30,NMUFWDCN
  MUFWDCN_LCL(IMU)=MUFWDCN_LCL(IMU-1)+RTMP
ENDDO
MUFWDCN_LCL=COS(MUFWDCN_LCL*FACTOR)

MINMUFWDCN=MUFWDCN_LCL(NMUFWDCN)

WMU_LCL(1)=0.5D0*ABS(MUFWDCN_LCL(1)-MUFWDCN_LCL(2))
DO IMU=2,NMUFWDCN-1
  WMU_LCL(IMU)=0.5D0* ABS(MUFWDCN_LCL(IMU-1)-MUFWDCN_LCL(IMU+1))
ENDDO
WMU_LCL(NMUFWDCN)=0.5D0*ABS(MUFWDCN_LCL(NMUFWDCN) - MUFWDCN_LCL(NMUFWDCN-1))

RTMP=TWOPI/(1.0D0*NPHIFWDCN)
DO IPHI=1,NPHIFWDCN
  PHIFWDCN_LCL(IPHI)=(IPHI-1)*RTMP
ENDDO
WPHI_LCL=RTMP

MTRX_LCL2GLB=0.0D0
MTRX_LCL2GLB(2,2)=1.0D0
MTRX_LCL2GLB(1,1)=-SIN(1.5D0*PI-THETA_IN)
MTRX_LCL2GLB(1,3)=SQRT(1.0D0-MU_IN*MU_IN)
MTRX_LCL2GLB(3,1)=COS(1.5D0*PI-THETA_IN)
MTRX_LCL2GLB(3,3)=MU_IN

DO IPHI=1,NPHIFWDCN
DO IMU=1,NMUFWDCN
  RTMP=SQRT(ABS(1.0D0-MUFWDCN_LCL(IMU)*MUFWDCN_LCL(IMU)))
  VEC1(1)=RTMP*COS(PHIFWDCN_LCL(IPHI))
  VEC1(2)=RTMP*SIN(PHIFWDCN_LCL(IPHI))
  VEC1(3)=MUFWDCN_LCL(IMU)

  VEC2=MATMUL(MTRX_LCL2GLB,VEC1)
  MUFWDCN(IMU,IPHI)=VEC2(3)
  PHIFWDCN(IMU,IPHI)=PHI_UPDT(VEC2)

ENDDO
ENDDO

ALLOCATE(LRADA_FWDCN_SNG(1:NMUFWDCN,0:NALYR,1:NPHIFWDCN))

ENDSUBROUTINE FWDCN_CONFIG

REAL*8 FUNCTION PHI_UPDT(VECTOR3)
USE RTTYPE
implicit none
REAL*8,DIMENSION(3),INTENT(IN)::VECTOR3

IF(ABS(VECTOR3(1))<TINY1 .AND. ABS(VECTOR3(2))<TINY1) THEN
     PHI_UPDT=0.0d0
     RETURN
ENDIF

IF(ABS(VECTOR3(1))<TINY1)THEN
  IF(VECTOR3(2)>0.0D0) THEN
      PHI_UPDT=PI/2.0D0
  ELSE IF(VECTOR3(2)<0.0D0)THEN
      PHI_UPDT=3.0D0*PI/2.0D0
  ENDIF
      RETURN
ENDIF

IF (VECTOR3(1)<0.0d0) THEN
      PHI_UPDT=PI+ATAN(VECTOR3(2)/VECTOR3(1))
ELSE IF (VECTOR3(2)>=0.0d0) THEN
      PHI_UPDT=ATAN(VECTOR3(2)/VECTOR3(1))
ELSE IF (VECTOR3(2)<0.0d0) THEN
     PHI_UPDT=TWOPI+ATAN(VECTOR3(2)/VECTOR3(1))
ENDIF
IF(PHI_UPDT>TWOPI)PHI_UPDT=PHI_UPDT-TWOPI
IF(ABS(PHI_UPDT-TWOPI)<TINY1)PHI_UPDT=0.0d0

END FUNCTION PHI_UPDT


SUBROUTINE SNGL_FWDCN_CRRCT_ATMOS(MU_IN)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
REAL*8,INTENT(IN) :: MU_IN

!TYPE(ARRAY4),DIMENSION(:,:,:,:),ALLOCATABLE :: SUNGLTA

INTEGER :: IMIE,I,IPHI,ITHETA,ILAYER
REAL*8 :: RTMP, RTMP1,RTMP2,COST1,COST2,PHI1,PHI2,MUSCAT,&
          SINT1,SINT2
REAL*8,DIMENSION(4)   :: ARRY1,ARRY2
REAL*8,DIMENSION(4,4) :: MTRX1
!LOGICAL :: DIFF_FLG

!INTEGER :: NUMPHI,IPHI_TMP
!REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP

REAL*8 :: RADCORR

DO I=1,4
  LRADA_FWDCN_SNG(1:NMUFWDCN,0:NALYR,1:NPHIFWDCN)%VRAD(I)=0.0D0
ENDDO

DO IPHI=1,NPHIFWDCN
DO ITHETA=1,NMUFWDCN

IF(MUFWDCN(ITHETA,IPHI)>0.0D0)CYCLE

DO I=1,NALYR
  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT

  CALL PHASE_MATRIX_CALC(MU_IN,0.0d0,MUFWDCN(ITHETA,IPHI),&
                         PHIFWDCN(ITHETA,IPHI),IMIE,MTRX1)
  MTRX1=LBDO_A_PRSV(I)*MTRX1/(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))

  ARRY2=MATMUL(MTRX1,ARRY1)
  ! convention sign changes.
  ARRY2(3)=-ARRY2(3)
  ARRY2(4)=-ARRY2(4)
  
  IF(SCL) ARRY2(2:4)=0.0D0
  
  RTMP2= EXP(-(ALYR(I)%TAUT-ALYR(I)%TAUB)/DABS(MUFWDCN(ITHETA,IPHI)))

  IF(ABS(MUFWDCN(ITHETA,IPHI)-MU_IN)<TINY2)THEN

    LRADA_FWDCN_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
      RTMP2*LRADA_FWDCN_SNG(ITHETA,I-1,IPHI)%VRAD(:)   +          &
           EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I)) *          &
      (ALYR(I)%TAUT-ALYR(I)%TAUB)/DABS(MUFWDCN(ITHETA,IPHI))* ARRY2(:)

  ELSE

    RTMP=-MU_IN/(MUFWDCN(ITHETA,IPHI)-MU_IN)
    RTMP1=ALYR(I)%TAUT-ALYR(I)%TAUB

    LRADA_FWDCN_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
      RTMP2*LRADA_FWDCN_SNG(ITHETA,I-1,IPHI)%VRAD(:) + &
        RTMP * EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I))*(1.0D0 -    &
          EXP(-RTMP1* (1.0D0/MU_IN-1.0D0/MUFWDCN(ITHETA,IPHI))) ) * ARRY2(:)


!    LRADA_FWDCN_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
!      RTMP2*LRADA_FWDCN_SNG(ITHETA,I-1,IPHI)%VRAD(:) + &
!                    RTMP * (EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I)) -    &
!      EXP(RTMP1/MUFWDCN(ITHETA,IPHI))*EXP(-ALYR(I)%TAUB*SECANT_THETAL_PRSV(I-1))) * ARRY2(:)

  ENDIF

ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0
ENDDO
ENDDO

IF(SEC_RAD_CORR .AND. FWDCN_CORR_FLAG)THEN
DO IPHI=1,NPHIFWDCN
DO ITHETA=1,NMUFWDCN
DO ILAYER=1,NALYR
  COST1=MU_IN
  COST2=MUFWDCN(ITHETA,IPHI)
  PHI1=0.0D0
  PHI2=PHIFWDCN(ITHETA,IPHI)
  SINT1=SQRT(1.0D0-COST1*COST1)
  SINT2=SQRT(1.0D0-COST2*COST2)
  MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI2-PHI1)

  CALL DBLE_SCAT_CORR_FWDCN(ILAYER,COST1,PHI1,COST2,PHI2,RADCORR)

  LRADA_FWDCN_SNG(ITHETA,ILAYER,IPHI)%VRAD(1)=         &
       LRADA_FWDCN_SNG(ITHETA,ILAYER,IPHI)%VRAD(1) - RADCORR

ENDDO
ENDDO
ENDDO
ENDIF ! SEC_RAD_CORR OPTION NAKAJIMA FORWARD PEAK CORRECTIOIN

END SUBROUTINE SNGL_FWDCN_CRRCT_ATMOS

SUBROUTINE RAD_FWDCN_SEARCH(MU_IN,COSTRST,PHIRST,VRADRST)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
implicit none
REAL*8,INTENT(IN) :: MU_IN
REAL*8,INTENT(IN)::COSTRST,PHIRST
REAL*8,DIMENSION(4),INTENT(OUT)::VRADRST

INTEGER :: IMU,IPHI,IPHI1
REAL*8,DIMENSION(3,3):: MTRX_GLB2LCL
REAL*8,DIMENSION(3):: VEC1,VEC2
REAL*8 :: SINTRST,PHILCL,MULCL,WT1,WT2,WT3,WT4

REAL*8 :: PHI_UPDT,RTMP,THETA_IN

THETA_IN=ACOS(MU_IN)

SINTRST=SQRT(1.0D0-COSTRST*COSTRST)
VEC1(1)=SINTRST*COS(PHIRST)
VEC1(2)=SINTRST*SIN(PHIRST)
VEC1(3)=COSTRST

MTRX_GLB2LCL=0.0D0
MTRX_GLB2LCL(2,2)=1.0D0
MTRX_GLB2LCL(1,1)=-SIN(THETA_IN-PI/2.0D0)
MTRX_GLB2LCL(1,3)=-SQRT(1.0D0-MU_IN*MU_IN)
MTRX_GLB2LCL(3,1)=COS(THETA_IN-PI/2.0D0)
MTRX_GLB2LCL(3,3)=MU_IN

VEC2=MATMUL(MTRX_GLB2LCL,VEC1)

PHILCL=PHI_UPDT(VEC2)
MULCL=VEC2(3)

DO IMU=1,NMUFWDCN-1
  IF(MULCL>MUFWDCN_LCL(IMU))EXIT
ENDDO

RTMP=TWOPI/(1.0D0*NPHIFWDCN)
IPHI=PHILCL/RTMP+1

WT1=ABS((MULCL-MUFWDCN_LCL(IMU))/(MUFWDCN_LCL(IMU-1)-MUFWDCN_LCL(IMU)))
WT2=ABS(1.0D0-WT1)

IF(IPHI==NPHIFWDCN)THEN
  RTMP=TWOPI
  IPHI1=1
ELSE
  RTMP=PHIFWDCN_LCL(IPHI+1)
  IPHI1=IPHI+1
ENDIF
WT3=ABS((PHILCL-PHIFWDCN_LCL(IPHI))/(RTMP-PHIFWDCN_LCL(IPHI)))
WT4=ABS(1.0D0-WT3)


VRADRST=WT2*WT4*LRADA_FWDCN_SNG(IMU,NALYR,IPHI)%VRAD + &
        WT1*WT4*LRADA_FWDCN_SNG(IMU-1,NALYR,IPHI)%VRAD + &
        WT2*WT3*LRADA_FWDCN_SNG(IMU,NALYR,IPHI1)%VRAD + &
        WT1*WT3*LRADA_FWDCN_SNG(IMU-1,NALYR,IPHI1)%VRAD
END SUBROUTINE RAD_FWDCN_SEARCH

SUBROUTINE RAD_FOURIER_INVERSE(NTHETAOUT,MAXMORD,NPHIOUT,PHIOUT,&
                               LSPAK,LRADAU)
USE RTTYPE
IMPLICIT NONE
INTEGER,INTENT(IN) ::NTHETAOUT,MAXMORD,NPHIOUT
REAL(DP),DIMENSION(1:NPHIOUT),INTENT(IN) :: PHIOUT

TYPE(ARRAY4),DIMENSION(1:NTHETAOUT,0:MAXMORD),INTENT(IN)::LSPAK
TYPE(ARRAY4),DIMENSION(NTHETAOUT,NPHIOUT),INTENT(OUT) :: LRADAU

INTEGER :: IPHI,ITHETA,M

DO IPHI=1,NPHIOUT
DO ITHETA=1,NTHETAOUT
LRADAU(ITHETA,IPHI)%VRAD=0.0D0
LRADAU(ITHETA,IPHI)%VRAD(1)=LRADAU(ITHETA,IPHI)%VRAD(1) + &
          LSPAK(ITHETA,0)%VRAD(1)
LRADAU(ITHETA,IPHI)%VRAD(2)=LRADAU(ITHETA,IPHI)%VRAD(2) + &
          LSPAK(ITHETA,0)%VRAD(2)
DO M=1,MAXMORD
LRADAU(ITHETA,IPHI)%VRAD(1)=LRADAU(ITHETA,IPHI)%VRAD(1) + &
          2.0D0*COS(M*PHIOUT(IPHI))*LSPAK(ITHETA,M)%VRAD(1)
LRADAU(ITHETA,IPHI)%VRAD(2)=LRADAU(ITHETA,IPHI)%VRAD(2) + &
          2.0D0*COS(M*PHIOUT(IPHI))*LSPAK(ITHETA,M)%VRAD(2)
LRADAU(ITHETA,IPHI)%VRAD(3)=LRADAU(ITHETA,IPHI)%VRAD(3) + &
          2.0D0*SIN(M*PHIOUT(IPHI))*LSPAK(ITHETA,M)%VRAD(3)
LRADAU(ITHETA,IPHI)%VRAD(4)=LRADAU(ITHETA,IPHI)%VRAD(4) + &
          2.0D0*SIN(M*PHIOUT(IPHI))*LSPAK(ITHETA,M)%VRAD(4)
ENDDO
ENDDO
ENDDO

END SUBROUTINE RAD_FOURIER_INVERSE

SUBROUTINE PHMX_ASSIGN(NUMMIEINPUT,NUMMIEANGINPUT,PHMXDATASTREAM)
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
INTEGER,INTENT(IN) :: NUMMIEINPUT
INTEGER,INTENT(IN),DIMENSION(NUMMIEINPUT) ::NUMMIEANGINPUT
REAL*8,INTENT(IN),DIMENSION(NUMMIEINPUT,NUMMIEANGMAX,0:6) :: PHMXDATASTREAM
INTEGER :: I,IMIE

NUMMIEANG=NUMMIEANGINPUT

DO IMIE=1,NUMMIE
DO I=1,NUMMIEANG(IMIE)
	   PM_AO_SNG(IMIE,I)%PHMX=0.0d0
	   THETA_SNG(IMIE,I)=PHMXDATASTREAM(IMIE,I,0)
	   PM_AO_SNG(IMIE,I)%PHMX(1,1)=PHMXDATASTREAM(IMIE,I,1)
	   PM_AO_SNG(IMIE,I)%PHMX(2,2)=PHMXDATASTREAM(IMIE,I,2)
	   PM_AO_SNG(IMIE,I)%PHMX(3,3)=PHMXDATASTREAM(IMIE,I,3)
	   PM_AO_SNG(IMIE,I)%PHMX(4,4)=PHMXDATASTREAM(IMIE,I,4)
	   PM_AO_SNG(IMIE,I)%PHMX(1,2)=PHMXDATASTREAM(IMIE,I,5)
	   PM_AO_SNG(IMIE,I)%PHMX(3,4)=PHMXDATASTREAM(IMIE,I,6)
	   PM_AO_SNG(IMIE,I)%PHMX(2,1)=PM_AO_SNG(IMIE,I)%PHMX(1,2)
	   PM_AO_SNG(IMIE,I)%PHMX(4,3)=-PM_AO_SNG(IMIE,I)%PHMX(3,4)
! TESTING PHMXDATASTREAM
! WRITE(*,'(I4,5(2x,E13.6))')IMIE,THETA_SNG(IMIE,I),PM_AO_SNG(IMIE,I)%PHMX(1,1),&
!  PM_AO_SNG(IMIE,I)%PHMX(2,1),PM_AO_SNG(IMIE,I)%PHMX(3,1),PM_AO_SNG(IMIE,I)%PHMX(4,1)

ENDDO
ENDDO ! IMIE LOOP
MU_SNG=COS(THETA_SNG*FACTOR)

END SUBROUTINE PHMX_ASSIGN

SUBROUTINE DBLE_SCAT_CORR_FWDCN(ILAYER,COST1,PHI1,COST2,PHI2,RADCORR)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
INTEGER,INTENT(IN)  :: ILAYER
REAL*8,INTENT(IN) :: COST1,PHI1,COST2,PHI2
REAL*8,INTENT(OUT) :: RADCORR

INTEGER :: IMIE,IL_AVG,ILTERM
REAL*8 :: PHASE_FUNCTION_RESIDUE,XIFUNC

REAL*8 :: PFRSD,PSPIKE,PSPIKE_AVG,PHINT

INTEGER :: IANG
REAL*8 :: SINT,SINT1,SINT2,SINT1P,MUSCAT,MUMIN,MUMAX,MU1,&
          COEFCI,COEFDI,COEFCP,COEFDP,WTANG,COST1P,RTMP,RTMP1,&
          WTTOTAL,LBDOAVG,FTRUNCAVG,FBAVG
LOGICAL :: CUTTING

INTEGER :: NK,IMIN,IMAX,KINT,ILYINX
REAL*8,DIMENSION(:),ALLOCATABLE :: XJK,PLNML

LOGICAL NEW_DBLE_SCAT_SCHEME

NK=MAXVAL(NUMORDFULLBETAL)
IF(NK<=MAXLORD)THEN
   RADCORR=0.0D0
   RETURN
ENDIF

NEW_DBLE_SCAT_SCHEME=.FALSE.

SINT1=SQRT(1.0D0-COST1*COST1)
SINT2=SQRT(1.0D0-COST2*COST2)

MUSCAT=COST1*COST2+SINT1*SINT2*COS(PHI2-PHI1)
IF(ABS(MUSCAT)>1.0D0)MUSCAT=MUSCAT/ABS(MUSCAT)
SINT=SQRT(1.0D0-MUSCAT*MUSCAT)

IF(NEW_DBLE_SCAT_SCHEME) THEN

ALLOCATE(XJK(NUMMIEANGMAX))

PSPIKE_AVG=0.0D0
WTTOTAL=0.0D0
FTRUNCAVG=0.0D0

DO IL_AVG=1,ILAYER
IMIE=ALYR(IL_AVG)%IPT

NK=NUMMIEANG(IMIE)
XJK(1:NK)=MU_SNG(IMIE,1:NK)

IMIN=INT(FLOAT(NK)*ABS((MUSCAT-XJK(1))/(XJK(NK)-XJK(1))))
CALL hunt(XJK,NK,MUSCAT,IMIN)
PFRSD=PHF_RESIDUE(IMIE,IMIN)+ &
      (PHF_RESIDUE(IMIE,IMIN+1)-PHF_RESIDUE(IMIE,IMIN))*  &
      (MUSCAT-XJK(IMIN))/(XJK(IMIN+1)-XJK(IMIN))

!PFRSD=PHASE_FUNCTION_RESIDUE(IMIE,MUSCAT)

PSPIKE=0.0D0
IF(IL_AVG==NALYR)THEN
 ILYINX=ALYR(IL_AVG)%ITAUE
ELSE
 ILYINX=ALYR(IL_AVG)%ITAUE+1
ENDIF
WTTOTAL=WTTOTAL+LBDO_A_PRSV(IL_AVG)* &
        (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))
FTRUNCAVG=FTRUNCAVG+FTRUNC(IMIE)*LBDO_A_PRSV(IL_AVG)* &
        (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))

DO IANG=1,NUMMIEANG(IMIE)

  MU1=MU_SNG(IMIE,IANG)
  SINT1P=SQRT(1.0D0-MU1*MU1)
  IF(ABS(SINT1P)<1.0D-6 .or. ABS(SINT)<1.0D-6)THEN
    RTMP=MUSCAT*MU1
    RTMP1=PI*PHASE_FUNCTION_RESIDUE(IMIE,RTMP)
    IF(ABS(SINT)<1.0D-6)RTMP1=RTMP1/2.0D0
    PHINT=RTMP1
  ELSE
    PHINT=0.0D0
    MUMIN=MUSCAT*MU1-SINT*SINT1P
    MUMAX=MUSCAT*MU1+SINT*SINT1P
    IF(MU1<MUMAX)THEN
      MUMAX=MU1
      CUTTING=.TRUE.
    ELSE
      CUTTING=.FALSE.
    ENDIF !  MUMAX=MIN(MUMAX,MU1)
    IF(MUMAX>MUMIN)THEN
      IMIN=INT(FLOAT(NK)*ABS((MUMIN-XJK(1))/(XJK(NK)-XJK(1))))
      CALL hunt(XJK,NK,MUMIN,IMIN)
      IMAX=INT(FLOAT(NK)*ABS((MUMAX-XJK(1))/(XJK(NK)-XJK(1))))
      CALL hunt(XJK,NK,MUMAX,IMAX)
      KINT=IMIN
      COEFDI=(PHF_RESIDUE(IMIE,KINT+1)-PHF_RESIDUE(IMIE,KINT)) / &
           (XJK(KINT+1)-XJK(KINT))
      COEFCI=PHF_RESIDUE(IMIE,KINT)-COEFDI*XJK(KINT)
      PHINT=PHINT+(COEFDI*MUSCAT*MU1+COEFCI)*PI/2.0D0
      DO KINT=IMIN+1,IMAX
        COEFDP=(PHF_RESIDUE(IMIE,KINT+1)-PHF_RESIDUE(IMIE,KINT)) / &
               (XJK(KINT+1)-XJK(KINT))
        COEFCP=PHF_RESIDUE(IMIE,KINT)-COEFDI*XJK(KINT)
        RTMP=(MUSCAT*MU1-XJK(KINT))/SINT/SINT1P
        IF(ABS(RTMP)>1.0D0)RTMP=RTMP/ABS(RTMP)
        PHINT=PHINT+(COEFDP-COEFDI)*SQRT(abs(1.0D0-MUSCAT*MUSCAT-MU1*MU1 &
                  -XJK(KINT)*XJK(KINT) + 2.0D0*MUSCAT*MU1*XJK(KINT))) +  &
                  ((COEFDP-COEFDI)*MUSCAT*MU1+COEFCP-COEFCI) *           &
                  ASIN(RTMP)
       COEFDI=COEFDP
       COEFCI=COEFCP       
      ENDDO
      
      IF(CUTTING)THEN
        RTMP=(MUSCAT-1.0D0)*MU1/SINT/SINT1P
        IF(ABS(RTMP)>1.0D0)RTMP=RTMP/ABS(RTMP)
        PHINT=PHINT-COEFDI*SQRT(1.0D0-MUSCAT*MUSCAT+2.0D0*MU1*MU1*(MUSCAT-1.0D0))  &
                  -(COEFDI*MUSCAT*MU1+COEFCI)*ASIN(RTMP)
      ELSE
        PHINT=PHINT+(COEFDI*MUSCAT*MU1+COEFCI)*PI/2.0D0
      ENDIF
    ENDIF ! IF(MUMAX>MUMIN)
  ENDIF ! SPECIAL CASE
  IF(IANG==1)THEN
     WTANG=0.5D0*ABS(MU_SNG(IMIE,IANG)-MU_SNG(IMIE,IANG+1))
  ELSEIF(IANG==NUMMIEANG(IMIE))THEN
     WTANG=0.5D0*ABS(MU_SNG(IMIE,IANG)-MU_SNG(IMIE,IANG-1))
  ELSE
     WTANG=0.5D0*ABS(MU_SNG(IMIE,IANG+1)-MU_SNG(IMIE,IANG-1))
  ENDIF
  PSPIKE=PSPIKE+PHINT*WTANG
ENDDO

PSPIKE=2.0D0*PFRSD - PSPIKE

PSPIKE_AVG=PSPIKE_AVG+PSPIKE*LBDO_A_PRSV(IL_AVG)*  &
       (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))
ENDDO ! IL_AVG LOOP

IF(ILAYER==NALYR)THEN
 ILYINX=ALYR(ILAYER)%ITAUE
ELSE
 ILYINX=ALYR(ILAYER)%ITAUE+1
ENDIF

IF(ABS(WTTOTAL)<1.0D-32) THEN
    RADCORR=0.0D0
    RETURN
ENDIF
PSPIKE_AVG=PSPIKE_AVG/WTTOTAL
FTRUNCAVG=FTRUNCAVG/WTTOTAL
LBDOAVG=WTTOTAL/TAU_PRSV(ILYINX)

DEALLOCATE(XJK)
ELSE  ! USE EXPANSION SCHEME IN DISORT REPORT

  NK=MAXVAL(NUMORDFULLBETAL)
  ALLOCATE(PLNML(0:NK))
  CALL fleg(MUSCAT,PLNML(0),NK+1)  

  FBAVG=0.0D0
  PSPIKE_AVG=0.0D0
  WTTOTAL=0.0D0
  FTRUNCAVG=0.0D0
  DO IL_AVG=1,ILAYER
    IMIE=ALYR(IL_AVG)%IPT

    IF(IL_AVG==NALYR)THEN
      ILYINX=ALYR(IL_AVG)%ITAUE
    ELSE
      ILYINX=ALYR(IL_AVG)%ITAUE+1
    ENDIF

    WTTOTAL=WTTOTAL+LBDO_A_PRSV(IL_AVG)* &
        (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))
    FTRUNCAVG=FTRUNCAVG+FTRUNC(IMIE)*LBDO_A_PRSV(IL_AVG)* &
        (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))
  ENDDO
  IF(ABS(WTTOTAL)<1.0D-32) THEN
    RADCORR=0.0D0
    RETURN
  ENDIF

  IF(ILAYER==NALYR)THEN
     ILYINX=ALYR(ILAYER)%ITAUE
  ELSE
    ILYINX=ALYR(ILAYER)%ITAUE+1
  ENDIF
  FTRUNCAVG=FTRUNCAVG/WTTOTAL
  LBDOAVG=WTTOTAL/TAU_PRSV(ILYINX)

  PSPIKE_AVG=0.0d0
  DO ILTERM=0,MAXLORD
    PSPIKE_AVG=PSPIKE_AVG+(2.0D0*ILTERM+1.0D0)*PLNML(ILTERM)
  ENDDO
  
  DO ILTERM=MAXLORD+1,NK !  NUMORDFULLBETAL(IMIE)
    FBAVG=0.0D0
    DO IL_AVG=1,ILAYER
      IMIE=ALYR(IL_AVG)%IPT
      IF(IL_AVG==NALYR)THEN
         ILYINX=ALYR(IL_AVG)%ITAUE
      ELSE
         ILYINX=ALYR(IL_AVG)%ITAUE+1
      ENDIF
      FBAVG=FBAVG+FULLBETAL(IMIE,ILTERM)*LBDO_A_PRSV(IL_AVG)* &
          (TAU_PRSV(ILYINX)-TAU_PRSV(ALYR(IL_AVG)%ITAUS))
    ENDDO
    IF(ILAYER==NALYR)THEN
        ILYINX=ALYR(ILAYER)%ITAUE
    ELSE
        ILYINX=ALYR(ILAYER)%ITAUE+1
    ENDIF

    IF(FTRUNCAVG*LBDOAVG*TAU_PRSV(ILYINX) <1.0D-4)THEN
      FBAVG=0.0D0
    ELSE
      FBAVG=FBAVG/FTRUNCAVG/LBDOAVG/TAU_PRSV(ILYINX)
    ENDIF
    PSPIKE_AVG=PSPIKE_AVG+(2.0D0*FBAVG-FBAVG*FBAVG)*&
                          (2.0D0*ILTERM+1.0D0)*PLNML(ILTERM)
  ENDDO

  DEALLOCATE(PLNML)
ENDIF

RTMP=LBDOAVG*FTRUNCAVG
RTMP1=1.0D0-RTMP
COST1P=COST1/RTMP1
    IF(ILAYER==NALYR)THEN
        ILYINX=ALYR(ILAYER)%ITAUE
    ELSE
        ILYINX=ALYR(ILAYER)%ITAUE+1
    ENDIF
RTMP=RTMP*RTMP/RTMP1/FOURPI
RTMP1=XIFUNC(TAU_PRSV(ILYINX),COST2,COST1P)
RADCORR=ESUN(1)*RTMP*PSPIKE_AVG*RTMP1

END SUBROUTINE DBLE_SCAT_CORR_FWDCN

REAL*8 FUNCTION PHASE_FUNCTION_RESIDUE(IMIE,MUSCAT)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
INTEGER,INTENT(IN) :: IMIE
REAL*8,INTENT(IN) :: MUSCAT

REAL*8,ALLOCATABLE,DIMENSION(:)::DL00,DL20,DL2P2,DL2N2
REAL*8,ALLOCATABLE,DIMENSION(:)::XJK,VSK

INTEGER :: NK,MPL,IULO,KLO,L
REAL*8 :: PHFFIT,PHFORI,RTMP

ALLOCATE(DL00(0:MAXLORD),DL20(0:MAXLORD),DL2P2(0:MAXLORD),DL2N2(0:MAXLORD))
CALL GETDMLlocal(MUSCAT,MAXLORD,DL00,DL20,DL2P2,DL2N2)
PHFFIT=0.0D0
DO L=0,MAXLORD
  PHFFIT=PHFFIT+DL00(L)*BETAL(IMIE,L)
ENDDO
DEALLOCATE(DL00,DL20,DL2P2,DL2N2)

NK=NUMMIEANG(IMIE)
ALLOCATE(VSK(NK),XJK(NK))
XJK(1:NK)=MU_SNG(IMIE,1:NK)
VSK(1:NK)=PM_AO_SNG(IMIE,1:NK)%PHMX(1,1)
MPL=3
IULO=INT(FLOAT(NK)*ABS((MUSCAT-XJK(1))/(XJK(NK)-XJK(1))))
CALL hunt(XJK,NK,MUSCAT,IULO)
KLO=min(max(IULO-(MPL-1)/2,1),NK+1-MPL)
CALL POLINT(XJK(KLO),VSK(KLO),MPL,MUSCAT,PHFORI,RTMP)
DEALLOCATE(VSK,XJK)

PHASE_FUNCTION_RESIDUE=(PHFORI-PHFFIT*(1.0D0-FTRUNC(IMIE)))/FTRUNC(IMIE)

END FUNCTION PHASE_FUNCTION_RESIDUE

REAL*8 FUNCTION XIFUNC(TAUCORR,COST2,COST1P)
REAL*8,INTENT(IN) :: TAUCORR,COST2,COST1P
REAL*8 :: RTMP

IF(ABS(COST2-COST1P)<1.0D-6)THEN
  XIFUNC=0.5D0*TAUCORR*TAUCORR*EXP(-TAUCORR/ABS(COST2))
ELSE
  RTMP=1.0D0/ABS(COST2)-1.0D0/ABS(COST1P)
  RTMP=1.0D0/RTMP
  XIFUNC=RTMP*((TAUCORR-RTMP)*EXP(-TAUCORR/ABS(COST1P)) + &
                RTMP*EXP(-TAUCORR/ABS(COST2)))
ENDIF

ENDFUNCTION XIFUNC

SUBROUTINE DBLE_SCAT_INIT
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
INTEGER :: IMIE,ITHETA,ILTERM
REAL*8 :: PHASE_FUNCTION_RESIDUE

REAL*8 :: RTMP

DO IMIE=1,NUMMIE
DO ITHETA=1,NUMMIEANG(IMIE)
  RTMP=MU_SNG(IMIE,ITHETA)
  PHF_RESIDUE(IMIE,ITHETA)=PHASE_FUNCTION_RESIDUE(IMIE,RTMP)
ENDDO
ENDDO

END SUBROUTINE DBLE_SCAT_INIT

SUBROUTINE FULLBETAL_INIT
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
INTEGER :: IMIE,ITHETA,ILTERM

REAL*8 :: RTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: PLNML
REAL*8,DIMENSION(:),ALLOCATABLE :: TWOX,F1TMP,F2TMP,DTMP,WTANG,PLNMLtmp


FULLBETAL=0.0D0

DO IMIE=1,NUMMIE
  ALLOCATE(PLNML(2,NUMMIEANG(IMIE)),TWOX(NUMMIEANG(IMIE)),&
           F1TMP(NUMMIEANG(IMIE)), F2TMP(NUMMIEANG(IMIE)),&
           DTMP(NUMMIEANG(IMIE)),WTANG(NUMMIEANG(IMIE)), &
           PLNMLtmp(NUMMIEANG(IMIE)))

  DO ITHETA=1,NUMMIEANG(IMIE)
      IF(ITHETA==1)THEN
        WTANG(ITHETA)=0.5D0*ABS(MU_SNG(IMIE,ITHETA)-MU_SNG(IMIE,ITHETA+1))
      ELSEIF(ITHETA==NUMMIEANG(IMIE))THEN
        WTANG(ITHETA)=0.5D0*ABS(MU_SNG(IMIE,ITHETA)-MU_SNG(IMIE,ITHETA-1))
      ELSE
        WTANG(ITHETA)=0.5D0*ABS(MU_SNG(IMIE,ITHETA+1)-MU_SNG(IMIE,ITHETA-1))
      ENDIF 
  ENDDO
  
  PLNML=0.0D0
  PLNML(1,1:NUMMIEANG(IMIE))=1.0D0
  PLNML(2,1:NUMMIEANG(IMIE))=MU_SNG(IMIE,1:NUMMIEANG(IMIE))

  DO ILTERM=0,1
    FULLBETAL(IMIE,ILTERM)=FULLBETAL(IMIE,ILTERM) + &
         0.5D0*SUM(PLNML(ILTERM+1,1:NUMMIEANG(IMIE))*      &
        PM_AO_SNG(IMIE,1:NUMMIEANG(IMIE))%PHMX(1,1)*WTANG(1:NUMMIEANG(IMIE)))
  ENDDO

  ILTERM=2
  TWOX=2.0D0*MU_SNG(IMIE,1:NUMMIEANG(IMIE))
  F2TMP=MU_SNG(IMIE,1:NUMMIEANG(IMIE))
  DTMP=1.0D0
  DO WHILE (ILTERM<MAXLFULL)
     F1TMP=DTMP
     F2TMP=F2TMP+TWOX
     DTMP=DTMP+1.0D0
     PLNMLtmp(1:NUMMIEANG(IMIE))=PLNML(2,1:NUMMIEANG(IMIE))
     PLNML(2,1:NUMMIEANG(IMIE))=(F2TMP*PLNML(2,1:NUMMIEANG(IMIE))  -   &
                                 F1TMP*PLNML(1,1:NUMMIEANG(IMIE)))/DTMP
     PLNML(1,1:NUMMIEANG(IMIE))=PLNMLtmp(1:NUMMIEANG(IMIE))
     FULLBETAL(IMIE,ILTERM)=FULLBETAL(IMIE,ILTERM) +  &
           0.5D0*SUM(PLNML(2,1:NUMMIEANG(IMIE))*      &
           PM_AO_SNG(IMIE,1:NUMMIEANG(IMIE))%PHMX(1,1)*WTANG(1:NUMMIEANG(IMIE)))

     ILTERM=ILTERM+1
     IF(abs(FULLBETAL(IMIE,ILTERM))<1.0D-6 &
          .AND. abs(FULLBETAL(IMIE,ILTERM-1))<1.0D-6) EXIT
  ENDDO
!  IF(ILTERM>=MAXLFULL) THEN
!     WRITE(*,*)'MAXLFULL MAY NOT BE ENOUGH, INCREASE MAXLFULL'
!     WRITE(*,*)'MIENUM(',IMIE,')','BETAL=',FULLBETAL(IMIE,ILTERM-1)
!  ENDIF
  NUMORDFULLBETAL(IMIE)=ILTERM

  DEALLOCATE(PLNML,TWOX,F1TMP,F2TMP,DTMP,WTANG,PLNMLtmp)
  FULLBETAL(IMIE,0:NUMORDFULLBETAL(IMIE))=FULLBETAL(IMIE,0:NUMORDFULLBETAL(IMIE))/&
                                     FULLBETAL(IMIE,0)
ENDDO

!testing
!DO ILTERM=0,NUMORDFULLBETAL(1)
!  write(*,*)ILTERM,FULLBETAL(1,ILTERM)*(2.0*ILTERM+1)
!enddo
IF(MAXLORD>MAXVAL(NUMORDFULLBETAL))THEN
  MAXLORD=MAXVAL(NUMORDFULLBETAL)
  MAXMORD=MAXLORD
ENDIF

END SUBROUTINE FULLBETAL_INIT

SUBROUTINE MUOUTSHUFFLE(NTHETAOUT,MUOUT,NMUOUTSHFLA,MUOUTSHFLA,&
                        NMUOUTSHFLO,MUOUTSHFLO)

USE RTTYPE
USE RTUTILITY, ONLY : OCEAN,OCEAN_NO_TRAN,FLATO,RAD_MAP,NWRE
IMPLICIT NONE
INTEGER,INTENT(IN) :: NTHETAOUT
REAL*8,DIMENSION(NTHETAOUT),INTENT(IN) :: MUOUT

INTEGER,INTENT(OUT) :: NMUOUTSHFLA,NMUOUTSHFLO
REAL*8,DIMENSION(:),ALLOCATABLE :: MUOUTSHFLA,MUOUTSHFLO
REAL*8,DIMENSION(:),ALLOCATABLE :: MUOUTTMP
INTEGER :: IMUOUT
REAL*8 :: RTMP,THETA1,THETA2

IF(OCEAN .AND. FLATO .AND. (.NOT. OCEAN_NO_TRAN) .AND. RAD_MAP)THEN
  ALLOCATE(MUOUTSHFLA(2*NTHETAOUT),MUOUTTMP(2*NTHETAOUT))
  MUOUTTMP=1.0d0
  MUOUTTMP(1:NTHETAOUT)=ABS(MUOUT(1:NTHETAOUT))
  DO IMUOUT=1,NTHETAOUT
    IF(MUOUT(IMUOUT)>0.0D0)CYCLE
    THETA2=ACOS(-MUOUT(IMUOUT))
    THETA1=SIN(THETA2)*NWRE
    IF(THETA1>1.0D0)CYCLE
    THETA1=ASIN(THETA1)
    MUOUTTMP(IMUOUT+NTHETAOUT)=-COS(THETA1)  
  ENDDO
  MUOUTTMP=ABS(MUOUTTMP)
  MUOUTSHFLA=MUOUTTMP
  CALL sort2(2*NTHETAOUT,MUOUTTMP,MUOUTSHFLA)
  CALL REMOVE_DUP(2*NTHETAOUT,MUOUTTMP,NMUOUTSHFLA,MUOUTSHFLA)
ELSE
  ALLOCATE(MUOUTSHFLA(NTHETAOUT),MUOUTTMP(NTHETAOUT))
  MUOUTTMP=ABS(MUOUT)
  MUOUTSHFLA=MUOUTTMP
  CALL sort2(NTHETAOUT,MUOUTTMP,MUOUTSHFLA)
  CALL REMOVE_DUP(NTHETAOUT,MUOUTTMP,NMUOUTSHFLA,MUOUTSHFLA)
ENDIF

  MUOUTTMP=MUOUTSHFLA
  DEALLOCATE(MUOUTSHFLA)
  ALLOCATE(MUOUTSHFLA(2*NMUOUTSHFLA))
  MUOUTSHFLA(NMUOUTSHFLA+1:2*NMUOUTSHFLA)=MUOUTTMP(1:NMUOUTSHFLA)
  DO IMUOUT=1,NMUOUTSHFLA
    MUOUTSHFLA(IMUOUT)=-MUOUTSHFLA(2*NMUOUTSHFLA-IMUOUT+1)
  ENDDO
  NMUOUTSHFLA=2*NMUOUTSHFLA
  DEALLOCATE(MUOUTTMP)

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. RAD_MAP .AND. FLATO ) THEN
  ALLOCATE(MUOUTTMP(2*NMUOUTSHFLA),MUOUTSHFLO(2*NMUOUTSHFLA))
  MUOUTTMP=1.0d0
  MUOUTTMP(1:NMUOUTSHFLA)=MUOUTSHFLA(1:NMUOUTSHFLA)
  
  DO IMUOUT=1,NMUOUTSHFLA
     IF(MUOUTSHFLA(IMUOUT)<0.0D0)CYCLE
     THETA2=ACOS(MUOUTSHFLA(IMUOUT))
     THETA1=ASIN(SIN(THETA2)/NWRE)
     MUOUTTMP(IMUOUT+NTHETAOUT)=COS(THETA1)
  ENDDO
  MUOUTTMP=ABS(MUOUTTMP)
  MUOUTSHFLO=MUOUTTMP
  CALL sort2(2*NMUOUTSHFLA,MUOUTTMP,MUOUTSHFLO)
  CALL REMOVE_DUP(2*NMUOUTSHFLA,MUOUTTMP,NMUOUTSHFLO,MUOUTSHFLO)
ELSE
  ALLOCATE(MUOUTSHFLO(NTHETAOUT))
  MUOUTSHFLO=MUOUT
  MUOUTTMP=MUOUT
  CALL sort2(NTHETAOUT,MUOUTTMP,MUOUTSHFLO)
  CALL REMOVE_DUP(NTHETAOUT,MUOUTTMP,NMUOUTSHFLO,MUOUTSHFLO)
ENDIF

MUOUTTMP=MUOUTSHFLO
DEALLOCATE(MUOUTSHFLO)
ALLOCATE(MUOUTSHFLO(2*NMUOUTSHFLO))
MUOUTSHFLO(NMUOUTSHFLO+1:2*NMUOUTSHFLO)=MUOUTTMP(1:NMUOUTSHFLO)

DO IMUOUT=1,NMUOUTSHFLO
  MUOUTSHFLO(IMUOUT)=-MUOUTSHFLO(2*NMUOUTSHFLO-IMUOUT+1)
ENDDO
NMUOUTSHFLO=2*NMUOUTSHFLO

DEALLOCATE(MUOUTTMP)

ENDSUBROUTINE MUOUTSHUFFLE

SUBROUTINE REMOVE_DUP(NARRAYINPUT,ARRAYINPUT,NARRAYOUTPUT,ARRAYOUTPUT)
implicit none
integer :: NARRAYINPUT,NARRAYOUTPUT
REAL*8,DIMENSION(NARRAYINPUT) :: ARRAYINPUT  ! The input
REAL*8,DIMENSION(NARRAYINPUT) :: ARRAYOUTPUT

integer :: k                   ! The number of unique elements
integer :: i, j

ARRAYINPUT=ARRAYOUTPUT

k = 1
ARRAYOUTPUT(1) = ARRAYINPUT(1)
LOOP_SEARCH: do i=2,NARRAYINPUT
do j=1,k
  if (ABS(ARRAYOUTPUT(j) - ARRAYINPUT(i))<1.0D-6) then
! Found a match so start looking again
    cycle LOOP_SEARCH
  endif
end do
! No match found so add it to the output
k = k + 1
ARRAYOUTPUT(k) = ARRAYINPUT(i)
end do LOOP_SEARCH
NARRAYOUTPUT=K

END SUBROUTINE REMOVE_DUP

REAL*8 FUNCTION WHITECAP_REFLECTANCE(WAVELENGTH_MICRON)
REAL*8, INTENT(IN) :: WAVELENGTH_MICRON
REAL*8 POLINT_SIMPLE
INTEGER,PARAMETER :: NDIM=34
! this table was extracted from Figure 8,Koepke, Applied Optics, 1984 through a plot digitizer
REAL*8,DIMENSION(NDIM) :: WAVELENGTH_TABLE=(/0.503702783,0.595283098,    &
             0.691741893,0.798816004,0.89756533,0.997943006,1.123956506, &
             1.203133143,1.266336723,1.313199778,1.36788328,1.41589394,  &
             1.450257892,1.475404589,1.500707106,1.542381407,1.574825938,&
             1.597990531,1.677371763,1.764829165,1.818252341,1.86557388, &
             1.90618518,1.939515938,1.973344481,2.011753412,2.05445488,  &
             2.097851818,2.174299646,2.302193228,2.397233402,2.45934083, &
             2.523310993,2.561567323/)
REAL*8,DIMENSION(NDIM) :: AWC=(/21.95668372,22.03437283,21.98116722,&
             21.67197236,20.97500117,20.19091556,18.77288009,       &
             17.59878731,16.29379982,15.15545631,13.33893647,       &
             11.39375275,9.276571016,8.473746322,8.222664921,       &
			 8.525557655,9.506180551,10.10348882,10.5806104,        &
             10.37910949,9.748728977,8.820363583,7.678896893,       &
             6.451654282,5.351737046,4.634242104,5.063121708,       &
             5.789093854,6.26353843,6.105817816,5.307900977,        &
             4.719069917,3.833146314,3.114759035/)
REAL*8 :: AWC_LOCAL

IF(WAVELENGTH_MICRON<WAVELENGTH_TABLE(1))THEN
	AWC_LOCAL=AWC(1)
ELSE IF (WAVELENGTH_MICRON>WAVELENGTH_TABLE(NDIM))THEN
    AWC_LOCAL=AWC(NDIM)
ELSE
	AWC_LOCAL=POLINT_SIMPLE(NDIM,WAVELENGTH_TABLE,AWC,WAVELENGTH_MICRON,2)
ENDIF

WHITECAP_REFLECTANCE=AWC_LOCAL/100.0d0
RETURN

ENDFUNCTION WHITECAP_REFLECTANCE
