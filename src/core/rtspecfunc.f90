SUBROUTINE GETDML(NMUOUTSHFLA,MUOUTSHFLA,NMUOUTSHFLO,MUOUTSHFLO)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

INTEGER(I4B),INTENT(IN) :: NMUOUTSHFLA,NMUOUTSHFLO
REAL*8,DIMENSION(NMUOUTSHFLA),INTENT(IN) :: MUOUTSHFLA
REAL*8,DIMENSION(NMUOUTSHFLO),INTENT(IN) ::MUOUTSHFLO
REAL(DP),DIMENSION(:,:),ALLOCATABLE :: WD0,WD2,WDN2

INTEGER(I4B) ::L, IQUAD,JQUAD,ITHETA,M,MORDMAX,LORDMAX

REAL(DP) :: U,NEG1,NEG1LM

! _______GLOBAL VARIABLES_______

MORDMAX=MAX(MAXMORD,MAXSORD)

IF(MAXLORD<MORDMAX) THEN
  LORDMAX=MORDMAX
ELSE
  LORDMAX=MAXLORD
ENDIF
ALLOCATE(DML0A(0:LORDMAX, NQUADA,0:MORDMAX),   &
         DML2PA(0:LORDMAX,NQUADA,0:MORDMAX),   &
         DML2NA(0:LORDMAX,NQUADA,0:MORDMAX)    )
IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN))                     &
  ALLOCATE(DML0O(0:LORDMAX, NQUADO,0:MORDMAX),   &
        DML2PO(0:LORDMAX,NQUADO,0:MORDMAX),      &
        DML2NO(0:LORDMAX,NQUADO,0:MORDMAX) )

IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) .AND. (.NOT. FLATO))         &
  ALLOCATE(DML0AT(0:LORDMAX, NQDAD2,NQDOD2,0:MORDMAX),            &
    DML2PAT(0:LORDMAX,NQDAD2,NQDOD2,0:MORDMAX),                   &
    DML2NAT(0:LORDMAX,NQDAD2,NQDOD2,0:MORDMAX),                   &
    DML0OT(0:LORDMAX, NQDOD2+1:NQUADO,NQDAD2+1:NQUADA,0:MORDMAX), &
    DML2POT(0:LORDMAX,NQDOD2+1:NQUADO,NQDAD2+1:NQUADA,0:MORDMAX), &
    DML2NOT(0:LORDMAX,NQDOD2+1:NQUADO,NQDAD2+1:NQUADA,0:MORDMAX))
IF(RAD_MAP)ALLOCATE(DML0XA(0:LORDMAX,NMUOUTSHFLA,0:MORDMAX),   &
                    DML2PXA(0:LORDMAX,NMUOUTSHFLA,0:MORDMAX),   &
                    DML2NXA(0:LORDMAX,NMUOUTSHFLA,0:MORDMAX)    )
IF(RAD_MAP.AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN)) &
     ALLOCATE(DML0XO(0:LORDMAX,NMUOUTSHFLO,0:MORDMAX),   &
              DML2PXO(0:LORDMAX,NMUOUTSHFLO,0:MORDMAX),   &
              DML2NXO(0:LORDMAX,NMUOUTSHFLO,0:MORDMAX)    )

CALL DMLINIT(LORDMAX,MORDMAX)

ALLOCATE(WD0(0:LORDMAX,0:MORDMAX),          &
         WD2(0:LORDMAX,0:MORDMAX),          &
         WDN2(0:LORDMAX,0:MORDMAX) )

DML0A=0.0D0
DML0A(0,1:NQUADA,0)=1.0D0

!LOOP OVER VARIABLE MU
NEG1=-1.0D0

LOOP_QUAD : DO IQUAD=1,NQDAD2 ! NQUADA ONLY HALF MU NEED TO CALCULATED
                              ! BECAUSE OF SYSMETRY RELATION

! EQ.(B.7), M.I. Mishchenko, L. D. Travis, and A. A. Lacis, 
! "Scattering, Absorption, and Emission of Light by Small Particles"
!(Cambridge University Press, Cambridge 2002).

  U=XJA(IQUAD)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  
 
  DO M=0,MORDMAX
  DO L=M,LORDMAX

    NEG1LM=NEG1**(L+M)

    DML0A(L,IQUAD,M)=WD0(L,M)

!  GET DML2P AND DML2N FROM WD AND WD2.
! A FACTOR OF (-1)^{-M} IS IGNORED IN THE FOLLOWING EQUATION
! BECAUSE DML2P AND DML2N APPEAR IN PAIRS IN P^M (SUBROUTINE GETPM ).
! (-1)^{-M} * (-1)^{-M} = 1

    DML2PA(L,IQUAD,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
    DML2NA(L,IQUAD,M)=0.5D0*(WD2(L,M) - WDN2(L,M))


    DML0A(L,NQUADA-IQUAD+1,M)=NEG1LM*DML0A(L,IQUAD,M)	
    DML2PA(L,NQUADA-IQUAD+1,M)=NEG1LM*DML2PA(L,IQUAD,M)
    DML2NA(L,NQUADA-IQUAD+1,M)=-NEG1LM*DML2NA(L,IQUAD,M)


  ENDDO  ! LOOP L OVER
  ENDDO   ! LOOP M OVER

ENDDO LOOP_QUAD  ! LOOP OVER NQUADA
IF(RAD_MAP)THEN
DML0XA=0.0D0
DML0XA(0,1:NMUOUTSHFLA,0)=1.0D0

!LOOP OVER VARIABLE MU

LOOP_THETAA : DO ITHETA=1,NMUOUTSHFLA

  U=MUOUTSHFLA(ITHETA)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  
 
  DO M=0,MORDMAX
  DO L=M,LORDMAX

    DML0XA(L,ITHETA,M)=WD0(L,M)

!  GET DML2P AND DML2N FROM WD AND WD2.
! A FACTOR OF (-1)^{-M} IS IGNORED IN THE FOLLOWING EQUATION
! BECAUSE DML2P AND DML2N APPEAR IN PAIRS IN P^M (SUBROUTINE GETPM ).
! (-1)^{-M} * (-1)^{-M} = 1

    DML2PXA(L,ITHETA,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
    DML2NXA(L,ITHETA,M)=0.5D0*(WD2(L,M) - WDN2(L,M))

  ENDDO  ! LOOP L OVER
  ENDDO   ! LOOP M OVER

ENDDO LOOP_THETAA ! LOOP OVER NMUOUTSHFLA
ENDIF

IF((.NOT. OCEAN) .OR. OCEAN_NO_TRAN ) THEN
  DEALLOCATE(WD0,WD2,WDN2)
  RETURN
ENDIF

WD0=0.0D0
WD2=0.0D0
WDN2=0.0D0

!LOOP OVER VARIABLE MU	  
LOOP_QUADO : DO IQUAD=1,NQDOD2
  U=XJO(IQUAD)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  

  DO M=0,MORDMAX
  DO L=M,LORDMAX
    NEG1LM=NEG1**(L+M)

    DML0O(L,IQUAD,M)=WD0(L,M)
    DML2PO(L,IQUAD,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
    DML2NO(L,IQUAD,M)=0.5D0*(WD2(L,M) - WDN2(L,M))

    DML0O(L,NQUADO-IQUAD+1,M)=NEG1LM*DML0O(L,IQUAD,M)
    DML2PO(L,NQUADO-IQUAD+1,M)=NEG1LM*DML2PO(L,IQUAD,M)
    DML2NO(L,NQUADO-IQUAD+1,M)=-NEG1LM*DML2NO(L,IQUAD,M)
  
  ENDDO  ! LOOP L OVER
  ENDDO   ! LOOP M OVER

ENDDO LOOP_QUADO  ! LOOP OVER NQUAD

IF(RAD_MAP .AND. (.NOT. OCEAN_NO_TRAN) .AND. OCEAN)THEN
DML0XO=0.0D0
DML0XO(0,1:NMUOUTSHFLO,0)=1.0D0

!LOOP OVER VARIABLE MU

LOOP_THETAO : DO ITHETA=1,NMUOUTSHFLO

U=MUOUTSHFLO(ITHETA)
CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  

DO M=0,MORDMAX
DO L=M,LORDMAX

DML0XO(L,ITHETA,M)=WD0(L,M)

!  GET DML2P AND DML2N FROM WD AND WD2.
! A FACTOR OF (-1)^{-M} IS IGNORED IN THE FOLLOWING EQUATION
! BECAUSE DML2P AND DML2N APPEAR IN PAIRS IN P^M (SUBROUTINE GETPM ).
! (-1)^{-M} * (-1)^{-M} = 1

DML2PXO(L,ITHETA,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
DML2NXO(L,ITHETA,M)=0.5D0*(WD2(L,M) - WDN2(L,M))

ENDDO  ! LOOP L OVER
ENDDO   ! LOOP M OVER

ENDDO LOOP_THETAO ! LOOP OVER NMUOUTSHFLO
ENDIF


IF(FLATO) THEN
  DEALLOCATE(WD0,WD2,WDN2)
  RETURN
ENDIF

!LOOP OVER VARIABLE MU	  
DO IQUAD=1,NQDAD2
DO JQUAD=1,NQDOD2
  U=XJAT(IQUAD,JQUAD)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  

  DO M=0,MORDMAX
  DO L=M,LORDMAX
    DML0AT(L,IQUAD,JQUAD,M)=WD0(L,M)
    DML2PAT(L,IQUAD,JQUAD,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
    DML2NAT(L,IQUAD,JQUAD,M)=0.5D0*(WD2(L,M) - WDN2(L,M))
  ENDDO  ! LOOP L OVER
  ENDDO   ! LOOP M OVER
ENDDO
ENDDO  ! LOOP OVER NQUAD

DO IQUAD=NQDOD2+1,NQUADO
DO JQUAD=NQDAD2+1,NQUADA
  U=XJOT(IQUAD,JQUAD)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2)  

  DO M=0,MORDMAX
  DO L=M,LORDMAX
    DML0OT(L,IQUAD,JQUAD,M)=WD0(L,M)
    DML2POT(L,IQUAD,JQUAD,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
    DML2NOT(L,IQUAD,JQUAD,M)=0.5D0*(WD2(L,M) - WDN2(L,M))
  ENDDO  ! LOOP L OVER
  ENDDO   ! LOOP M OVER
ENDDO
ENDDO  ! LOOP OVER NQUAD

DEALLOCATE(WD0,WD2,WDN2)

END SUBROUTINE GETDML


SUBROUTINE GETSDML(U)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

REAL(DP) :: U


INTEGER(I4B) ::MORDMAX,LORDMAX

REAL(DP),DIMENSION(:,:),ALLOCATABLE :: WD2,WDN2

!_________GLOBAL VARIABLES________
MORDMAX=MAX(MAXMORD,MAXSORD)
IF(MAXLORD<MORDMAX) THEN
  LORDMAX=MORDMAX
ELSE
  LORDMAX=MAXLORD
ENDIF
ALLOCATE(SDML0(0:LORDMAX, 0:MORDMAX),      &
		 SDML2P(0:LORDMAX,0:MORDMAX),     &
         SDML2N(0:LORDMAX,0:MORDMAX)       )

ALLOCATE(WD2(0:LORDMAX,0:MORDMAX),          &
         WDN2(0:LORDMAX,0:MORDMAX) )

SDML0=0.0D0
SDML0(0,0)=1.0D0
SDML0(0,0)=1.0D0

CALL DMLSPEC(U,LORDMAX,MORDMAX,SDML0,WD2,WDN2)  

!  GET DML2P AND DML2N FROM WD AND WD2.
! A FACTOR OF (-1)^{-M} IS IGNORED IN THE FOLLOWING EQUATION
! BECAUSE DML2P AND DML2N APPEAR IN PAIRS IN P^M (SUBROUTINE GETPM ).
! (-1)^{-M} * (-1)^{-M} = 1

SDML2P(:,:)=0.5D0*(WD2(:,:) + WDN2(:,:))
SDML2N(:,:)=0.5D0*(WD2(:,:) - WDN2(:,:))

IF(.NOT. (FLATO .OR. (LAMB .AND. FLAM<1.0D0))) THEN
  DEALLOCATE(WD2,WDN2)
  RETURN
ENDIF

ALLOCATE(SRDML0(0:LORDMAX, 0:MORDMAX),      &
		 SRDML2P(0:LORDMAX,0:MORDMAX),     &
         SRDML2N(0:LORDMAX,0:MORDMAX)       )

WD2=0.0D0
WDN2=0.0D0

SRDML0=0.0D0
SRDML0(0,0)=1.0D0
SRDML0(0,0)=1.0D0

CALL DMLSPEC(-U,LORDMAX,MORDMAX,SRDML0,WD2,WDN2)  
SRDML2P(:,:)=0.5D0*(WD2(:,:) + WDN2(:,:))
SRDML2N(:,:)=0.5D0*(WD2(:,:) - WDN2(:,:))

DEALLOCATE(WD2,WDN2)

END SUBROUTINE GETSDML

SUBROUTINE GETSDMLO
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

REAL(DP),DIMENSION(:,:),ALLOCATABLE :: WD0,WD2,WDN2

INTEGER(I4B) ::L, IQUAD,M,MORDMAX,LORDMAX

REAL(DP) :: U

! _______GLOBAL VARIABLES_______

MORDMAX=MAX(MAXMORD,MAXSORD)
IF(MAXLORD<MORDMAX) THEN
  LORDMAX=MORDMAX
ELSE
  LORDMAX=MAXLORD
ENDIF
ALLOCATE(DML0SO(0:LORDMAX, NQUADSO,0:MORDMAX),   &
         DML2PSO(0:LORDMAX,NQUADSO,0:MORDMAX),  &
         DML2NSO(0:LORDMAX,NQUADSO,0:MORDMAX))


ALLOCATE(WD0(0:LORDMAX,0:MORDMAX),         &
         WD2(0:LORDMAX,0:MORDMAX),    &
         WDN2(0:LORDMAX,0:MORDMAX)      )

!LOOP OVER VARIABLE MU	  
LOOP_QUADO : DO IQUAD=1,NQUADSO
  U=XJSO(IQUAD)
  CALL DMLSPEC(U,LORDMAX,MORDMAX,WD0,WD2,WDN2) 
DO M=0,MORDMAX
DO L=M,LORDMAX
!  GET DML2P AND DML2N FROM WD AND WD2.
! A FACTOR OF (-1)^{-M} IS IGNORED IN THE FOLLOWING EQUATION
! BECAUSE DML2P AND DML2N APPEAR IN PAIRS IN P^M (SUBROUTINE GETPM ).
! (-1)^{-M} * (-1)^{-M} = 1
  DML0SO(L,IQUAD,M)=WD0(L,M)
  DML2PSO(L,IQUAD,M)=0.5D0*(WD2(L,M) + WDN2(L,M))
  DML2NSO(L,IQUAD,M)=0.5D0*(WD2(L,M) - WDN2(L,M))
ENDDO  ! LOOP L OVER
ENDDO   ! LOOP M OVER
ENDDO LOOP_QUADO  ! LOOP OVER NQUAD

DEALLOCATE(WD0,WD2,WDN2)


END SUBROUTINE GETSDMLO


SUBROUTINE GETPM(NMUOUTSHFLA,MUOUTSHFLA,NMUOUTSHFLO,MUOUTSHFLO)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

INTEGER(I4B),INTENT(IN) ::NMUOUTSHFLA,NMUOUTSHFLO
REAL*8,DIMENSION(NMUOUTSHFLA),INTENT(IN) ::MUOUTSHFLA
REAL*8,DIMENSION(NMUOUTSHFLO),INTENT(IN) ::MUOUTSHFLO

INTEGER(I4B) ::L,M,IQUAD,JQUAD,IMIE,ITHETA

REAL(DP) ::rtmp

INTEGER :: NUMPHI, IPHI_TMP,ICOM1,ICOM2
REAL(DP) :: PHIRG
REAL*8,DIMENSION(:), ALLOCATABLE::PHI_TMP,WPHI_TMP
REAL*8,DIMENSION(4,4) :: MTRX2
LOGICAL :: PM_EXP_FLG
integer time_array_0(8)!, time_array_1(8)
real start_time, finish_time
PM_EXP_FLG=.TRUE.

IF(PM_EXP_FLG)THEN

! ATMOSPHERE PHASE MATRIX PMA
DO IQUAD=1,NQUADA
DO JQUAD=1,NQUADA
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

PMA(IQUAD,JQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0A(L,IQUAD,M)*DML0A(L,JQUAD,M)
  IF(SCL)CYCLE

  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*DML2PA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,3)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*DML2NA(L,JQUAD,M)

  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PA(L,IQUAD,M)*DML0A(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*DML2PA(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*DML2NA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*DML2NA(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*DML2PA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,4)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NA(L,IQUAD,M)*DML0A(L,JQUAD,M)
  

  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,1)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NA(L,IQUAD,M)*DML0A(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*DML2PA(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*DML2NA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*DML2NA(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*DML2PA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PA(L,IQUAD,M)*DML0A(L,JQUAD,M)
  
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*DML2NA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*DML2PA(L,JQUAD,M)
  PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)=PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0A(L,IQUAD,M)*DML0A(L,JQUAD,M)
ENDDO
!testing PMA
!write(*,*) 'expansion method'
!write(*,'(2F10.4,I4,16E19.6)')xja(iquad),xja(jquad),m,&
!                     PMA(IQUAD,JQUAD,IMIE,M)%PHMX(1,1:4),&
!					 PMA(IQUAD,JQUAD,IMIE,M)%PHMX(2,1:4),&
!					 PMA(IQUAD,JQUAD,IMIE,M)%PHMX(3,1:4),&
!					 PMA(IQUAD,JQUAD,IMIE,M)%PHMX(4,1:4)

ENDDO
ENDDO
ENDDO
ENDDO
           
! ATMOSPHERE QUADRATURE ANGLES TO OUTPUT ANGLES PHASE MATRIX PMAX

IF(RAD_MAP)THEN
  call date_and_time(values=time_array_0)
  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

DO ITHETA=1,NMUOUTSHFLA
DO JQUAD=1,NQUADA
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,1)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0XA(L,ITHETA,M)*DML0A(L,JQUAD,M)
  IF(SCL)CYCLE

  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,2)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0XA(L,ITHETA,M)*DML2PA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,3)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0XA(L,ITHETA,M)*DML2NA(L,JQUAD,M)

  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,1)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML0A(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,2)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML2PA(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML2NA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,3)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML2NA(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML2PA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,4)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML0A(L,JQUAD,M)
  

  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,1)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML0A(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,2)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML2PA(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML2NA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,3)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NXA(L,ITHETA,M)*DML2NA(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML2PA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,4)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PXA(L,ITHETA,M)*DML0A(L,JQUAD,M)
  
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,2)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0XA(L,ITHETA,M)*DML2NA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,3)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0XA(L,ITHETA,M)*DML2PA(L,JQUAD,M)
  PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,4)=PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0XA(L,ITHETA,M)*DML0A(L,JQUAD,M)
ENDDO

ENDDO
ENDDO
ENDDO
ENDDO
  call date_and_time(values=time_array_0)
  finish_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

if(VERBOSE_FLAG) write(*,*)'PMAX integration elapsed time =', finish_time-start_time
 
ENDIF ! RAD_MAP IF

! OCEAN PHASE MATRIX PMO 
IF(.NOT. OCEAN .OR. OCEAN_NO_TRAN)RETURN

DO IQUAD=1,NQUADO
DO JQUAD=1,NQUADO
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

PMO(IQUAD,JQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0O(L,IQUAD,M)*DML0O(L,JQUAD,M)
  IF(SCL)CYCLE
  
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0O(L,IQUAD,M)*DML2PO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,3)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0O(L,IQUAD,M)*DML2NO(L,JQUAD,M)

  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PO(L,IQUAD,M)*DML0O(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PO(L,IQUAD,M)*DML2PO(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2NO(L,IQUAD,M)*DML2NO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PO(L,IQUAD,M)*DML2NO(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2NO(L,IQUAD,M)*DML2PO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,4)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NO(L,IQUAD,M)*DML0O(L,JQUAD,M)
  

  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,1)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NO(L,IQUAD,M)*DML0O(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NO(L,IQUAD,M)*DML2PO(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2PO(L,IQUAD,M)*DML2NO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NO(L,IQUAD,M)*DML2NO(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2PO(L,IQUAD,M)*DML2PO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PO(L,IQUAD,M)*DML0O(L,JQUAD,M)
  
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0O(L,IQUAD,M)*DML2NO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0O(L,IQUAD,M)*DML2PO(L,JQUAD,M)
  PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)=PMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0O(L,IQUAD,M)*DML0O(L,JQUAD,M)

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO

! ATMOSPHERE QUADRATURE ANGLES TO OUTPUT ANGLES PHASE MATRIX PMAX
IF(RAD_MAP .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
  call date_and_time(values=time_array_0)
  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

DO ITHETA=1,NMUOUTSHFLO
DO JQUAD=1,NQUADO
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,1)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0XO(L,ITHETA,M)*DML0O(L,JQUAD,M)
  IF(SCL)CYCLE
  
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,2)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0XO(L,ITHETA,M)*DML2PO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,3)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0XO(L,ITHETA,M)*DML2NO(L,JQUAD,M)

  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,1)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML0O(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,2)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML2PO(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML2NO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,3)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML2NO(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML2PO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,4)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML0O(L,JQUAD,M)
  

  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,1)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML0O(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,2)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML2PO(L,JQUAD,M) - &
			ZETAL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML2NO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,3)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NXO(L,ITHETA,M)*DML2NO(L,JQUAD,M) + &
			ZETAL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML2PO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,4)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PXO(L,ITHETA,M)*DML0O(L,JQUAD,M)
  
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,2)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0XO(L,ITHETA,M)*DML2NO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,3)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0XO(L,ITHETA,M)*DML2PO(L,JQUAD,M)
  PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,4)=PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0XO(L,ITHETA,M)*DML0O(L,JQUAD,M)

ENDDO
ENDDO
ENDDO
ENDDO
ENDDO
  call date_and_time(values=time_array_0)
  finish_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
           + time_array_0 (7) + 0.001 * time_array_0 (8)

 write(*,*)'PMOX integration elapsed time =', finish_time-start_time  
ENDIF !RAD_MAP IF
ELSE ! DIRECT INTEGRATION
  NUMPHI=500
  ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
  PHIRG=PI
  CALL gauleg(-PHIRG,PHIRG,PHI_TMP,WPHI_TMP,NUMPHI)
  WPHI_TMP=WPHI_TMP/TWOPI

IF(RAD_MAP)THEN

  DO IMIE=1,NUMMIE
  DO M=0,MAXMORD
  DO ITHETA=1,NMUOUTSHFLA
  DO JQUAD=1,NQUADA
    PMAX(ITHETA,JQUAD,IMIE,M)%PHMX=0.0D0
  DO IPHI_TMP=1,NUMPHI

    CALL PHASE_MATRIX_CALC(XJA(JQUAD),0.0D0,MUOUTSHFLA(ITHETA), &
                          PHI_TMP(IPHI_TMP),IMIE,MTRX2)
 IF(SCL)THEN
   RTMP=MTRX2(1,1)
   MTRX2=0.0D0
   MTRX2(1,1)=RTMP
 ENDIF

 DO ICOM1=1,4
 DO ICOM2=1,4

   IF(ICOM1>2 .AND. ICOM2<=2) THEN
     RTMP=SIN(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ELSE IF(ICOM1<=2 .AND. ICOM2>2) THEN
     RTMP=SIN(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ELSE
     RTMP=COS(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ENDIF    
   PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(ICOM1,ICOM2)= &
      PMAX(ITHETA,JQUAD,IMIE,M)%PHMX(ICOM1,ICOM2) + &
      MTRX2(ICOM1,ICOM2)*RTMP*WPHI_TMP(IPHI_TMP)
 ENDDO
 ENDDO

 ENDDO ! IPHI_TMP LOOP

 ENDDO
 ENDDO
 ENDDO
 ENDDO
ENDIF
!  call date_and_time(values=time_array_0)
!  start_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
!           + time_array_0 (7) + 0.001 * time_array_0 (8)
IF(RAD_MAP .AND. OCEAN .AND. (.NOT. OCEAN_NO_TRAN))THEN
 DO IMIE=1,NUMMIE
 DO M=0,MAXMORD
 DO ITHETA=1,NMUOUTSHFLO
 DO JQUAD=1,NQUADO
 PMOX(ITHETA,JQUAD,IMIE,M)%PHMX=0.0D0
 DO IPHI_TMP=1,NUMPHI

   CALL PHASE_MATRIX_CALC(XJO(JQUAD),0.0D0,MUOUTSHFLO(ITHETA), &
                          PHI_TMP(IPHI_TMP),IMIE,MTRX2)

 IF(SCL)THEN
   RTMP=MTRX2(1,1)
   MTRX2=0.0D0
   MTRX2(1,1)=RTMP
 ENDIF

 DO ICOM1=1,4
 DO ICOM2=1,4
   IF(ICOM1>2 .AND. ICOM2<=2) THEN
     RTMP=SIN(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ELSE IF(ICOM1<=2 .AND. ICOM2>2) THEN
     RTMP=SIN(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ELSE
     RTMP=COS(DFLOAT(M)*PHI_TMP(IPHI_TMP))
   ENDIF    
   PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(ICOM1,ICOM2)= &
      PMOX(ITHETA,JQUAD,IMIE,M)%PHMX(ICOM1,ICOM2) + &
      MTRX2(ICOM1,ICOM2)*RTMP*WPHI_TMP(IPHI_TMP)
 ENDDO
 ENDDO

 ENDDO ! IPHI_TMP LOOP

 ENDDO
 ENDDO
 ENDDO
 ENDDO


!   call date_and_time(values=time_array_0)
!  finish_time = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
!           + time_array_0 (7) + 0.001 * time_array_0 (8)

!write(*,*)'PMOX integration elapsed time =', finish_time-start_time  
ENDIF
  DEALLOCATE(PHI_TMP,WPHI_TMP)
ENDIF
END SUBROUTINE GETPM

! SPM IS THE PHASE MATRIX IN ATMOSPHERE FOR DIRECT SOLAR INCIDENT LIGHT
SUBROUTINE GETSPM
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE

INTEGER(I4B) ::L,M,IQUAD,JQUAD,IMIE
!real(dp) ::RTMP

INTEGER :: NUMPHI!,IPHI_TMP,ICOM1,ICOM2
REAL(DP) :: PHIRG!,SINMPHI,COSMPHI

REAL*8,DIMENSION(:), ALLOCATABLE::PHI_TMP,WPHI_TMP
!REAL*8,DIMENSION(4,4) :: MTRX2

LOGICAL SPMXTST

SPMXTST=.FALSE.
IF(SPMXTST)THEN
  NUMPHI=500
  ALLOCATE(PHI_TMP(NUMPHI),WPHI_TMP(NUMPHI))
  PHIRG=PI
  CALL gauleg(-PHIRG,PHIRG,PHI_TMP,WPHI_TMP,NUMPHI)
  WPHI_TMP=WPHI_TMP/TWOPI
ENDIF
DO IQUAD=1,NQUADA
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

SPMA(IQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  SPMA(IQUAD,IMIE,M)%PHMX(1,1)=SPMA(IQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0A(L,IQUAD,M)*SDML0(L,M)

  IF(SCL)CYCLE
  
  SPMA(IQUAD,IMIE,M)%PHMX(1,2)=SPMA(IQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*SDML2P(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(1,3)=SPMA(IQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*SDML2N(L,M)

  SPMA(IQUAD,IMIE,M)%PHMX(2,1)=SPMA(IQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML0(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(2,2)=SPMA(IQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML2P(L,M) + &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML2N(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(2,3)=SPMA(IQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML2N(L,M) - &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML2P(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(2,4)=SPMA(IQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML0(L,M)

  SPMA(IQUAD,IMIE,M)%PHMX(3,1)=SPMA(IQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML0(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(3,2)=SPMA(IQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML2P(L,M) - &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML2N(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(3,3)=SPMA(IQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*SDML2N(L,M) + &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML2P(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(3,4)=SPMA(IQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PA(L,IQUAD,M)*SDML0(L,M)

  SPMA(IQUAD,IMIE,M)%PHMX(4,2)=SPMA(IQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*SDML2N(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(4,3)=SPMA(IQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*SDML2P(L,M)
  SPMA(IQUAD,IMIE,M)%PHMX(4,4)=SPMA(IQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0A(L,IQUAD,M)*SDML0(L,M)
ENDDO

ENDDO
ENDDO

ENDDO

IF(FLATO .OR. (LAMB .AND. FLAM<1.0D0))THEN

DO IQUAD=1,NQUADA
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

SRPMA(IQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  SRPMA(IQUAD,IMIE,M)%PHMX(1,1)=SRPMA(IQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML0(L,M)
  IF(SCL)CYCLE

  SRPMA(IQUAD,IMIE,M)%PHMX(1,2)=SRPMA(IQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML2P(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(1,3)=SRPMA(IQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML2N(L,M)

  SRPMA(IQUAD,IMIE,M)%PHMX(2,1)=SRPMA(IQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML0(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(2,2)=SRPMA(IQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML2P(L,M) + &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML2N(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(2,3)=SRPMA(IQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML2N(L,M) - &
			ZETAL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML2P(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(2,4)=SRPMA(IQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML0(L,M)

  SRPMA(IQUAD,IMIE,M)%PHMX(3,1)=SRPMA(IQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML0(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(3,2)=SRPMA(IQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML2P(L,M) - &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML2N(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(3,3)=SRPMA(IQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NA(L,IQUAD,M)*SRDML2N(L,M) + &
			ZETAL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML2P(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(3,4)=SRPMA(IQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PA(L,IQUAD,M)*SRDML0(L,M)

  SRPMA(IQUAD,IMIE,M)%PHMX(4,2)=SRPMA(IQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML2N(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(4,3)=SRPMA(IQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML2P(L,M)
  SRPMA(IQUAD,IMIE,M)%PHMX(4,4)=SRPMA(IQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0A(L,IQUAD,M)*SRDML0(L,M)
ENDDO

ENDDO
ENDDO

ENDDO

ENDIF ! FLATO IF

IF((.NOT. OCEAN) .OR. OCEAN_NO_TRAN) RETURN

DO IQUAD=1,NQUADSO

DO JQUAD=1,NQUADO
DO IMIE=1,NUMMIE
DO M=0,MAXMORD

SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(:,:)=0.0D0

DO L=M,MAXLORD

  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,1)+ &
                 BETAL(IMIE,L)*DML0O(L,JQUAD,M)*DML0SO(L,IQUAD,M)

  IF(SCL)CYCLE
  
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,2)+ &
                 GAMMAL(IMIE,L)*DML0O(L,JQUAD,M)*DML2PSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,3)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(1,3) - &
                 GAMMAL(IMIE,L)*DML0O(L,JQUAD,M)*DML2NSO(L,IQUAD,M)

  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,1)+ &
                 GAMMAL(IMIE,L)*DML2PO(L,JQUAD,M)*DML0SO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,2)+ &
            ALPHAL(IMIE,L)*DML2PO(L,JQUAD,M)*DML2PSO(L,IQUAD,M) + &
			ZETAL(IMIE,L) *DML2NO(L,JQUAD,M)*DML2NSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,3)  - &
		    ALPHAL(IMIE,L)*DML2PO(L,JQUAD,M)*DML2NSO(L,IQUAD,M) - &
			ZETAL(IMIE,L) *DML2NO(L,JQUAD,M)*DML2PSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,4)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(2,4) + &
                 EPSILONL(IMIE,L)*DML2NO(L,JQUAD,M)*DML0SO(L,IQUAD,M)

  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,1)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,1) - &
                 GAMMAL(IMIE,L)*DML2NO(L,JQUAD,M)*DML0SO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,2)  - &
		    ALPHAL(IMIE,L)*DML2NO(L,JQUAD,M)*DML2PSO(L,IQUAD,M) - &
			ZETAL(IMIE,L) *DML2PO(L,JQUAD,M)*DML2NSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,3)  + &
            ALPHAL(IMIE,L)*DML2NO(L,JQUAD,M)*DML2NSO(L,IQUAD,M) + &
			ZETAL(IMIE,L) *DML2PO(L,JQUAD,M)*DML2PSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(3,4)  - &
                 EPSILONL(IMIE,L)*DML2PO(L,JQUAD,M)*DML0SO(L,IQUAD,M)

  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,2)  - &
                 EPSILONL(IMIE,L)*DML0O(L,JQUAD,M)*DML2NSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,3)  + &
                 EPSILONL(IMIE,L)*DML0O(L,JQUAD,M)*DML2PSO(L,IQUAD,M)
  SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)=SPMO(IQUAD,JQUAD,IMIE,M)%PHMX(4,4)  + &
                 DELTAL(IMIE,L)*DML0O(L,JQUAD,M)*DML0SO(L,IQUAD,M)
ENDDO

ENDDO
ENDDO

ENDDO
ENDDO


IF(SPMXTST) DEALLOCATE(PHI_TMP,WPHI_TMP)

END SUBROUTINE GETSPM

SUBROUTINE CALSPBRDF(WAVELENGTH_MICRON,MU0)
USE RTTYPE
USE RTUTILITY
USE SnowBRDF
USE RossLiBRDF
IMPLICIT NONE
REAL*8,INTENT(IN)::WAVELENGTH_MICRON,MU0
INTEGER(I4B) ::L,M,K,IQUAD,IQUAD2,MAXMS,NUMPHI,IPHI
REAL*8,DIMENSION(:),ALLOCATABLE :: PHI,WPHI
REAL*8,DIMENSION(4,4)::SLI1,SLI2,FFINT,TEM1,TEM2,FRES_REFL,FRES_TRAN
REAL*8 SINT1,SINT2,COST1,COST2,CAPA,LITA,LITB, &
       MUDIFFSQ,MUDIFFQU,RTMP,RTMP1,TWOCOS,EXPBA,  &
       COSMPHI,SINMPHI,SA,SB,SC,SPHI, &
       FA,FB,FC,FPHI,SENGFCT,PHIRG

MAXMS=MAX(MAXMORD,MAXSORD)
ALLOCATE(SFRES_REFLA(NQDAD2+1:NQUADA,0:MAXMS))

DO IQUAD2=NQDAD2+1,NQUADA
DO K=0,MAXMS
SFRES_REFLA(IQUAD2,K)%PHMX(:,:)=0.0D0
ENDDO
ENDDO
NUMPHI=500
ALLOCATE(PHI(NUMPHI),WPHI(NUMPHI))
PHIRG=PI
CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
WPHI=WPHI/TWOPI

COST1=MU0
SINT1=DSQRT(1.0D0-COST1*COST1)

DO IQUAD2=NQDAD2+1,NQUADA
COST2=XJA(IQUAD2)
SINT2=DSQRT(1.0D0-COST2*COST2)
DO K=0,MAXMORD
FFINT=0.0D0
DO IPHI=1,NUMPHI
SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
COSMPHI=COS(DFLOAT(K)*PHI(IPHI))
IF(pBRDF) CALL pBRDM_LAND(COST1,0.0D0,COST2,PHI(IPHI),TEM1)
IF(fSnowBRDF)THEN
	CALL pBRDM_Snow(WAVELENGTH_MICRON,COST1,0.0D0,COST2,PHI(IPHI),TEM1,GLBDO)
ENDIF
IF(fRossLiBRDF) CALL pBRDM_RossLi(COST1,0.0D0,COST2,PHI(IPHI),TEM1)
IF(SCL)THEN
RTMP=TEM1(1,1)
TEM1=0.0D0
TEM1(1,1)=RTMP
ENDIF
FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
ENDDO
SFRES_REFLA(IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
SFRES_REFLA(IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
SFRES_REFLA(IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
SFRES_REFLA(IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
SFRES_REFLA(IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
SFRES_REFLA(IQUAD2,K)%PHMX(4,4)=FFINT(4,4)

SFRES_REFLA(IQUAD2,K)%PHMX(1,3)=FFINT(1,3)
SFRES_REFLA(IQUAD2,K)%PHMX(2,3)=FFINT(2,3)
SFRES_REFLA(IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
SFRES_REFLA(IQUAD2,K)%PHMX(3,2)=FFINT(3,2)
ENDDO
ENDDO

!testing mRPV
!DO IQUAD2=NQDAD2+1,NQUADA,4 !NQDAD2+1,NQUADA
!DO K=0,2
!write(*,*) XJA(IQUAD2),K,SFRES_REFLA(IQUAD2,K)%PHMX(1,1),&
!          SFRES_REFLA(IQUAD2,K)%PHMX(1,2)
!ENDDO
!ENDDO

ENDSUBROUTINE CALSPBRDF

SUBROUTINE CALPBRDF(WAVELENGTH_MICRON)
USE RTTYPE
USE RTUTILITY
USE SnowBRDF
USE RossLiBRDF
IMPLICIT NONE
REAL*8,INTENT(IN) :: WAVELENGTH_MICRON
INTEGER(I4B) ::L,M,K,IQUAD1,IQUAD2,MAXMS,NUMPHI,IPHI
REAL*8,DIMENSION(:),ALLOCATABLE :: PHI,WPHI
REAL*8,DIMENSION(4,4)::SLI1,SLI2,FFINT,TEM1,TEM2,FRES_REFL,FRES_TRAN
REAL*8 SINT1,SINT2,COST1,COST2,CAPA,LITA,LITB, &
       MUDIFFSQ,MUDIFFQU,RTMP,RTMP1,TWOCOS,EXPBA,  &
       COSMPHI,SINMPHI,SA,SB,SC,SPHI, &
       FA,FB,FC,FPHI,SENGFCT,PHIRG


MAXMS=MAX(MAXMORD,MAXSORD)
ALLOCATE(FRES_REFLA(1:NQDAD2,NQDAD2+1:NQUADA,0:MAXMS))

NUMPHI=500
ALLOCATE(PHI(NUMPHI),WPHI(NUMPHI))
PHIRG=PI
CALL gauleg(-PHIRG,PHIRG,PHI,WPHI,NUMPHI)
WPHI=WPHI/TWOPI

DO IQUAD1=1,NQDAD2
DO IQUAD2=NQDAD2+1,NQUADA
COST1=XJA(IQUAD1)
COST2=XJA(IQUAD2)

SINT1=DSQRT(1.0D0-COST1*COST1)
SINT2=DSQRT(1.0D0-COST2*COST2)
DO K=0,MAXMORD
   FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(:,:)=0.0D0
   FFINT=0.0D0
   DO IPHI=1,NUMPHI
     SINMPHI=SIN(DFLOAT(K)*PHI(IPHI))
     COSMPHI=COS(DFLOAT(K)*PHI(IPHI))
     IF(pBRDF) CALL pBRDM_LAND(COST1,0.0D0,COST2,PHI(IPHI),TEM1)
	 IF(fSnowBRDF)THEN
		CALL pBRDM_Snow(WAVELENGTH_MICRON,COST1,0.0D0,COST2,PHI(IPHI),TEM1,GLBDO)
	 ENDIF
     IF(fRossLiBRDF) CALL pBRDM_RossLi(COST1,0.0D0,COST2,PHI(IPHI),TEM1)
     IF(SCL)THEN
       RTMP=TEM1(1,1)
       TEM1=0.0D0
       TEM1(1,1)=RTMP
     ENDIF
     FFINT(1,1)=FFINT(1,1)+TEM1(1,1)*COSMPHI*WPHI(IPHI)
     FFINT(1,2)=FFINT(1,2)+TEM1(1,2)*COSMPHI*WPHI(IPHI)
     FFINT(2,1)=FFINT(2,1)+TEM1(2,1)*COSMPHI*WPHI(IPHI)
     FFINT(2,2)=FFINT(2,2)+TEM1(2,2)*COSMPHI*WPHI(IPHI)
     FFINT(3,3)=FFINT(3,3)+TEM1(3,3)*COSMPHI*WPHI(IPHI)
     FFINT(4,4)=FFINT(4,4)+TEM1(4,4)*COSMPHI*WPHI(IPHI)

     FFINT(1,3)=FFINT(1,3)+TEM1(1,3)*SINMPHI*WPHI(IPHI)
     FFINT(2,3)=FFINT(2,3)+TEM1(2,3)*SINMPHI*WPHI(IPHI)
     FFINT(3,1)=FFINT(3,1)+TEM1(3,1)*SINMPHI*WPHI(IPHI)
     FFINT(3,2)=FFINT(3,2)+TEM1(3,2)*SINMPHI*WPHI(IPHI)
   ENDDO
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,1)=FFINT(1,1)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,2)=FFINT(1,2)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,1)=FFINT(2,1)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,2)=FFINT(2,2)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,3)=FFINT(3,3)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(4,4)=FFINT(4,4)

FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(1,3)=FFINT(1,3)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(2,3)=FFINT(2,3)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,1)=FFINT(3,1)
FRES_REFLA(IQUAD1,IQUAD2,K)%PHMX(3,2)=FFINT(3,2)
ENDDO
ENDDO
ENDDO

ENDSUBROUTINE CALPBRDF



SUBROUTINE RTWVSF
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

INTEGER(I4B) ::L,M,IQUAD,JQUAD,MAXMS
! real*8::rtmp
MAXMS=MAX(MAXMORD,MAXSORD)

ALLOCATE(FRES_REFLA(1:NQDAD2,NQDAD2+1:NQUADA,0:MAXMS) )
IF(OCEAN_NO_TRAN) RETURN
ALLOCATE (FRES_TRANA(1:NQDAD2,1:NQDOD2,0:MAXMS),   &
		 FRES_REFLO(NQDOD2+1:NQUADO,1:NQDOD2,0:MAXMS),          &
		 FRES_TRANO(NQDOD2+1:NQUADO,NQDAD2+1:NQUADA,0:MAXMS)  )
IF(.NOT. OSFREXP) RETURN
! SKI LIGH ROUGH SURFACE BIDIRECTIONAL REFLECTANCE, INCIDENT FROM AIR
DO IQUAD=1,NQDAD2
DO JQUAD=NQDAD2+1,NQUADA
DO M=0,MAXSORD
FRES_REFLA(IQUAD,JQUAD,M)%PHMX(:,:)=0.0D0

DO L=M,MAXSORD

  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,1)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,1)+ &
                 WBETAL(1,L)*DML0A(L,JQUAD,M)*DML0A(L,IQUAD,M)
  IF(SCL)CYCLE
  
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,2)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,2)+ &
                 WGAMMAL(1,L)*DML0A(L,JQUAD,M)*DML2PA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,3)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(1,3) - &
                 WGAMMAL(1,L)*DML0A(L,JQUAD,M)*DML2NA(L,IQUAD,M)

  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,1)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,1)+ &
            WGAMMAL(1,L)*DML2PA(L,JQUAD,M)*DML0A(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,2)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,2)+ &
            WALPHAL(1,L)*DML2PA(L,JQUAD,M)*DML2PA(L,IQUAD,M) + &
			WZETAL(1,L)*DML2NA(L,JQUAD,M)*DML2NA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,3)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,3)  - &
		    WALPHAL(1,L)*DML2PA(L,JQUAD,M)*DML2NA(L,IQUAD,M) - &
			WZETAL(1,L)*DML2NA(L,JQUAD,M)*DML2PA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,4)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(2,4) + &
		    WEPSILONL(1,L)*DML2NA(L,JQUAD,M)*DML0A(L,IQUAD,M)
  

  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,1)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,1) - &
          WGAMMAL(1,L)*DML2NA(L,JQUAD,M)*DML0A(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,2)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,2)  - &
		    WALPHAL(1,L)*DML2NA(L,JQUAD,M)*DML2PA(L,IQUAD,M) - &
			WZETAL(1,L)*DML2PA(L,JQUAD,M)*DML2NA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,3)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,3)  + &
            WALPHAL(1,L)*DML2NA(L,JQUAD,M)*DML2NA(L,IQUAD,M) + &
			WZETAL(1,L)*DML2PA(L,JQUAD,M)*DML2PA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,4)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(3,4)  - &
            WEPSILONL(1,L)*DML2PA(L,JQUAD,M)*DML0A(L,IQUAD,M)
  
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,2)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,2)  - &
                 WEPSILONL(1,L)*DML0A(L,JQUAD,M)*DML2NA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,3)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,3)  + &
                 WEPSILONL(1,L)*DML0A(L,JQUAD,M)*DML2PA(L,IQUAD,M)
  FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,4)=FRES_REFLA(IQUAD,JQUAD,M)%PHMX(4,4)  + &
                 WDELTAL(1,L)*DML0A(L,JQUAD,M)*DML0A(L,IQUAD,M)


ENDDO
ENDDO
ENDDO
ENDDO

! SKI LIGH ROUGH SURFACE BIDIRECTIONAL TRANSMITTANCE, INCIDENT FROM AIR
DO IQUAD=1,NQDAD2
DO JQUAD=1,NQDOD2
DO M=0,MAXSORD
FRES_TRANA(IQUAD,JQUAD,M)%PHMX(:,:)=0.0D0

DO L=M,MAXSORD

  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,1)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,1)+ &
                 WBETAL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)
  IF(SCL)CYCLE
  
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,2)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,2)+ &
                 WGAMMAL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,3)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(1,3) - &
                 WGAMMAL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)

  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,1)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,1)+ &
            WGAMMAL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,2)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,2)+ &
            WALPHAL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M) + &
			WZETAL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,3)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,3)  - &
		    WALPHAL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M) - &
			WZETAL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,4)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(2,4) + &
		    WEPSILONL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M)
  

  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,1)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,1) - &
          WGAMMAL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,2)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,2)  - &
		    WALPHAL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M) - &
			WZETAL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,3)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,3)  + &
            WALPHAL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML2NO(L,JQUAD,M) + &
			WZETAL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,4)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(3,4)  - &
            WEPSILONL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML2PO(L,JQUAD,M)
  
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,2)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,2)  - &
                 WEPSILONL(2,L)*DML2NAT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,3)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,3)  + &
                 WEPSILONL(2,L)*DML2PAT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)
  FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,4)=FRES_TRANA(IQUAD,JQUAD,M)%PHMX(4,4)  + &
                 WDELTAL(2,L)*DML0AT(L,IQUAD,JQUAD,M)*DML0O(L,JQUAD,M)

ENDDO
ENDDO
!test
!if(iquad==1)write(*,*)'b',xja(iquad),xjo(jquad),FRES_TRANA(IQUAD,jQUAD,0)%PHMX(1,1)

ENDDO
ENDDO

! OCEAN TRANSMITTANCE, INCIDENT FROM WATER
DO IQUAD=NQDOD2+1,NQUADO
DO JQUAD=NQDAD2+1,NQUADA
DO M=0,MAXSORD
FRES_TRANO(IQUAD,JQUAD,M)%PHMX(:,:)=0.0D0

DO L=M,MAXSORD

  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,1)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,1)+ &
                 WBETAL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)

  IF(SCL)CYCLE
  
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,2)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,2)+ &
                 WGAMMAL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,3)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(1,3) - &
                 WGAMMAL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)

  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,1)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,1)+ &
            WGAMMAL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,2)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,2)+ &
            WALPHAL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M) + &
			WZETAL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,3)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,3)  - &
		    WALPHAL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M) - &
			WZETAL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,4)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(2,4) + &
		    WEPSILONL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M)
  

  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,1)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,1) - &
          WGAMMAL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,2)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,2)  - &
		    WALPHAL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M) - &
			WZETAL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,3)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,3)  + &
            WALPHAL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML2NA(L,JQUAD,M) + &
			WZETAL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,4)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(3,4)  - &
            WEPSILONL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML2PA(L,JQUAD,M)
  
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,2)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,2)  - &
           WEPSILONL(2,L)*DML2NOT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,3)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,3)  + &
           WEPSILONL(2,L)*DML2POT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)
  FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,4)=FRES_TRANO(IQUAD,JQUAD,M)%PHMX(4,4)  + &
           WDELTAL(2,L)*DML0OT(L,IQUAD,JQUAD,M)*DML0A(L,JQUAD,M)

ENDDO
ENDDO
ENDDO
ENDDO

END SUBROUTINE RTWVSF


! _______ROUGH SURFACE REFLECTION AND TRANSMISSION
SUBROUTINE RTSWVSF
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

INTEGER(I4B) ::L,M,JQUAD,MAXMS
!real*8::rtmp
MAXMS=MAX(MAXMORD,MAXSORD)
ALLOCATE(SFRES_REFLA(NQDAD2+1:NQUADA,0:MAXMS))
                  
IF(NQUADSO>1 .AND. (.NOT. OCEAN_NO_TRAN))    &
   ALLOCATE(SFRES_TRANA(NQUADSO,0:MAXMS))

IF(.NOT. OSFREXP) RETURN 

! SUN LIGHT ROUGH SURFACE BIDIRECTIONAL REFLECTANCE, INCIDENT FROM AIR

DO JQUAD=NQDAD2+1,NQUADA
DO M=0,MAXSORD
SFRES_REFLA(JQUAD,M)%PHMX(:,:)=0.0D0
DO L=M,MAXSORD

  SFRES_REFLA(JQUAD,M)%PHMX(1,1)=SFRES_REFLA(JQUAD,M)%PHMX(1,1)+ &
                 WBETAL(1,L)*SDML0(L,M)*DML0A(L,JQUAD,M)
  IF(SCL)CYCLE
  
  SFRES_REFLA(JQUAD,M)%PHMX(1,2)=SFRES_REFLA(JQUAD,M)%PHMX(1,2)+ &
                 WGAMMAL(1,L)*SDML2P(L,M)*DML0A(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(1,3)=SFRES_REFLA(JQUAD,M)%PHMX(1,3) - &
                 WGAMMAL(1,L)*SDML2N(L,M)*DML0A(L,JQUAD,M)

  SFRES_REFLA(JQUAD,M)%PHMX(2,1)=SFRES_REFLA(JQUAD,M)%PHMX(2,1)+ &
            WGAMMAL(1,L)*SDML0(L,M)*DML2PA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(2,2)=SFRES_REFLA(JQUAD,M)%PHMX(2,2)+ &
            WALPHAL(1,L)*SDML2P(L,M)*DML2PA(L,JQUAD,M) + &
			WZETAL(1,L)*SDML2N(L,M)*DML2NA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(2,3)=SFRES_REFLA(JQUAD,M)%PHMX(2,3)  - &
		    WALPHAL(1,L)*SDML2N(L,M)*DML2PA(L,JQUAD,M) - &
			WZETAL(1,L)*SDML2P(L,M)*DML2NA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(2,4)=SFRES_REFLA(JQUAD,M)%PHMX(2,4) + &
		    WEPSILONL(1,L)*SDML0(L,M)*DML2NA(L,JQUAD,M)
  

 SFRES_REFLA(JQUAD,M)%PHMX(3,1)=SFRES_REFLA(JQUAD,M)%PHMX(3,1) - &
          WGAMMAL(1,L)*SDML0(L,M)*DML2NA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(3,2)=SFRES_REFLA(JQUAD,M)%PHMX(3,2)  - &
		    WALPHAL(1,L)*SDML2P(L,M)*DML2NA(L,JQUAD,M) - &
			WZETAL(1,L)*SDML2N(L,M)*DML2PA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(3,3)=SFRES_REFLA(JQUAD,M)%PHMX(3,3)  + &
            WALPHAL(1,L)*SDML2N(L,M)*DML2NA(L,JQUAD,M) + &
			WZETAL(1,L)*SDML2P(L,M)*DML2PA(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(3,4)=SFRES_REFLA(JQUAD,M)%PHMX(3,4)  - &
            WEPSILONL(1,L)*SDML0(L,M)*DML2PA(L,JQUAD,M)
  
  SFRES_REFLA(JQUAD,M)%PHMX(4,2)=SFRES_REFLA(JQUAD,M)%PHMX(4,2)  - &
                 WEPSILONL(1,L)*SDML2N(L,M)*DML0A(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(4,3)=SFRES_REFLA(JQUAD,M)%PHMX(4,3)  + &
                 WEPSILONL(1,L)*SDML2P(L,M)*DML0A(L,JQUAD,M)
  SFRES_REFLA(JQUAD,M)%PHMX(4,4)=SFRES_REFLA(JQUAD,M)%PHMX(4,4)  + &
                 WDELTAL(1,L)*SDML0(L,M)*DML0A(L,JQUAD,M)


ENDDO
ENDDO
ENDDO

IF(NQUADSO==1 .AND. (.NOT. OCEAN_NO_TRAN) )RETURN

! LIGHT INCIDENT FROM AIR, TRANSMISSION
DO JQUAD=1,NQUADSO
DO M=0,MAXSORD

SFRES_TRANA(JQUAD,M)%PHMX(:,:)=0.0D0
DO L=M,MAXSORD
  SFRES_TRANA(JQUAD,M)%PHMX(1,1)=SFRES_TRANA(JQUAD,M)%PHMX(1,1)+ &
            WBETAL(2,L)*SDML0(L,M)*DML0SO(L,JQUAD,M)

  IF(SCL)CYCLE

  SFRES_TRANA(JQUAD,M)%PHMX(1,2)=SFRES_TRANA(JQUAD,M)%PHMX(1,2)+ &
            WGAMMAL(2,L)*SDML2P(L,M)*DML0SO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(1,3)=SFRES_TRANA(JQUAD,M)%PHMX(1,3) - &
            WGAMMAL(2,L)*SDML2N(L,M)*DML0SO(L,JQUAD,M)

  SFRES_TRANA(JQUAD,M)%PHMX(2,1)=SFRES_TRANA(JQUAD,M)%PHMX(2,1)+ &
            WGAMMAL(2,L)*SDML0(L,M)*DML2PSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(2,2)=SFRES_TRANA(JQUAD,M)%PHMX(2,2)+ &
            WALPHAL(2,L)*SDML2P(L,M)*DML2PSO(L,JQUAD,M) + &
			WZETAL(2,L)*SDML2N(L,M)*DML2NSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(2,3)=SFRES_TRANA(JQUAD,M)%PHMX(2,3)  - &
		    WALPHAL(2,L)*SDML2N(L,M)*DML2PSO(L,JQUAD,M) - &
			WZETAL(2,L)*SDML2P(L,M)*DML2NSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(2,4)=SFRES_TRANA(JQUAD,M)%PHMX(2,4) + &
            WEPSILONL(2,L)*SDML0(L,M)*DML2NSO(L,JQUAD,M)
  

  SFRES_TRANA(JQUAD,M)%PHMX(3,1)=SFRES_TRANA(JQUAD,M)%PHMX(3,1) - &
                 WGAMMAL(2,L)*SDML0(L,M)*DML2NSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(3,2)=SFRES_TRANA(JQUAD,M)%PHMX(3,2)  - &
		    WALPHAL(2,L)*SDML2P(L,M)*DML2NSO(L,JQUAD,M) - &
			WZETAL(2,L)*SDML2N(L,M)*DML2PSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(3,3)=SFRES_TRANA(JQUAD,M)%PHMX(3,3)  + &
            WALPHAL(2,L)*SDML2N(L,M)*DML2NSO(L,JQUAD,M) + &
			WZETAL(2,L)*SDML2P(L,M)*DML2PSO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(3,4)=SFRES_TRANA(JQUAD,M)%PHMX(3,4)  - &
                 WEPSILONL(2,L)*SDML0(L,M)*DML2PSO(L,JQUAD,M)
  
  SFRES_TRANA(JQUAD,M)%PHMX(4,2)=SFRES_TRANA(JQUAD,M)%PHMX(4,2)  - &
                 WEPSILONL(2,L)*SDML2N(L,M)*DML0SO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(4,3)=SFRES_TRANA(JQUAD,M)%PHMX(4,3)  + &
                 WEPSILONL(2,L)*SDML2P(L,M)*DML0SO(L,JQUAD,M)
  SFRES_TRANA(JQUAD,M)%PHMX(4,4)=SFRES_TRANA(JQUAD,M)%PHMX(4,4)  + &
                 WDELTAL(2,L)*SDML0(L,M)*DML0SO(L,JQUAD,M)

ENDDO
ENDDO
ENDDO

END SUBROUTINE RTSWVSF

!________ROUGH SURFACE OVER

SUBROUTINE DMM0FUNC(MORDMAX)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

INTEGER, INTENT(IN)::MORDMAX
INTEGER :: MMAX
REAL*8 :: RTMP,RTMP1

INTEGER :: M

DMM0FCTR(0)=1.0D0

IF(MORDMAX<1)RETURN

DMM0FCTR(1)=DSQRT(2.0D0)

IF(MORDMAX<2)RETURN

DO MMAX=2,MORDMAX

RTMP=1.0D0
RTMP1=2.0D0
DO M=1,MMAX-1
  RTMP=RTMP*(1.0D0-DFLOAT(M)/DFLOAT(MMAX))
  RTMP1=RTMP1*(2.0D0-DFLOAT(M)/DFLOAT(MMAX))
ENDDO
DMM0FCTR(MMAX)=DSQRT(RTMP1)/DSQRT(RTMP)

ENDDO

END SUBROUTINE DMM0FUNC

SUBROUTINE DMM2FUNC(MORDMAX)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
INTEGER, INTENT(IN)::MORDMAX
INTEGER :: MMAX
REAL*8 :: RTMP,RTMP1

INTEGER :: M
!MORDMAX=MAX(MAXMORD,MAXSORD)
DMM2FCTR(0)=1.0D0

IF(MORDMAX<1)RETURN

DMM2FCTR(1)=1.0D0

IF(MORDMAX<2)RETURN

DO MMAX=2,MORDMAX
RTMP=(1.0D0+1.0D0/DFLOAT(MMAX))*(1.0D0+2.0D0/DFLOAT(MMAX))
RTMP1=2.0D0*(1.0D0-1.0D0/DFLOAT(MMAX))
DO M=1,MMAX-1
  RTMP=RTMP*(1.0D0-DFLOAT(M)/DFLOAT(MMAX))
  RTMP1=RTMP1*(2.0D0-DFLOAT(M)/DFLOAT(MMAX))
ENDDO
DMM2FCTR(MMAX)=DSQRT(RTMP1)/DSQRT(RTMP)
ENDDO

END SUBROUTINE DMM2FUNC




REAL*8 FUNCTION expbessi(n,x)
INTEGER n,IACC
REAL*8 bessi,x,BIGNO,BIGNI
PARAMETER (IACC=10000,BIGNO=1.0d38,BIGNI=1.0d-38)
!U    USES bessi0
INTEGER j,m
REAL*8 bi,bim,bip,tox,bessi0,BESEI1,BESEI0
!REAL*8 mutmp,fln,pi,sqrttwopi,eightbr
!REAL*8 expbessi0,expbessi1
! if(x>1.0D4)then !use asymptotic expansion
!   fln=dfloat(n)
!   mutmp=4.0d0*fln*fln
!   pi=3.141592653589793238462643383279502884197d0
!   sqrttwopi=dsqrt(2.0d0*pi)
!	eightbr=8.0d0*x
!	expbessi=1.0d0/sqrttwopi/dsqrt(x)*&
!     (1.0d0-(mutmp-1.0d0)/eightbr*(1.0d0-0.5d0*(mutmp-9.0d0)/eightbr))
!   return
! endif

      IF(n==0)then
!	     expbessi=expbessi0(x)
		 expbessi=BESEI0(x)
		 return
	  ELSE IF(n==1) then
!	     expbessi=expbessi1(x)
         expbessi=BESEI1(X)
		 return
      ENDIF
!	  if (n.lt.2) stop 'bad argument n in bessi, n<2'
      if (x.eq.0.0d0) then
        bessi=0.0D0
      else
        tox=2.0D0/abs(x)
        bip=0.0D0
        bi=1.0D0
        bessi=0.0D0
        m=2*((n+int(dsqrt(dfloat(IACC*n)))))
        do j=m,1,-1
          bim=bip+dfloat(j)*tox*bi
          bip=bi
          bi=bim
          if (abs(bi).gt.BIGNO) then
            bessi=bessi*BIGNI
            bi=bi*BIGNI
            bip=bip*BIGNI
          endif
          if (j.eq.n) bessi=bip
        enddo
!        expbessi=bessi*expbessi0(x)/bi
         expbessi=bessi*BESEI0(x)/bi
        if (x.lt.0.0D0.and.mod(n,2).eq.1.0d0) expbessi=-expbessi
      endif
      return
      END


      REAL*8 FUNCTION expbessi0(x)
      REAL*8 bessi0,x
      REAL*8 ax
      REAL*8 p1,p2,p3,p4,p5,p6,p7,q1,q2,q3,q4,q5,q6,q7,q8,q9,y
      SAVE p1,p2,p3,p4,p5,p6,p7,q1,q2,q3,q4,q5,q6,q7,q8,q9
      DATA p1,p2,p3,p4,p5,p6,p7/1.0d0,3.5156229d0,3.0899424d0,  &
		   1.2067492d0,0.2659732d0,0.360768d-1,0.45813d-2/
      DATA q1,q2,q3,q4,q5,q6,q7,q8,q9/0.39894228d0,0.1328592d-1,      &
      0.225319d-2,-0.157565d-2,0.916281d-2,-0.2057706d-1,0.2635537d-1,&
      -0.1647633d-1,0.392377d-2/
      ax=abs(x)
      if (abs(x).lt.3.75d0) then
        y=(x/3.75d0)**2
        bessi0=p1+y*(p2+y*(p3+y*(p4+y*(p5+y*(p6+y*p7)))))
        expbessi0=dexp(-ax)*bessi0
      else
        y=3.75d0/ax
!        bessi0=(exp(ax)/sqrt(ax))*(q1+y*(q2+y*(q3+y*(q4   &
!		        +y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))))
        expbessi0=(1.0d0/dsqrt(ax))*(q1+y*(q2+y*(q3+y*(q4   &
		        +y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))))

      endif
      return
      END

      REAL*8 FUNCTION expbessi1(x)
      REAL*8 bessi1,x
      REAL*8 ax
      REAL*8 p1,p2,p3,p4,p5,p6,p7,q1,q2,q3,q4,q5,q6,q7,q8,q9,y
      SAVE p1,p2,p3,p4,p5,p6,p7,q1,q2,q3,q4,q5,q6,q7,q8,q9
      DATA p1,p2,p3,p4,p5,p6,p7/0.5d0,0.87890594d0,0.51498869d0, &
           0.15084934d0,0.2658733d-1,0.301532d-2,0.32411d-3/
      DATA q1,q2,q3,q4,q5,q6,q7,q8,q9/0.39894228d0,-0.3988024d-1, &
        -0.362018d-2,0.163801d-2,-0.1031555d-1,0.2282967d-1,-0.2895312d-1, &
        0.1787654d-1,-0.420059d-2/
      ax=abs(x)
      if (abs(x).lt.3.75d0) then
        y=(x/3.75D0)**2
        bessi1=x*(p1+y*(p2+y*(p3+y*(p4+y*(p5+y*(p6+y*p7))))))
        expbessi1=dexp(-ax)*bessi1
      else
        y=3.75D0/ax
!        bessi1=(exp(ax)/sqrt(ax))*(q1+y*(q2+y*(q3+y*(q4    &
!		       +y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))))
        expbessi1=(1.0d0/dsqrt(ax))*(q1+y*(q2+y*(q3+y*(q4    &
		       +y*(q5+y*(q6+y*(q7+y*(q8+y*q9))))))))

        if(x.lt.0.0D0)bessi1=-bessi1
      endif
      return
      END

	subroutine myspline(n,x,y,nn,xn,yn)

!c---------spline fit to derive the yy value at point xx

!c  Inputs:
!c     n:    the length of x and y
!c     x(n): the x values which x(1) < x(2) ... < x(n)
!c     y(n): the y value which correspondent to x(n)
!c     nn:  the length of vector xx and yy
!c     xn:  the x value at which y value is wanted
!c

!c  Outputs:

!c     yn: the wanted y value from the fitting
!c  Internal variables:

!c     yp1: the derivative of y over x at x(1), for natural bc, yp1=1.e31
!c     ypn: the derivative of y over x at x(n), for natural bc, ypn=1.e31
!c     y2(n): the second derivatives

      integer n,nn,ny2,i
      parameter (ny2=5000) 
      real*8 x(*),y(*),xn(*),yn(*),y2(ny2),xx,yy,yp1,ypn

!c--------the sorting which makes sure x(1)<x(2)<...<x(n)-------

!        call sort2(n,x,y) 

!c--------start spline------------

        yp1=1.e31
        ypn=1.e31

!    yp1=(y(2)-y(1))/(x(2)-x(1))
!	ypn=(y(n)-y(n-1))/(x(n)-x(n-1))
	
	call spline2(x,y,n,yp1,ypn,y2)
	do i=1,nn
        xx = xn(i)
        call splint2(x,y,y2,n,xx,yy)
        yn(i) = yy
	enddo

	return

   	end 

	



      SUBROUTINE spline2(x,y,n,yp1,ypn,y2) 

      INTEGER n,NMAX, ny2
      PARAMETER (NMAX=5000) 
      parameter (ny2=5000) 
      real*8 yp1,ypn,x(n),y(n),y2(ny2) 
      INTEGER i,k 
      real*8 p,qn,sig,un,u(NMAX) 

      if (yp1.gt..99e30) then 
        y2(1)=0.0d0 
        u(1)=0.0d0 
      else 
        y2(1)=-0.50d0 
        u(1)=(3.0d0/(x(2)-x(1)))*((y(2)-y(1))/(x(2)-x(1))-yp1) 
      endif 

      do i=2,n-1 

        sig=(x(i)-x(i-1))/(x(i+1)-x(i-1)) 
        p=sig*y2(i-1)+2.0d0 
        y2(i)=(sig-1.0d0)/p 

        u(i)=(6.0d0*((y(i+1)-y(i))/(x(i+1)      &
    -x(i))-(y(i)-y(i-1))/(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig*    & 
     u(i-1))/p 

      enddo 

      if (ypn.gt..99e30) then 
        qn=0.0d0 
        un=0.0d0 
      else 
        qn=0.50d0 
        un=(3.0d0/(x(n)-x(n-1)))*(ypn-(y(n)-y(n-1))/(x(n)-x(n-1))) 
      endif 

      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.0d0) 

      do k=n-1,1,-1 
        y2(k)=y2(k)*y2(k+1)+u(k) 
      enddo

      return 

      END 



      SUBROUTINE splint2(xa,ya,y2a,n,x,y) 

      INTEGER n 
      real*8 x,y,xa(n),y2a(n),ya(n) 
      INTEGER k,khi,klo 
      real*8 a,b,h 

      klo=1 
      khi=n 

100     if (khi-klo.gt.1) then 

        k=(khi+klo)/2 

        if(xa(k).gt.x)then 
          khi=k 
        else 
          klo=k 
        endif 

      goto 100 

      endif 

      h=xa(khi)-xa(klo) 
      if (h.eq.0.0d0) stop 'bad xa input in splint' 

      a=(xa(khi)-x)/h 
      b=(x-xa(klo))/h 

       y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+ &
        (b**3-b)*y2a(khi))*(h*h)/6.0d0 

      return 

      END 

      SUBROUTINE RMATRIX(SA,SB,SC,SPHI,FA,FB,FC,FPHI,SLI1,SLI2)
      implicit none
      REAL*8, INTENT(IN) :: SA,SB,SC,FA,FB,FC
	  REAL*8 :: SPHI,FPHI
      REAL*8, DIMENSION(4,4),INTENT(OUT) :: SLI1, SLI2
      REAL*8 :: COSA,COSB,COSC,SINA,SINB,SINC, &
                  COSP,SINP,WTEMP,DOPY,FUD,PI,TWOPI,TINY2
      INTEGER :: I
      
      PI=3.141592653589793238462643383279502884197d0
	  TWOPI=2.0D0*PI
	  TINY2=0.000001D0
	  
      IF(SPHI<0.0d0) THEN
	    SPHI=SPHI+TWOPI
      ELSE IF(SPHI>=TWOPI)THEN
	    SPHI=SPHI-TWOPI
	  ENDIF

      IF(FPHI<0.0d0) THEN
	    FPHI=FPHI+TWOPI
      ELSE IF(FPHI>=TWOPI)THEN
	    FPHI=FPHI-TWOPI
	  ENDIF

      IF(FPHI<0.0d0 .OR. FPHI>=TWOPI) WRITE(*,*) "FPHI IS NOT IN 0-2PI"
      IF(SPHI<0.0d0 .OR. SPHI>=TWOPI) WRITE(*,*) "SPHI IS NOT IN 0-2PI"


      SLI1=0.0d0
      SLI2=0.0d0
      DO I=1,4
          SLI1(I,I)=1.0d0
          SLI2(I,I)=1.0d0
      ENDDO

      IF(ABS(FPHI-SPHI)<TINY2) RETURN

!     ROTATION MATRIX

           COSA=FC
           COSB=SC
           COSC=SA*FA+SB*FB+SC*FC

           IF(ABS(COSC)>1.0d0) COSC=COSC/ABS(COSC)

           SINA=SQRT(ABS(1.0d0-COSA**2))
           SINB=SQRT(ABS(1.0d0-COSB**2))
           SINC=SQRT(ABS(1.0d0-COSC**2))
          
           IF(ABS(SINC)<TINY2) THEN
             IF(ABS(SINB)>TINY2) RETURN
             IF(COSA>0.0d0) THEN
                 FUD=-1.0d0
             ELSE 
                 FUD=1.0d0
             ENDIF
             SLI2(2,2)=COS(2.0d0*(FPHI-SPHI))
             SLI2(2,3)=FUD*SIN(2.0d0*(FPHI-SPHI))
             SLI2(3,2)=-SLI2(2,3)
             SLI2(3,3)=SLI2(2,2)
             RETURN
           ENDIF


!       SPHERICAL TRIANGLE FORMULA

           IF (ABS(SINB)<TINY2) THEN
              IF(COSB>0.0d0) THEN
                 FUD=-1.0d0
              ELSE 
                 FUD=1.0d0
              ENDIF
              SLI1(2,2)=COS(2.0d0*(FPHI-SPHI))
              SLI1(2,3)=FUD*SIN(2.0d0*(FPHI-SPHI))
              SLI1(3,2)=-SLI1(2,3)
              SLI1(3,3)=SLI1(2,2)
              RETURN
           ENDIF
           

           IF(ABS(SINA)<TINY2) THEN
              IF(COSA>0.0d0) THEN
                  FUD=-1.0d0
              ELSE 
                  FUD=1.0d0
              ENDIF
              SLI2(2,2)=COS(2.0d0*(FPHI-SPHI))
              SLI2(2,3)=FUD*SIN(2.0d0*(FPHI-SPHI))
              SLI2(3,2)=-SLI2(2,3)
              SLI2(3,3)=SLI2(2,2)
              RETURN
           ENDIF

           COSP=(COSA-COSB*COSC)/(SINB*SINC)
           IF(ABS(COSP)>1.0d0) COSP=COSP/ABS(COSP)
           SINP=SQRT(ABS(1.0d0-COSP**2))

!        RENORMALIZATION
           WTEMP=SQRT(SINP**2+COSP**2)
           SINP=SINP/WTEMP
           COSP=COSP/WTEMP

           DOPY=SB*FA-SA*FB
           IF (DOPY>0.0d0) THEN
              FUD=-1.0d0
           ELSE
              FUD=1.0d0
           ENDIF


           SLI1(2,2)=COSP**2-SINP**2
           SLI1(2,3)=2.0d0*COSP*SINP*FUD
           SLI1(3,2)=-SLI1(2,3)
           SLI1(3,3)=SLI1(2,2)

!      CALCULATE ROTATION MATRIX 2

           COSP=(COSB-COSA*COSC)/(SINA*SINC)
           IF(ABS(COSP)>1.0d0) COSP=COSP/ABS(COSP)
           SINP=SQRT(ABS(1.0d0-COSP**2))

!      RENORMALIZATION
           WTEMP=SQRT(SINP**2+COSP**2)
           SINP=SINP/WTEMP
           COSP=COSP/WTEMP

           SLI2(2,2)=COSP**2-SINP**2
           SLI2(2,3)=2.0d0*COSP*SINP*FUD
           SLI2(3,2)=-SLI2(2,3)
           SLI2(3,3)=SLI2(2,2)

      END SUBROUTINE RMATRIX
SUBROUTINE DMLINIT(LMAX,MMAX)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE
INTEGER :: LMAX,MMAX
INTEGER :: L
ALLOCATE(DMM0FCTR(0:MMAX),DMM2FCTR(0:MMAX),   &
         COEF1(0:LMAX),COEF2(0:LMAX),       &
         COEF3(0:LMAX),COEF4(0:LMAX),       &
         COEF5(0:LMAX),COEF6(0:LMAX)       )

CALL DMM0FUNC(MMAX)
CALL DMM2FUNC(MMAX)

DO L=0,LMAX
   COEF1(L)=DFLOAT(2*L+1) 
   COEF2(L)=DFLOAT(L*L)                                            
   COEF3(L)=DFLOAT((L+1)*(L+1))

   COEF4(L)=DFLOAT(L*(L+1))
   COEF5(L)=DFLOAT(L+1)*SQRT(max(0.0d0,(L*L-4.0d0)))
   COEF6(L)=DFLOAT(L)*SQRT(max(0.0d0,((L+1)*(L+1)-4.0d0)))
!   COEF5(L)=DFLOAT(L+1)*DSQRT(DFLOAT(L*L-4))
!   COEF6(L)=DFLOAT(L)*DSQRT(DFLOAT((L+1)*(L+1)-4))
ENDDO

END SUBROUTINE DMLINIT

SUBROUTINE DMLSPEC(U,LMAX,MMAX,WD0,WD2,WDN2)
USE RTTYPE
USE RTUTILITY
IMPLICIT NONE

REAL(DP),INTENT(IN) :: U
INTEGER,INTENT(IN) :: LMAX,MMAX
REAL(DP),DIMENSION(0:LMAX,0:MMAX),INTENT(OUT) :: WD0,WD2,WDN2

INTEGER(I4B) ::L,M

REAL(DP) :: DUP,DUM,DU,ONEMU2,D6,MSQ,SGNF,TWOFM,&
      TMT,DML0LN1,DML2LN1,DMLN2LN1

  WD0=0.0D0
  WD2=0.0D0
  WDN2=0.0D0

  DUP=1.0D0+U                                                                 
  DUM=1.0D0-U
  ONEMU2=DUP*DUM                                 
  DU=U*U
  D6=DSQRT(6.0D0)*0.25D0

!  LOOP OVER ORDER M

  TWOFM=0.5D0
  SGNF=-1.0D0
  WD2(2,0)=D6*ONEMU2
  WDN2(2,0)=D6*ONEMU2
  IF(MMAX>0)THEN
     WD2(2,1)=0.5D0*DSQRT(ONEMU2)*DUP
     WDN2(2,1)=-0.5D0*DSQRT(ONEMU2)*DUM
  ENDIF
DO M=0,MMAX

	MSQ=DFLOAT(M*M)
    SGNF=-SGNF
	TWOFM=2.0D0*TWOFM
	TMT=2.0D0*DFLOAT(M)
	
	WD0(M,M)=SGNF*DMM0FCTR(M)*DSQRT(ONEMU2**M)/TWOFM

	IF(M>=2)THEN
      WD2(M,M)=SGNF*DMM2FCTR(M)*                     &
             DSQRT((DUM**(M-2)) * (DUP**(M+2)))/TWOFM
	  WDN2(M,M)=SGNF*DMM2FCTR(M)*                    &
	         DSQRT((DUM**(M+2)) * (DUP**(M-2)))/TWOFM
    ENDIF

    IF(M==LMAX) RETURN

   ! LOOP OVER ORDER L
DO L=M,LMAX-1

! RECURRENCE FOR d^l_{m,0}
      IF(L-1<M)THEN 
        DML0LN1=0.0D0
	  ELSE
        DML0LN1=WD0(L-1,M)
      ENDIF
      WD0(L+1,M)=(COEF1(L)*U*WD0(L,M)       &
			-DSQRT(COEF2(L)-MSQ)*DML0LN1      ) &
			/DSQRT(COEF3(L)-MSQ)

! RECURRENCE FOR d^l_{m,2}

IF(L>=2)THEN

   IF(L-1<M)THEN 
     DML2LN1=0.0D0
     DMLN2LN1=0.0D0
   ELSE
     DML2LN1=WD2(L-1,M)
     DMLN2LN1=WDN2(L-1,M)
   ENDIF

   WD2(L+1,M)=(COEF1(L)*(COEF4(L)*U - TMT)*WD2(L,M) &
   - COEF5(L)*DSQRT(COEF2(L)-MSQ)*DML2LN1 ) &
   /COEF6(L)/DSQRT(COEF3(L)-MSQ)

   WDN2(L+1,M)=(COEF1(L)*(COEF4(L)*U + TMT)*WDN2(L,M) &
   - COEF5(L)*DSQRT(COEF2(L)-MSQ)*DMLN2LN1  ) &
   /COEF6(L)/DSQRT(COEF3(L)-MSQ)

ENDIF

ENDDO  ! LOOP L OVER
ENDDO   ! LOOP M OVER

END SUBROUTINE DMLSPEC

      SUBROUTINE REFL_TRAN_COXMUNK
      USE RTTYPE
      USE RTUTILITY
      implicit none
      INTEGER:: IMU_CM,NPHI_TMP,NMU_TMP,IMU_TMP,IPHI_TMP
      REAL*8,ALLOCATABLE,DIMENSION(:)::MU_TMP,PHI_TMP
      REAL*8,DIMENSION(4,4)::BRDMO
      REAL*8 DMU_CM,DMU_TMP,DPHI_TMP,RTMP
      NMU_CM=30
      ALLOCATE(MU_CM(NMU_CM),REFL_CM_AT(NMU_CM),TRAN_CM_AT(NMU_CM),&
               REFL_CM_OT(NMU_CM),TRAN_CM_OT(NMU_CM))
      DMU_CM=1.0D0/(NMU_CM*1.0D0)
      DO IMU_CM=1,NMU_CM
         MU_CM(IMU_CM)=IMU_CM*DMU_CM
      ENDDO

      NPHI_TMP=400
      NMU_TMP=100
      DMU_TMP=1.0D0/(1.0D0*NMU_TMP)
      DPHI_TMP=TWOPI/(1.0D0*NPHI_TMP)
      ALLOCATE(MU_TMP(NMU_TMP),PHI_TMP(NPHI_TMP))
      DO IMU_TMP=1,NMU_TMP
        MU_TMP(IMU_TMP)=IMU_TMP*DMU_TMP
      ENDDO
      DO IPHI_TMP=1,NPHI_TMP
        PHI_TMP(IPHI_TMP)=(IPHI_TMP-1.0D0)*DPHI_TMP
      ENDDO

      REFL_CM_AT=0.0D0
      REFL_CM_OT=0.0D0
      TRAN_CM_AT=0.0D0
      TRAN_CM_OT=0.0D0

      DO IMU_CM=1,NMU_CM
!        IF(MU_CM(IMU_CM)<0.1D0)THEN
!          REFL_CM_AT(IMU_CM)=1.0D0
!          TRAN_CM_AT(IMU_CM)=0.0D0
!          CYCLE
!        ENDIF
      DO IMU_TMP=1,NMU_TMP
      DO IPHI_TMP=1,NPHI_TMP
         CALL BRDM_OCEAN(-MU_CM(IMU_CM),0.0D0,MU_TMP(IMU_TMP),&
                   PHI_TMP(IPHI_TMP),NWRE,NWIM,BRDMO)
         RTMP=BRDMO(1,1)*abs(MU_TMP(IMU_TMP))
         REFL_CM_AT(IMU_CM)=REFL_CM_AT(IMU_CM)+RTMP

         CALL BTDM_AT_OCEAN(-MU_CM(IMU_CM),0.0D0,-MU_TMP(IMU_TMP),&
                            PHI_TMP(IPHI_TMP),NWRE,NWIM,BRDMO)
         RTMP=BRDMO(1,1)*abs(MU_TMP(IMU_TMP))
         TRAN_CM_AT(IMU_CM)=TRAN_CM_AT(IMU_CM)+RTMP

         CALL BRDM_OCEAN(MU_CM(IMU_CM),0.0D0,-MU_TMP(IMU_TMP),&
                   PHI_TMP(IPHI_TMP),1.0d0/NWRE,0.0d0,BRDMO)
         RTMP=BRDMO(1,1)*abs(MU_TMP(IMU_TMP))
         REFL_CM_OT(IMU_CM)=REFL_CM_OT(IMU_CM)+RTMP

         CALL BTDM_OT_OCEAN(MU_CM(IMU_CM),0.0D0,MU_TMP(IMU_TMP),&
                            PHI_TMP(IPHI_TMP),1.0d0/NWRE,0.0d0,BRDMO)
         RTMP=BRDMO(1,1)*abs(MU_TMP(IMU_TMP))
         TRAN_CM_OT(IMU_CM)=TRAN_CM_OT(IMU_CM)+RTMP
      ENDDO
      ENDDO
      REFL_CM_AT(IMU_CM)=REFL_CM_AT(IMU_CM)/MU_CM(IMU_CM)/PI*DMU_TMP*DPHI_TMP
      TRAN_CM_AT(IMU_CM)=TRAN_CM_AT(IMU_CM)/MU_CM(IMU_CM)/PI*DMU_TMP*DPHI_TMP
      REFL_CM_OT(IMU_CM)=REFL_CM_OT(IMU_CM)/MU_CM(IMU_CM)/PI*DMU_TMP*DPHI_TMP
      TRAN_CM_OT(IMU_CM)=TRAN_CM_OT(IMU_CM)/MU_CM(IMU_CM)/PI*DMU_TMP*DPHI_TMP

! due to difficulties of calculating TRAN_CM_AT and TRAN_CM_OT at incident mu of 1
! they are calculated using T=1-R
        IF(MU_CM(IMU_CM)>0.98)THEN
            TRAN_CM_AT(IMU_CM)=1.0-REFL_CM_AT(IMU_CM)
            TRAN_CM_OT(IMU_CM)=1.0-REFL_CM_OT(IMU_CM)
        ENDIF

!        RTMP=REFL_CM_AT(IMU_CM)+TRAN_CM_AT(IMU_CM)
!        REFL_CM_AT(IMU_CM)=REFL_CM_AT(IMU_CM)/RTMP
!        TRAN_CM_AT(IMU_CM)=TRAN_CM_AT(IMU_CM)/RTMP

!        RTMP=REFL_CM_OT(IMU_CM)+TRAN_CM_OT(IMU_CM)
!        REFL_CM_OT(IMU_CM)=REFL_CM_OT(IMU_CM)/RTMP
!        TRAN_CM_OT(IMU_CM)=TRAN_CM_OT(IMU_CM)/RTMP
        
!        WRITE(*,*)'AT',MU_CM(IMU_CM),REFL_CM_AT(IMU_CM),TRAN_CM_AT(IMU_CM),&
!                                REFL_CM_AT(IMU_CM)+TRAN_CM_AT(IMU_CM)
!        WRITE(*,*)'OT',MU_CM(IMU_CM),REFL_CM_OT(IMU_CM),TRAN_CM_OT(IMU_CM),&
!                                REFL_CM_OT(IMU_CM)+TRAN_CM_OT(IMU_CM)

      ENDDO
      ENDSUBROUTINE REFL_TRAN_COXMUNK

SUBROUTINE REFL_SEARCH(MU0,ATFLAG,REFL_COEFF)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
REAL*8,INTENT(IN) :: MU0
LOGICAL,INTENT(IN) :: ATFLAG
REAL*8,INTENT(OUT)::REFL_COEFF
REAL*8 :: MU_SEARCH,RTMP
INTEGER :: IULO,MPL,KLO
MU_SEARCH=ABS(MU0)
MPL=3

IULO=INT(FLOAT(NMU_CM)*ABS((MU_SEARCH-MU_CM(1))/(MU_CM(NMU_CM)-MU_CM(1))))
call hunt(MU_CM,NMU_CM,MU_SEARCH,IULO)
KLO=min(max(IULO-(MPL-1)/2,1),NMU_CM+1-MPL)

IF(ATFLAG)THEN
  CALL POLINT(MU_CM(KLO),REFL_CM_AT(KLO),MPL,MU_SEARCH,REFL_COEFF,RTMP)
ELSE
  CALL POLINT(MU_CM(KLO),REFL_CM_OT(KLO),MPL,MU_SEARCH,REFL_COEFF,RTMP)
ENDIF

END SUBROUTINE REFL_SEARCH

SUBROUTINE TRAN_SEARCH(MU0,ATFLAG,TRAN_COEFF)
USE RTTYPE
USE RTUTILITY
USE PHASE_MATRIX_TRUNCATION
IMPLICIT NONE
REAL*8,INTENT(IN) :: MU0
LOGICAL,INTENT(IN) :: ATFLAG
REAL*8,INTENT(OUT)::TRAN_COEFF
REAL*8 :: MU_SEARCH,RTMP
INTEGER :: IULO,MPL,KLO
MU_SEARCH=ABS(MU0)
MPL=3

IULO=INT(FLOAT(NMU_CM)*ABS((MU_SEARCH-MU_CM(1))/(MU_CM(NMU_CM)-MU_CM(1))))
call hunt(MU_CM,NMU_CM,MU_SEARCH,IULO)
KLO=min(max(IULO-(MPL-1)/2,1),NMU_CM+1-MPL)

IF(ATFLAG)THEN
  CALL POLINT(MU_CM(KLO),TRAN_CM_AT(KLO),MPL,MU_SEARCH,TRAN_COEFF,RTMP)
ELSE
  CALL POLINT(MU_CM(KLO),TRAN_CM_OT(KLO),MPL,MU_SEARCH,TRAN_COEFF,RTMP)
ENDIF

END SUBROUTINE TRAN_SEARCH

SUBROUTINE FRSNL_T2(NRE,NIM,THETA1,FRES_TRAN)
USE RTTYPE
USE RTUTILITY,ONLY : SCL
IMPLICIT NONE
REAL(DP),INTENT(IN) :: NRE,NIM,THETA1
REAL(DP),DIMENSION(4,4),INTENT(OUT) :: FRES_TRAN

REAL(DP) :: THETA2,SINT1,COST1,ALPHA2,BETA2,SINT2,COST2
COMPLEX*16::UNIT_COM,NREL,NREL2,ALPHA,BETA,GAMMA

UNIT_COM=(0.0D0,1.0D0)
NREL=NRE+NIM*UNIT_COM
NREL2=NREL*NREL
SINT1=SIN(THETA1)
COST1=COS(THETA1)
SINT2=SINT1*SINT1
IF(SINT1/NRE>1.0D0)THEN
  FRES_TRAN=0.0_DP
  RETURN
ENDIF
THETA2=ASIN(SINT1/NRE)
COST2=COS(THETA2)

ALPHA=2.0D0*NREL*COST1/(NREL2*COST1+SQRT(NREL2-SINT2))
BETA=2.0D0*COST1/(COST1+SQRT(NREL2-SINT2))

GAMMA=NRE*CONJG(ALPHA)*BETA/COST1*COST2
ALPHA2=0.5D0*NRE*(ABS(ALPHA)**2)/COST1*COST2
BETA2=0.5D0*NRE*(ABS(BETA)**2)/COST1*COST2

FRES_TRAN=0.0_DP

FRES_TRAN(1,1)=ALPHA2+BETA2

IF(SCL)RETURN

FRES_TRAN(1,2)=ALPHA2-BETA2
FRES_TRAN(2,1)=FRES_TRAN(1,2)
FRES_TRAN(2,2)=FRES_TRAN(1,1)
FRES_TRAN(3,3)=REAL(GAMMA)
FRES_TRAN(4,4)=FRES_TRAN(3,3)

FRES_TRAN(3,4)=-IMAG(GAMMA)
FRES_TRAN(4,3)=-FRES_TRAN(3,4)

!TESTING ERROR ANALYSIS FOR IGNORING POLARIZATION 
!CAUSED BY FRESNEL TRANSMISSION

!FRES_TRAN(1,2)=0.0D0
!FRES_TRAN(2,1)=0.0D0
!FRES_TRAN(2,2)=0.0D0
!FRES_TRAN(3,3)=0.0D0
!FRES_TRAN(4,4)=0.0D0
!FRES_TRAN(3,4)=0.0D0
!FRES_TRAN(4,3)=0.0D0

END SUBROUTINE FRSNL_T2

SUBROUTINE FRSNL_R2(NRE,NIM,THETA1,FRES_REFL)
USE RTTYPE
USE RTUTILITY,ONLY : SCL

IMPLICIT NONE
REAL(DP),INTENT(IN) :: NRE,NIM,THETA1
REAL(DP),DIMENSION(4,4),INTENT(OUT) :: FRES_REFL

REAL(DP) :: SINT1,COST1,SINT2,ALPHA2,BETA2
COMPLEX*16::UNIT_COM,NREL,NREL2,CFCT1,CFCT2,ALPHA,BETA,GAMMA

!IF(THETA1<0 .OR. THETA1>PI/2) then
!   write(*,*) 'theta2-',THETA2
!   STOP 'THETA1 WRONG'
!ENDIF

UNIT_COM=(0.0D0,1.0D0)
NREL=NRE+NIM*UNIT_COM
NREL2=NREL*NREL
SINT1=SIN(THETA1)
COST1=COS(THETA1)
SINT2=SINT1*SINT1

CFCT1=NREL2*COST1
CFCT2=CDSQRT(NREL2-SINT2)
ALPHA=(CFCT1-CFCT2)/(CFCT1+CFCT2)
  
CFCT1=COST1
CFCT2=CDSQRT(NREL2-SINT2)
BETA=(CFCT1-CFCT2)/(CFCT1+CFCT2)

GAMMA= CONJG(ALPHA)*BETA

ALPHA2=0.5D0*ABS(ALPHA)**2
BETA2=0.5D0*ABS(BETA)**2

FRES_REFL=0.0D0

FRES_REFL(1,1)=ALPHA2+BETA2
IF(SCL)RETURN
FRES_REFL(1,2)=ALPHA2-BETA2
FRES_REFL(2,1)=FRES_REFL(1,2)
FRES_REFL(2,2)=FRES_REFL(1,1)
FRES_REFL(3,3)=REAL(GAMMA)
FRES_REFL(4,4)=FRES_REFL(3,3)
FRES_REFL(3,4)=-IMAG(GAMMA)
FRES_REFL(4,3)=-FRES_REFL(3,4)

END SUBROUTINE FRSNL_R2


! fresnel reflectance subroutine sample calling
!  CALL FRESNELL_R(NAIR,NWRE,THETA1,THETA2,MTRX1)
! for air incidence
! or
!  CALL FRESNELL_R(NWRE,NAIR,THETA1,THETA2,MTRX1)
! for water incidence

!SUBROUTINE FRESNELL_R(N1,N2,THETA1,THETA2,FRES_REFL)
!IMPLICIT NONE
!REAL*8,INTENT(IN) :: N1,N2,THETA1,THETA2
!REAL*8,DIMENSION(4,4),INTENT(OUT) :: FRES_REFL

!REAL*8 :: NREL,NREL2,GAMMA_RE,GAMMA_IM,ALPHA,BETA,  &
!        THETAT,SINT1,COST1,SINT1S,SINT2,          &
!        SINT1M2,SINT1P2,TANT1M2,TANT1P2
!COMPLEX*16::GAMMA_COM,UNIT_COM

!SINT1=SIN(THETA1)
!NREL=N2/N1

!IF(SINT1<1.0E-8)THEN

!  ALPHA=(1.0D0-NREL)/(1.0D0+NREL)
!  BETA=(1.0D0-NREL)/(1.0D0+NREL)
  
!  GAMMA_RE=-ALPHA*BETA
  
!  ALPHA=0.5D0*ALPHA*ALPHA
!  BETA=0.5D0*BETA*BETA

!  FRES_REFL=0.0D0

!  FRES_REFL(1,1)=ALPHA+BETA
!  FRES_REFL(2,2)=FRES_REFL(1,1)
!  FRES_REFL(3,3)=GAMMA_RE
!  FRES_REFL(4,4)=GAMMA_RE
!  RETURN

!ENDIF


!IF((N1>N2).AND.(SINT1>NREL)) THEN !TOTAL REFLECTION
!  UNIT_COM=(0.0,1.0)
!  COST1=COS(THETA1)
!  SINT1S=SINT1*SINT1
!  NREL2=NREL*NREL
!  GAMMA_COM=(NREL2*COST1+UNIT_COM*SQRT(SINT1S-NREL2)) &
!         *(COST1-UNIT_COM*SQRT(SINT1S-NREL2))       &
!         /(NREL2*COST1-UNIT_COM*SQRT(SINT1S-NREL2)) &
!         /(COST1+UNIT_COM*SQRT(SINT1S-NREL2))

!  GAMMA_RE=DREAL(GAMMA_COM)
!  GAMMA_IM=DIMAG(GAMMA_COM)

!  FRES_REFL=0.0D0

!  FRES_REFL(1,1)=1.0D0
!  FRES_REFL(2,2)=1.0D0
!  FRES_REFL(3,3)=GAMMA_RE
!  FRES_REFL(4,4)=GAMMA_RE
!  FRES_REFL(3,4)=-GAMMA_IM
!  FRES_REFL(4,3)=GAMMA_IM

!ELSE
!  SINT2=N1*SINT1/N2
!  THETAT=ASIN(SINT2)
!  TANT1M2=TAN(THETA1-THETAT)
!  TANT1P2=TAN(THETA1+THETAT)

!  SINT1M2=SIN(THETA1-THETAT)
!  SINT1P2=SIN(THETA1+THETAT)
  
!  ALPHA=TANT1M2/TANT1P2
!  BETA=SINT1M2/SINT1P2
!  GAMMA_RE= -ALPHA*BETA

!  ALPHA=0.5D0*ALPHA*ALPHA
!  BETA=0.5D0*BETA*BETA

!  FRES_REFL=0.0D0

!  FRES_REFL(1,1)=ALPHA+BETA
!  FRES_REFL(1,2)=ALPHA-BETA
!  FRES_REFL(2,1)=FRES_REFL(1,2)
!  FRES_REFL(2,2)=FRES_REFL(1,1)
!  FRES_REFL(3,3)=GAMMA_RE
!  FRES_REFL(4,4)=GAMMA_RE
  
!ENDIF

!END SUBROUTINE FRESNELL_R

! fresenl transmittance
! sample call
!!  CALL FRESNELL_T(NAIR,NWRE,THETA1,THETA2,FRES_TRAN)
! for air incidence
! or
!!  CALL FRESNELL_T(NWRE,NAIR,THETA1,THETA2,FRES_TRAN)
! for water incidence
 
!SUBROUTINE FRESNELL_T(N1,N2,THETA1,THETA2,FRES_TRAN)
!IMPLICIT NONE
!REAL*8,INTENT(IN) :: N1,N2,THETA1,THETA2
!REAL*8,DIMENSION(4,4),INTENT(OUT) :: FRES_TRAN

!REAL*8 :: NREL, ALPHA,BETA,GAMMA,SINT2,SINT1,SINT12,COST12,RTMP1

!NREL=N2/N1

!IF(THETA1<1.0D-4) THEN
!  ALPHA=2.0D0/(1.0D0+NREL)
!  BETA=2.0D0/(1.0D0+NREL)
  
!  GAMMA=ALPHA*BETA*NREL
!  ALPHA=0.5D0*ALPHA*ALPHA*NREL
!  BETA=0.5D0*BETA*BETA*NREL
!  FRES_TRAN=0.0D0

!  FRES_TRAN(1,1)=ALPHA+BETA
!  FRES_TRAN(2,2)=FRES_TRAN(1,1)
!  FRES_TRAN(3,3)=GAMMA
!  FRES_TRAN(4,4)=GAMMA
!RETURN
!ENDIF  

!SINT2=SIN(2.0D0*THETA2)
!SINT1=SIN(2.0D0*THETA1)
!SINT12=SIN(THETA1+THETA2)
!SINT12=SINT12*SINT12
!COST12=COS(THETA1-THETA2)

!RTMP1=SINT2*SINT1/SINT12

!BETA=0.5D0*RTMP1

!GAMMA=RTMP1/COST12

!ALPHA=0.5D0*GAMMA/COST12

!FRES_TRAN=0.0D0

!FRES_TRAN(1,1)=ALPHA+BETA
!FRES_TRAN(1,2)=ALPHA-BETA
!FRES_TRAN(2,1)=FRES_TRAN(1,2)
!FRES_TRAN(2,2)=FRES_TRAN(1,1)
!FRES_TRAN(3,3)=GAMMA
!FRES_TRAN(4,4)=GAMMA

!END SUBROUTINE FRESNELL_T

!Calculate the slant path under pseudo spherical shell approximation
!SECANT_THETAL is the ratio of tau1 and tau2
!tau1: cummulative curved path optical depth from from the specified location to TOA.
!tau2: the vertical optical depth from the specified location to TOA.
SUBROUTINE SLANT_PATH_PSS(MU_IN)
USE RTUTILITY, ONLY : TAU,NALYR,HEIGHT_ATMOSPHERE,ALYR,SECANT_THETAL, &
               SECANT_THETAL_PRSV,RADIUS_EARTH
IMPLICIT NONE
REAL*8,INTENT(IN) :: MU_IN
INTEGER :: ILAYER,JLAYER,NXX
REAL*8 :: POLINT_SIMPLE,RTMP,SINT0,XX,YY,ZZ
REAL*8,DIMENSION(:),ALLOCATABLE :: XARRY,YARRY

SINT0=SQRT(1.0D0-MU_IN*MU_IN)
SECANT_THETAL_PRSV(0)=1.0D0/ABS(MU_IN)

DO ILAYER=1,NALYR
	IF(HEIGHT_ATMOSPHERE(ILAYER-1)-HEIGHT_ATMOSPHERE(ILAYER)<0.0D0) &
	STOP 'HEIGHT_ATMOSPHERE DOES NOT INCREASE MONOTONICALLY'
ENDDO

DO ILAYER=1,NALYR
  RTMP=(RADIUS_EARTH+HEIGHT_ATMOSPHERE(ILAYER))*SINT0
  YY=0.D0
  DO JLAYER=1,ILAYER
     XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER-1))**2-RTMP**2) -  &
		 SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER  ))**2-RTMP**2)
     YY=YY+XX/(HEIGHT_ATMOSPHERE(JLAYER-1)-HEIGHT_ATMOSPHERE(JLAYER)) * &
              (ALYR(JLAYER)%TAUT-ALYR(JLAYER)%TAUB)
     IF(YY<0.0d0) STOP 'CHECK SLANT_PATH_PSS SUBROUTINE'
  ENDDO
  SECANT_THETAL_PRSV(ILAYER)=YY/ALYR(ILAYER)%TAUT
!write(*,*)'test slant pp, ilayer, tau, secant_theta', &
!    ilayer,ALYR(ILAYER)%TAUT,SECANT_THETAL_PRSV(ILAYER)
ENDDO

!SECANT_THETAL_PRSV(0:NALYR))
!SECANT_THETAL(ALYR(NALYR)%ITAUE))
NXX=NALYR+1
ALLOCATE(XARRY(NXX),YARRY(NXX))

DO ILAYER=1,NALYR
 XARRY(ILAYER)=ALYR(ILAYER)%TAUB
ENDDO
XARRY(NALYR+1)=ALYR(NALYR)%TAUT
YARRY(1:NALYR+1)=SECANT_THETAL_PRSV(0:NALYR)


DO JLAYER=1,ALYR(NALYR)%ITAUE
   SECANT_THETAL(JLAYER)=POLINT_SIMPLE(NXX,XARRY,YARRY,TAU(JLAYER),3)
ENDDO

DEALLOCATE(XARRY,YARRY)

ENDSUBROUTINE SLANT_PATH_PSS

! CALCULATE SLANT_TAU_LOCAL OF THE SOLAR BEAM FOR A LINE OF SIGHT ALONG A VIEWING DIRECTION
! SENSOR IS ASSUMED TO BE LOCATED AT THE SURFACE.
SUBROUTINE SLANT_PATH_SURF_FSS(HEIGHT_TEMP,INDX_LAYER,MU_IN,MUV,PHIV,&
						 SLANT_TAU_LOCAL)

USE RTUTILITY, ONLY : PI,NALYR,HEIGHT_ATMOSPHERE,ALYR, &
			   SECANT_THETAL_PRSV,RADIUS_EARTH
IMPLICIT NONE
INTEGER,INTENT(IN) :: INDX_LAYER
REAL*8,INTENT(IN) :: HEIGHT_TEMP,MU_IN,MUV,PHIV
REAL*8, INTENT(OUT)::SLANT_TAU_LOCAL

INTEGER :: ILAYER,JLAYER
REAL*8 :: RTMP,SINT0,XX,YY,ZZ

REAL*8 :: SINT1,SINT2,SINTV,THETA1,LDIS,COSD0
REAL*8 :: XI,YI,ZI,AI,BI,CI,TAUFRAC

SINTV=SQRT(1.0D0-MUV*MUV)
IF(SINTV>1.0E-6)THEN
	SINT1=SINTV*RADIUS_EARTH/(RADIUS_EARTH+HEIGHT_TEMP)
	THETA1=ASIN(SINTV)-ASIN(SINT1)
	LDIS=RADIUS_EARTH*SIN(THETA1)/SINT1
ELSE
	LDIS=HEIGHT_TEMP
ENDIF

XI=LDIS*SINTV*COS(PHIV)
YI=LDIS*SINTV*SIN(PHIV)
ZI=RADIUS_EARTH+LDIS*ABS(MUV)

RTMP=SQRT(XI*XI+YI*YI+ZI*ZI)

AI=SQRT(1.0D0-MU_IN*MU_IN)
BI=0.0D0
CI=ABS(MU_IN)

COSD0=(XI*AI+YI*BI+ZI*CI)/RTMP
SINT0=SQRT(1.0D0-COSD0*COSD0)
RTMP=(RADIUS_EARTH+HEIGHT_TEMP)*SINT0

IF(COSD0<0.0D0 .AND. RTMP<RADIUS_EARTH) THEN
   SLANT_TAU_LOCAL=1.0E32  ! BEHIND EARTH SHADOW
   RETURN
ENDIF

XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER-1))**2-RTMP**2) -  &
	 SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-RTMP**2)
SLANT_TAU_LOCAL=XX/(HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER)) * &
	   (ALYR(INDX_LAYER)%TAUT-ALYR(INDX_LAYER)%TAUB)

IF(INDX_LAYER>1)THEN
	DO JLAYER=1,INDX_LAYER-1
	 XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER-1))**2-RTMP**2) -  &
		 SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER  ))**2-RTMP**2)
     SLANT_TAU_LOCAL=SLANT_TAU_LOCAL+XX/(HEIGHT_ATMOSPHERE(JLAYER-1)-HEIGHT_ATMOSPHERE(JLAYER)) * &
			  (ALYR(JLAYER)%TAUT-ALYR(JLAYER)%TAUB)
	ENDDO
ENDIF

ENDSUBROUTINE SLANT_PATH_SURF_FSS

! CALCULATE SLANT_TAU_LOCAL OF THE SOLAR BEAM FOR A LINE OF SIGHT ALONG A VIEWING DIRECTION
! SENSOR IS ASSUMED TO BE LOCATED AT THE TOA.
SUBROUTINE SLANT_PATH_TOA_FSS(HEIGHT_TEMP,INDX_LAYER,MU_IN,MUV,PHIV,&
                              SLANT_TAU_LOCAL,EPSS_FARSIDE)
USE RTUTILITY, ONLY : PI,NALYR,HEIGHT_ATMOSPHERE,ALYR, &
			   SECANT_THETAL_PRSV,RADIUS_EARTH,IPSS_VIEWANGLE_GROUND
IMPLICIT NONE
INTEGER,INTENT(IN) :: INDX_LAYER
REAL*8,INTENT(IN) :: HEIGHT_TEMP,MU_IN,MUV,PHIV
REAL*8, INTENT(OUT)::SLANT_TAU_LOCAL
LOGICAL, INTENT(IN)::EPSS_FARSIDE
INTEGER :: ILAYER,JLAYER
REAL*8 :: RTMP,SINT0,XX,YY,ZZ !,TAUFRAC

REAL*8 :: SINT1,SINTV,THETA1,LDIS,COSD0,DIST0 !,SINT2
REAL*8 :: XI,YI,ZI,AI,BI,CI,DISSIGN

IF(EPSS_FARSIDE)THEN
   DISSIGN=-1.0D0
ELSE
   DISSIGN=1.0D0
ENDIF

SINTV=SQRT(1.0D0-MUV*MUV)

! IPSS_VIEWANGLE_GROUND ONLY USED IN SPHERICAL SHELL IPSS TREATMENT.
IF(IPSS_VIEWANGLE_GROUND==0)THEN
! IPSS_VIEWANGLE_GROUND=0 THE TOA SENSOR VIEWING ANGLE IS REFERENCED AT GROUND
	DIST0=SINTV*RADIUS_EARTH
	LDIS=SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2) -        &
		 SQRT( RADIUS_EARTH**2             -DIST0**2)

	XI=LDIS*SINTV*COS(PI-PHIV)
	YI=LDIS*SINTV*SIN(PI-PHIV)
	ZI=RADIUS_EARTH+LDIS*ABS(MUV)
ELSEIF(IPSS_VIEWANGLE_GROUND==1)THEN
! IPSS_VIEWANGLE_GROUND=1 THE TOA SENSOR VIEWING ANGLE IS REFERENCED AT TOA
	DIST0=SINTV*(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))
	IF(RADIUS_EARTH+HEIGHT_TEMP-DIST0<0.0d0)THEN
	  SLANT_TAU_LOCAL=1.0E32  ! HEIGHT_TEMP not in the line of sight.
	  RETURN
	ENDIF
	LDIS=abs(MUV)*(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))
	LDIS=LDIS-DISSIGN*SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)

	XI=LDIS*SINTV*COS(PHIV)
	YI=LDIS*SINTV*SIN(PHIV)
	ZI=(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))-LDIS*ABS(MUV)
ELSE
	STOP 'IPSS_VIEWANGLE_GROUND NOT PROPERLY ASSIGNED'
ENDIF


RTMP=SQRT(XI*XI+YI*YI+ZI*ZI)

AI=SQRT(1.0D0-MU_IN*MU_IN)
BI=0.0D0
CI=ABS(MU_IN)

COSD0=(XI*AI+YI*BI+ZI*CI)/RTMP
SINT0=SQRT(1.0D0-COSD0*COSD0)
DIST0=(RADIUS_EARTH+HEIGHT_TEMP)*SINT0

IF(COSD0<0.0D0 .AND. DIST0<RADIUS_EARTH) THEN
   SLANT_TAU_LOCAL=1.0E32  ! BEHIND EARTH SHADOW
   RETURN
ENDIF

IF(COSD0<0.0D0)THEN
  DO JLAYER=INDX_LAYER,NALYR
     IF(RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER)<=DIST0)THEN
		 ILAYER=JLAYER
         EXIT
     ENDIF
  ENDDO

  IF(ILAYER == INDX_LAYER)THEN
		XX=SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2) +   &
		   SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER-1))**2-DIST0**2)
		YY=XX/(HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER)) * &
				(ALYR(INDX_LAYER)%TAUT-ALYR(INDX_LAYER)%TAUB)

  ELSE
		XX=SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2) -   &
		   SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER))**2-DIST0**2)
		YY=XX/(HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER)) * &
				(ALYR(INDX_LAYER)%TAUT-ALYR(INDX_LAYER)%TAUB)
        IF(ILAYER>INDX_LAYER+1)THEN
		  DO JLAYER=INDX_LAYER+1,ILAYER-1
			XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER-1))**2-DIST0**2) -  &
				SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER  ))**2-DIST0**2)
			YY=YY+XX/(HEIGHT_ATMOSPHERE(JLAYER-1)-HEIGHT_ATMOSPHERE(JLAYER)) * &
					 (ALYR(JLAYER)%TAUT-ALYR(JLAYER)%TAUB)
		  ENDDO
        ENDIF
		XX= 2.0d0*SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(ILAYER-1))**2-DIST0**2)
		YY=YY+XX/(HEIGHT_ATMOSPHERE(ILAYER-1)-HEIGHT_ATMOSPHERE(ILAYER)) * &
				 (ALYR(ILAYER)%TAUT-ALYR(ILAYER)%TAUB)

  ENDIF
  IF(ILAYER>1)THEN
     DO JLAYER=1,ILAYER-1
		XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER-1))**2-DIST0**2) -  &
			SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER  ))**2-DIST0**2)
		YY=YY+XX/(HEIGHT_ATMOSPHERE(JLAYER-1)-HEIGHT_ATMOSPHERE(JLAYER)) * &
				 (ALYR(JLAYER)%TAUT-ALYR(JLAYER)%TAUB)
     ENDDO

  ENDIF
  SLANT_TAU_LOCAL=YY
ELSE  !COSD0>0.0D0

	XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER-1))**2-DIST0**2) -  &
		SQRT((RADIUS_EARTH+HEIGHT_TEMP)**2-DIST0**2)
	IF(INDX_LAYER==1)THEN
        SLANT_TAU_LOCAL=XX*(ALYR(INDX_LAYER)%TAUT-ALYR(INDX_LAYER)%TAUB)       &
               /(HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER))
	ELSE
		YY=XX/(HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER)) * &
			(ALYR(INDX_LAYER)%TAUT-ALYR(INDX_LAYER)%TAUB)
		DO JLAYER=1,INDX_LAYER-1
		 XX= SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER-1))**2-DIST0**2) -  &
			 SQRT((RADIUS_EARTH+HEIGHT_ATMOSPHERE(JLAYER  ))**2-DIST0**2)
		 YY=YY+XX/(HEIGHT_ATMOSPHERE(JLAYER-1)-HEIGHT_ATMOSPHERE(JLAYER)) * &
				  (ALYR(JLAYER)%TAUT-ALYR(JLAYER)%TAUB)
		ENDDO
		SLANT_TAU_LOCAL=YY
	ENDIF
ENDIF
RETURN

ENDSUBROUTINE SLANT_PATH_TOA_FSS

!!SECANT_THETAL_LAYER is the ratio of tau1 and tau2
!!tau1: curved path optical depth OF THE LAYER ALONG A LINE OF SIGHT
!!tau2: the vertical optical depth OF THE LAYER.
!!MUV: COSINE OF THE VIEWING ZENITH ANGLE
!!SENSOR LOCATED AT TOA
!SUBROUTINE SLANT_PATH_TOA_LAYER(MUV,INDX_LAYER,SECANT_THETAL_LAYER)
!USE RTUTILITY, ONLY : NALYR,HEIGHT_ATMOSPHERE,ALYR,RADIUS_EARTH
!IMPLICIT NONE
!REAL*8,INTENT(IN) :: MUV
!INTEGER,INTENT(IN) :: INDX_LAYER
!REAL*8,INTENT(OUT) :: SECANT_THETAL_LAYER
!
!REAL*8 :: SINT1,SINT2,SINTV,THETA1,LDIS1,LDIS2
!
!SINTV=SQRT(1.0D0-MUV*MUV)
!! SINE OF THE CRITICAL ANGLE, EQ.(1) OF Korkin et al. JQSRT, 254 (2020) 107181
!SINT2=RADIUS_EARTH/(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))
!IF(SINTV<1.0E-3 .OR. SINTV>SINT2 .OR. INDX_LAYER .LE. 1)THEN
!   SECANT_THETAL_LAYER=1.0D0/ABS(MUV)
!   RETURN
!ENDIF
!
!SINT1=SINTV*(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0)) &
!		   /(RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER))
!THETA1=ASIN(SINT1)-ASIN(SINTV)
!
!LDIS1=(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))*SIN(THETA1)/SINT1
!
!SINT1=SINTV*(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0)) &
!		   /(RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER-1))
!THETA1=ASIN(SINT1)-ASIN(SINTV)
!
!LDIS2=(RADIUS_EARTH+HEIGHT_ATMOSPHERE(0))*SIN(THETA1)/SINT1
!
!SECANT_THETAL_LAYER=(LDIS1-LDIS2) / &
!        (HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER))
!IF(SECANT_THETAL_LAYER<0.0D0) STOP 'CHECK SLANT_PATH_SURF_LAYER'
!
!ENDSUBROUTINE SLANT_PATH_TOA_LAYER
!
!! CALCULATE SECANT_THETAL_LOCAL OF THE SOLAR BEAM FOR A LINE OF SIGHT ALONG A VIEWING DIRECTION
!! SENSOR IS ASSUMED TO BE LOCATED AT THE SURFACE.
!SUBROUTINE SLANT_PATH_SURF_LAYER(MUV,INDX_LAYER,SECANT_THETAL_LAYER)
!USE RTUTILITY, ONLY : NALYR,HEIGHT_ATMOSPHERE,ALYR,RADIUS_EARTH
!IMPLICIT NONE
!REAL*8,INTENT(IN) :: MUV
!INTEGER,INTENT(IN) :: INDX_LAYER
!REAL*8,INTENT(OUT) :: SECANT_THETAL_LAYER
!
!REAL*8 :: SINT1,SINT2,SINTV,THETA1,LDIS1,LDIS2
!
!IF(MUV>0.0D0) STOP 'MUV NEEDS TO BE < 0 IN SLANT_PATH_SURF_FSS'
!SINTV=SQRT(1.0D0-MUV*MUV)
!IF(SINTV<1.0E-4)THEN
!   SECANT_THETAL_LAYER=1.0D0/ABS(MUV)
!   RETURN
!ENDIF
!SINT1=SINTV*RADIUS_EARTH/(RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER-1))
!THETA1=ASIN(SINTV)-ASIN(SINT1)
!LDIS1=RADIUS_EARTH*SIN(THETA1)/SINT1
!
!SINT1=SINTV*RADIUS_EARTH/(RADIUS_EARTH+HEIGHT_ATMOSPHERE(INDX_LAYER))
!THETA1=ASIN(SINTV)-ASIN(SINT1)
!LDIS2=RADIUS_EARTH*SIN(THETA1)/SINT1
!
!SECANT_THETAL_LAYER=(LDIS1-LDIS2) / &
!       (HEIGHT_ATMOSPHERE(INDX_LAYER-1)-HEIGHT_ATMOSPHERE(INDX_LAYER))
!IF(SECANT_THETAL_LAYER<0.0D0) STOP 'CHECK SLANT_PATH_SURF_LAYER'
!
!ENDSUBROUTINE SLANT_PATH_SURF_LAYER
!      SUBROUTINE fleg(x,pl,nl) 
!      INTEGER nl 
!      real*8 x,pl(nl) 
!      INTEGER j 
!      real*8 d,f1,f2,twox 
!      pl(1)=1.0d0
!      pl(2)=x

!      if(nl.gt.2) then 
!        twox=2.0d0*x 
!        f2=x 
!        d=1.0d0 
!        do j=3,nl 
!          f1=d 
!          f2=f2+twox 
!          d=d+1.0d0 
!          pl(j)=(f2*pl(j-1)-f1*pl(j-2))/d 
!        enddo
!      endif
!      return
!      END

SUBROUTINE BT_Planck_INIT
USE RTTYPE
USE RTUTILITY
implicit none
INTEGER :: I
REAL(DP) :: BT_Planck_Func
REAL(DP), PARAMETER :: CMB_TEMP=2.72548D0
REAL(DP) :: RTMP,SCALE_TEMP

IF(ALYR(1)%WAVELENGTH<1.0D-12)THEN
    WRITE(*,*)'WAVELENGTH IS ZERO, RETURNNING ZERO FOR ALL THERMAL QUANTITIES'
	CMB_Rad=0.0D0
	BT_Planck=0.0D0
	SURFACE_RAD=0.0D0
    RETURN
ENDIF

CMB_Rad=BT_Planck_Func(ALYR(1)%WAVELENGTH,CMB_TEMP)

BT_Planck=0.0D0
IF(ALYR(1)%WAVELENGTH<3.0D0)RETURN
RTMP=0.0D0
DO I=1,NALYR
	IF(ALYR(I)%TEMPERATURE>RTMP) RTMP=ALYR(I)%TEMPERATURE
ENDDO
IF(ABS(RTMP)<1.0D-6)THEN
! ASSUMING ALL TEMPERATURE INPUT IS ZERO, NO PLANCK FUNCTION EVALUATION NEEDED.
	BT_Planck=0.0D0
	SURFACE_RAD=0.0D0
	RETURN
ELSEIF(RTMP<100.0D0 ) THEN
   SCALE_TEMP=273.15D0
ELSE
   SCALE_TEMP=0.0D0
ENDIF
! INITIALIZE BT_PLANCK FUNCTION
DO I=1,NALYR
    RTMP=ALYR(I)%TEMPERATURE+SCALE_TEMP
	BT_Planck(I)=BT_Planck_Func(ALYR(I)%WAVELENGTH,RTMP)
ENDDO

RTMP=SURFACE_TEMPERATURE+SCALE_TEMP ! KELVIN UNIT ASSUMED

SURFACE_RAD=BT_Planck_Func(ALYR(1)%WAVELENGTH,RTMP)


END SUBROUTINE BT_Planck_INIT

FUNCTION BT_Planck_Func(WAVELENGTH_MICRON,TEMP_KELVIN)
USE RTTYPE
REAL(DP) :: BT_Planck_Func
REAL(DP),INTENT(IN) :: WAVELENGTH_MICRON,TEMP_KELVIN
REAL(DP),PARAMETER :: CSPEED=299792458.0_DP, h_const=6.62607015D-34, &
						K_const=1.380649D-23
REAL(DP) :: FREQ,RTMP,WAVELENGTH_METER
IF(TEMP_KELVIN<0.0D0) STOP 'TEMPERATURE INPUT < 0 IN BT_Planck_Func'
IF(TEMP_KELVIN<1.0D-2) THEN
	BT_Planck_Func=0.0D0
	RETURN
ENDIF
WAVELENGTH_METER=WAVELENGTH_MICRON*1.0D-6
FREQ=CSPEED/WAVELENGTH_METER
RTMP=h_const*FREQ/K_const/TEMP_KELVIN
IF(RTMP>100.0D0)THEN
	BT_Planck_Func=0.0D0
ELSE
! Radiance in W/m^2/Hz/Sr
	BT_Planck_Func=2.0_DP*h_const*(FREQ**3)/(CSPEED**2)/(exp(RTMP)-1.0_DP)
! CONVERT TO W/m^2/meter/Sr
    BT_Planck_Func=BT_Planck_Func*CSPEED/WAVELENGTH_METER/WAVELENGTH_METER
! CONVERT TO W/m^2/micron/Sr
    BT_Planck_Func=BT_Planck_Func*1.0D-6
ENDIF
RETURN

END FUNCTION BT_Planck_Func

      REAL*8 FUNCTION beta(z,w)
      REAL*8 w,z,a,b,c
!U    USES gammln
!      REAL*8 DLOG_GAMMA
      real*8 GAMMLN
	  a=gammln(z)
	  b=gammln(w)
	  c=gammln(z+w)
      beta=exp(a+b-c)
      return
      END

 
REAL*8 FUNCTION gammln(xx)
REAL*8 xx
INTEGER j
DOUBLE PRECISION ser,stp,tmp,x,y,cof(6)
SAVE cof,stp
DATA cof,stp/76.18009172947146d0,-86.50532032941677d0, &
     24.01409824083091d0,-1.231739572450155d0,.1208650973866179d-2,  &
     -.5395239384953d-5,2.5066282746310005d0/
x=xx
y=x
tmp=x+5.5d0
tmp=(x+0.5d0)*log(tmp)-tmp
ser=1.000000000190015d0
DO j=1,6
   y=y+1.d0
   ser=ser+cof(j)/y
ENDDO
gammln=tmp+log(stp*ser/x)
return
END



SUBROUTINE polin2(x1a,x2a,ya,m,n,x1,x2,y,dy)
INTEGER,intent(in):: m,n
REAL*8,intent(in):: x1,x2,x1a(m),x2a(n),ya(m,n)
REAL*8,intent(out):: dy,y
real*8,external :: POLINT_SIMPLE
REAL*8, dimension(:), allocatable:: ymtmp,yntmp

INTEGER j,k,ORDER
ORDER=2
allocate(ymtmp(m),yntmp(n))
do j=1,m
  do k=1,n
	yntmp(k)=ya(j,k)
  enddo
!  call polint(x2a,yntmp,n,x2,ymtmp(j),dy)
  ymtmp(j)=POLINT_SIMPLE(n,x2a,yntmp,x2,ORDER)
enddo
y=POLINT_SIMPLE(m,x1a,ymtmp,x1,ORDER)
!call polint(x1a,ymtmp,m,x1,y,dy)
deallocate(ymtmp,yntmp)
return
END
