!NAME:            rt_single_scattering.f90
!RADIATION:       Vector 
!GEOMETRY:        Plane-parallel
!METHOD:          Analytical solution to vector radiative transfer system
!DETECTORS:       User Defined Position
!SCATTERING:      Multiple
!INTERFACE:       COX MUNK MODEL
!                 Pengwang Zhai
!DATE:            June 21 2017
!COMMENTS:        IF "TRUC_FLAG==.TRUE." AND THE INCORRECT SIMULATION, 
!                 CHECK INPUT FILE FOR THE CORRECT VALUE OF "FTRUNC"

SUBROUTINE RT_SINGLE_SCATTERING(NREC,NDET,RECDATASTREAM,DELTATAUAINPUT,&
         DELTATAUOINPUT,NUMMIEINPUT,NUMMIEANGINPUT,MAXLORDINPUT,       &
         PHMXDATASTREAM,MU_IN,NTHETAOUT,NPHIOUT,PHIOUT,MUOUT,DIRAD,    &
         DSTOKES,WCFLG_INPUT,DELTAM_INPUT)
USE RTTYPE 
USE RTUTILITY
USE IRRADSUNL
implicit none

INTEGER, INTENT(IN) :: NREC,NDET,NUMMIEINPUT,MAXLORDINPUT
REAL*8, INTENT(IN) ::  DELTATAUAINPUT,DELTATAUOINPUT
REAL*8,INTENT(IN),DIMENSION(NREC,7) :: RECDATASTREAM
INTEGER,INTENT(IN),DIMENSION(NUMMIEINPUT) ::NUMMIEANGINPUT
REAL*8,INTENT(IN),DIMENSION(NUMMIEINPUT,NUMMIEANGMAX,0:6) :: PHMXDATASTREAM

INTEGER(I4B),INTENT(IN) :: NTHETAOUT,NPHIOUT
REAL*8, INTENT(IN) :: MU_IN
REAL*8 :: THETA_IN
REAL*8,DIMENSION(NTHETAOUT) :: MUOUT
REAL*8,DIMENSION(NPHIOUT) :: PHIOUT
REAL*8,DIMENSION(NDET,2) :: DIRAD  ! DIRAD(:,1) DOWNWELLING IRADIANCE
                                   ! DIRAD(:,2) UPWELLING IRADIANCE
REAL*8,DIMENSION(NDET,NTHETAOUT,NPHIOUT,4) :: DSTOKES
LOGICAL :: WLR_FLAG_INPUT,WCFLG_INPUT
integer :: DELTAM_INPUT

REAL(DP) :: X1,X2,RTMP,RTMP1,RTMP2,RTMP3,RTMP4,RTMP5,TAUTMP,&
            DELTATAUATMP,DELTATAUOTMP,COST1,COST2,SINT1,SINT2,MUSCAT

REAL(DP) :: THETA1,THETA2,MU0T,ENGREFL

INTEGER(I4B) :: M,IMIE,LORDER,I,L,N,ICOM, IMU, &
      ICOL,ITAU,ITHETA,IPHI,IDTAU,IDTAUA,&
      IDTAUO,IALYR,ICOM1,MPLIN
             ! IMIE, LORDER ARE THE TEMPERARY VARIABLES
!INTEGER(I4B),SAVE ::ICALNUM=0

REAL(DP),DIMENSION(:),ALLOCATABLE:: TAUDETA

REAL(DP),DIMENSION(4,4) :: MTRX1
REAL(DP),DIMENSION(4)   :: ARRY1,ARRY2,ARRY3

REAL(DP),DIMENSION(4,4) :: FRES_MTRX  

LOGICAL :: TRUC_FLAG,SGLNT,MUFLG
LOGICAL :: FLAG1,FLAG2,DIFF_FLG

REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADATMP1,RADOTMP,RADOTMP1,RADOUTTMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADDETU

TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADATMP,LSPATMP,LRADATMP1,LSPATMP1
REAL*8,DIMENSION(:),ALLOCATABLE :: MUTMP

!ICALNUM=ICALNUM+1 ! number of calls to RTSOS
! ___________________________

ESUN(:)=0.0D0
ESUN(1)=2.0D0*ASIN(1.0D0) ! INPUT SUN IRRADIANCE

TRUC_FLAG=.true.    ! UTILIZE THE DLETA FIT or Deltam TECHNIQUE
SCL = .false.       ! CALCULATED SCALAR RADIANCE
SGLNT=.true.        ! SUN GLINT SWITCH

MUFLG=.false.        ! IF TRUE OUTPUT MU OF THE ZENITH ANGLE
                    ! IF FALSE OUT PUT THETA OF THE ZENITH ANGLE
					
!surface options
SHDWFLG=.true.           ! IF TRUE, USE SHADOWING FUNCTION
                         ! SHOULD BE ALWAYS TRUE.

WLR_FLAG=WLR_FLAG_INPUT ! OUTPUT WATER LEAVING RADIANCE IF DET IS IN AIR
WCFLG=WCFLG_INPUT     ! IF TRUE CONSIDER WHITE CAP (FOAM) COVERAGE PARAMETERIZATION
! USING TO WIND SPEED
!  THESE PARAMETERS ARE ADJUSTABLE FOR ACCURACY.
! ___________________________
DELTATAUA=DELTATAUAINPUT      ! ADJUST FOR ACCURATE OPTICAL INTEGRATION
DELTATAUO=DELTATAUOINPUT

DELTAM=DELTAM_INPUT  ! IF TRUE, RETURN DELTA M RESULTS
                     ! OTHERWISE, RETURN DELTA FIT RESULTS
MPLIN=2  ! DEFAULT ORDER OF POLYNOMIAL INTERPOLATION FOR RADIANCES

! DON'T CHANGE THESE OPTIONS IN BETWEEN ####
IF(WLR_FLAG) SGLNT=.FALSE.

! DON'T CHANGE THESE OPTIONS IN BETWEEN ####

NLAYER=0
NALYR=0
NOLYR=0
NDTAUA=0
NDTAUO=0
I=0
N=0
OCEAN=.FALSE.
pBRDF=.false.
LAMB=.FALSE.
OCEAN_NO_TRAN=.false.

DETA=.FALSE.
DETO=.FALSE.

LOOP_READ_CONFIG : DO N=1,NREC
   I=RECDATASTREAM(N,1)
   RTMP=RECDATASTREAM(N,2)
   RTMP1=RECDATASTREAM(N,3)
   RTMP2=RECDATASTREAM(N,4)

   ! COUNTING DETECTOR NUMBERS
   IF(I==-1000) THEN
     IF(OCEAN .AND. OCEAN_NO_TRAN) &
         STOP 'ERROR: OCEAN DETECTOR WITH -101 INTERFACE'
     IF(OCEAN) THEN
          DETO=.TRUE.
          NDTAUO=NDTAUO+1
     ELSE
          DETA=.TRUE.
          NDTAUA=NDTAUA+1
     ENDIF
   ENDIF
   !TURN ON OCEAN FLAG IF AN OCEAN INTERFACE EXISTS
   IF(I==-100) THEN
      IF(OCEAN) STOP 'ERROR: -101 AND -100 COEXIST IN SOSI.DAT'
      OCEAN=.TRUE.

   ! AIR - SEA INTERFACE IS TREATED AS A LAYER.
      NLAYER=NLAYER+1
   ENDIF

   IF(I==-101) THEN
      IF(OCEAN) STOP 'ERROR: -101 AND -100 COEXIST IN SOSI.DAT'
      OCEAN=.TRUE.
      OCEAN_NO_TRAN=.TRUE.
    ! AIR - SEA INTERFACE IS TREATED AS A LAYER.
      NLAYER=NLAYER+1
      IF(LAMB) STOP 'ERROR: 1 TWO SYSTEM BOTTOM ASSIGNED'
      IF(pBRDF) STOP 'ERROR: 1 TWO SYSTEM BOTTOM ASSIGNED'
	EXIT LOOP_READ_CONFIG
   ENDIF

   ! MIE LAYERS, IPT HAS TO BE BIGGER THAN 0
   IF(I>0 .AND. .NOT.OCEAN ) THEN
      NALYR=NALYR+1
	  NLAYER=NLAYER+1
   ENDIF
   IF(I>0 .AND. OCEAN ) THEN
     NOLYR=NOLYR+1
     NLAYER=NLAYER+1
   ENDIF

   IF(I==-200) THEN
     NLAYER=NLAYER+1
     IF(OCEAN_NO_TRAN) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(pBRDF) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     LAMB=.TRUE.
     IF(N .NE. NREC) STOP 'CHECK NREC INPUT'
     EXIT LOOP_READ_CONFIG
   ENDIF

   IF(I==-201) THEN
     NLAYER=NLAYER+1
     IF(OCEAN_NO_TRAN) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     IF(LAMB) STOP 'ERROR: 2 TWO SYSTEM BOTTOM ASSIGNED'
     pBRDF=.TRUE.
     OCEAN_NO_TRAN=.true.
     EXIT LOOP_READ_CONFIG
   ENDIF

ENDDO LOOP_READ_CONFIG

IF(NDET-NDTAUA-NDTAUO .NE. 0) STOP "NDET NOT EQUAL TO NDTAUA + NDTAUO"

ALLOCATE(ALYR(NALYR))
!IF((.NOT.OCEAN) .AND. WLR_FLAG)STOP &
!        'ERROR: WLR_FLAG = .TRUE. WHILE NO OCEAN'
!IF(OCEAN .AND. (.NOT. OCEAN_NO_TRAN) ) &
!   STOP 'OCEAN CALCULATION NOT INCLUDED IN THIS SINGLE SCATTERING PROGRAM'

IF(DETA) THEN
  ALLOCATE(INDXDETA(NDTAUA),TAUDETA(NDTAUA),INDXDETA_SNGSCAT(NDTAUA))
ENDIF

!IF(DETO) STOP 'THIS SINGLE SCATTERING PROGRAM DOES NOT CALCUATE OCEAN DETECTOR'

! read in atmospheric & ocean parameters
    !  TAU=0 FOR TOP OF THE ATMOSPHERE ASSUMED
    !  ALERT!!! TAUB HAS TO BE MONOTONICALLY INCREASING.
	!  0<=LBDOM<=1
IALYR=0
IDTAUA=0
IDTAUO=0
NTTAU = 1
TAUTMP=0
OCEAN=.FALSE.
DO M=1,NREC
   I=RECDATASTREAM(M,1)
   RTMP=RECDATASTREAM(M,2)
   RTMP1=RECDATASTREAM(M,3)
   RTMP2=RECDATASTREAM(M,4)
   RTMP3=RECDATASTREAM(M,5)
   RTMP4=RECDATASTREAM(M,6)
   RTMP5=RECDATASTREAM(M,7)

  IF(I==-1000 .AND. (.NOT. OCEAN)) THEN
	  IDTAUA=IDTAUA+1
      INDXDETA(IDTAUA)=NTTAU
      TAUDETA(IDTAUA)=TAUTMP
      INDXDETA_SNGSCAT(IDTAUA)=IALYR
  ENDIF
  
  IF(I>0 .AND. .NOT.OCEAN) THEN
    IALYR=IALYR+1
	ALYR(IALYR)%IPT=I
	ALYR(IALYR)%TAUB=TAUTMP
    TAUTMP=TAUTMP+RTMP
	ALYR(IALYR)%TAUT=TAUTMP
	ALYR(IALYR)%LBDOM=RTMP1
    ALYR(IALYR)%WAVELENGTH=RTMP2
    ALYR(IALYR)%TEMPERATURE=RTMP3


     DELTATAUATMP=DELTATAUA
	 IF(DELTATAUATMP>RTMP/2.0D0)DELTATAUATMP=RTMP/2.0D0
     L=NINT(RTMP/DELTATAUATMP)
     IF(MOD(L,2)/=0)THEN
	    L=L+1
	    DELTATAUATMP=RTMP/DFLOAT(L)
	 ENDIF

    ALYR(IALYR)%ITAUS=NTTAU
    ALYR(IALYR)%NTAU=NINT(RTMP/DELTATAUATMP)
    IF(MOD(ALYR(IALYR)%NTAU,2)/=0) &
	  ALYR(IALYR)%NTAU=ALYR(IALYR)%NTAU+1

    NTTAU=NTTAU+ALYR(IALYR)%NTAU

    IF(IALYR==NALYR) THEN
      ALYR(IALYR)%ITAUE=NTTAU
    ELSE
      ALYR(IALYR)%ITAUE=NTTAU-1
    ENDIF
  ENDIF

  IF(I==-100) THEN
    IF(OCEAN)STOP 'ERROR: MULTIPLE AIR-SEA INTERFACE'
    OCEAN=.TRUE.
	NTTAU=NTTAU+1
	OITAU=TAUTMP+TINY2
	TAUTMP=TAUTMP+2.0D0*TINY2
	WNDSPD=RTMP
	NWRE=RTMP1
	NWIM=RTMP2
    IF(NWRE<=1.0d0 .or. NWRE>2.0d0)stop 'check nmre'
    NRELRE=NWRE/(NWRE*NWRE+NWIM*NWIM)
    NRELIM=-NWIM/(NWRE*NWRE+NWIM*NWIM)
	NSQW=NWRE*NWRE
    NSQA=1.0D0/NWRE/NWRE
  ENDIF

  IF(I==-101) THEN
    IF(OCEAN)STOP 'ERROR: MULTIPLE AIR-SEA INTERFACE'
    OCEAN=.TRUE.
	NTTAU=NTTAU+1
	OITAU=TAUTMP
	TOTALTAU=OITAU
	WNDSPD=RTMP
	NWRE=RTMP1
	NWIM=RTMP2
    IF(NWRE<=1.0d0 .or. NWRE>2.0d0)stop 'check nmre'
    NRELRE=NWRE/(NWRE*NWRE+NWIM*NWIM)
    NRELIM=-NWIM/(NWRE*NWRE+NWIM*NWIM)
	NSQW=NWRE*NWRE
    NSQA=1.0D0/NWRE/NWRE
  ENDIF

  IF(I== -200)THEN
     TOTALTAU=TAUTMP
     GLBDO=RTMP
     FLAM=RTMP1
     NMBRE=RTMP2
     NMBIM=RTMP3
     IF(NMBRE<=1.0d0 .or. NMBRE>2.0d0)stop 'check nmbre'
     IF(OCEAN .AND. FLAM<1.0D0) &
	   STOP 'ERROR: MIXING LAMBERT AND SPECULAR REFLECTION &
	        &IS NOT SUPPORTED FOR OCEAN BOTTOM'
  ENDIF

  IF(I== -201)THEN
     TOTALTAU=TAUTMP
     pBRDFa=RTMP
     pBRDFk=RTMP1
     pBRDFb=RTMP2
     pBRDFe=RTMP3
     NMBRE=RTMP4
     NMBIM=RTMP5
     IF(NMBRE<=1.0d0 .or. NMBRE>2.0d0)stop 'check nmbre'
  ENDIF

ENDDO

IF(OCEAN)THEN
  SIGMASQ=0.003D0+0.00512D0*WNDSPD
  IF(WNDSPD<0.5D0) THEN
     FLATO=.TRUE.
  ELSE
     FLATO=.FALSE.
  ENDIF
ENDIF

IMIE=ALYR(1)%IPT
DO I=1,NALYR
  IF(ALYR(I)%IPT>IMIE)IMIE=ALYR(I)%IPT
ENDDO

IF(IMIE>NUMMIEINPUT)STOP 'MAX IPT INPUT IS LARGER THAN NUMMIE'

!READ(1,*) NUMMIE,MAXLORD
NUMMIE=NUMMIEINPUT
MAXLORD=MAXLORDINPUT

! NUMBER OF SETS OF MIE SCATTERING MATRIX
!WRITE(9,'("THERE ARE",I4,1X,"SETS OF MIE TYPES.")')NUMMIE
ALLOCATE(NUMORD(NUMMIE),FTRUNC(NUMMIE))

!READ IN MIE SCATTERING FUNCTIONS
ALLOCATE(NUMMIEANG(NUMMIE),THETA_SNG(NUMMIE,NUMMIEANGMAX), &
         MU_SNG(NUMMIE,NUMMIEANGMAX),PM_AO_SNG(NUMMIE,NUMMIEANGMAX),&
         PHF_RESIDUE(NUMMIE,NUMMIEANGMAX),NUMFULLBETAL(NUMMIE),&
         FULLBETAL(NUMMIE,0:MAXLFULL))
NUMMIEANG=NUMMIEANGINPUT

DO IMIE=1,NUMMIE
DO I=1,NUMMIEANG(IMIE)
       PM_AO_SNG(IMIE,I)%PHMX=0.0d0
       THETA_SNG(IMIE,I)=PHMXDATASTREAM(IMIE,I,0)
       PM_AO_SNG(IMIE,I)%PHMX(1,1)=PHMXDATASTREAM(IMIE,I,1)
       PM_AO_SNG(IMIE,I)%PHMX(2,2)=PHMXDATASTREAM(IMIE,I,2)
       PM_AO_SNG(IMIE,I)%PHMX(3,3)=PHMXDATASTREAM(IMIE,I,3)
       PM_AO_SNG(IMIE,I)%PHMX(4,4)=PHMXDATASTREAM(IMIE,I,4)
       PM_AO_SNG(IMIE,I)%PHMX(1,2)=PHMXDATASTREAM(IMIE,I,5)
       PM_AO_SNG(IMIE,I)%PHMX(3,4)=PHMXDATASTREAM(IMIE,I,6)
       PM_AO_SNG(IMIE,I)%PHMX(2,1)=PM_AO_SNG(IMIE,I)%PHMX(1,2)
       PM_AO_SNG(IMIE,I)%PHMX(4,3)=-PM_AO_SNG(IMIE,I)%PHMX(3,4)

ENDDO
ENDDO ! IMIE LOOP
MU_SNG=COS(THETA_SNG*FACTOR)

CALL FTRUNC_EVAL

IF(FLATO .AND. WCFLG) WCFLG=.FALSE.

IF((.NOT.OCEAN) .AND. WCFLG)THEN
     WCFLG=.FALSE.
     WRITE(*,*)'WARNING, WHITE CAP FLAG TURNED OFF'
     WRITE(*,*)'BECAUSE NO OCEAN IS PRESENT'
ENDIF
IF(pBRDF)WCFLG=.FALSE.
IF(OCEAN .AND. WCFLG)THEN
  FWC=2.95E-6*WNDSPD**3.52D0  ! EQUATION (3), FRASER, JGR, 1997.
  WCLBDO=0.22D0               ! VALUE OBTAINED IN FRASER, JGR, 1997.

!  FWC and WCLBDO can be changed to 1.0 or 0.0 to do sanity check versus lambertian bottom
!  uncomment the following two lines to check white cap correction with Coulson 's table
!  to test white cap correction, 
!  set lambertian bottom albedo = 0.66666666
!  set white cap albedo = 0.6666666
!  turn white cap flag on
!  set very thin conservative ocean
!  set white cap fraction 1
!  compare with Coulson with bottom albedo 0.8 because
!  0.8=2*0.666666666/(1+0.66666666666)

 !  FWC=1.0D0
 !  WCLBDO=0.66666666666D0
!  FWC=1.0D0
!  WCLBDO=1.0D0

ENDIF

THETA_IN=ACOS(MU_IN)

IF(LAMB .AND. FLAM<1.0D0) GLBDO=GLBDO*FLAM

ALLOCATE(TAU(NTTAU),TAU_PRSV(NTTAU),LBDO_A_PRSV(NALYR))

! ___ATMOSPHERE CONFIGRATION____
CALL ATMOS_CONFIG(TRUC_FLAG)

IF(DETA) THEN
  ALLOCATE(INDXREVA(ALYR(NALYR)%ITAUE))
  INDXREVA=-1
  DO IDTAUA=1,NDTAUA
    IF(INDXDETA(IDTAUA)>ALYR(NALYR)%ITAUE) STOP 'ERROR: CHECK INDXDETA'
       INDXREVA(INDXDETA(IDTAUA))=IDTAUA
  ENDDO
ENDIF
! ___ATMOSPHERE CONFIGRATION OVER____

! DELTA FIT TRUNCATION ADJUSTMENT FOR THE DETECTOR
IF(DETA)THEN
DO IDTAUA=1,NDTAUA
 TAUDETA(IDTAUA)=TAU(INDXDETA(IDTAUA))
! WRITE(9,"('TAU OF AIR DETECTOR(',I8,')=',ES13.6)")&
!            IDTAUA,TAUDETA(IDTAUA)
! WRITE(*,"('TAU OF AIR DETECTOR(',I8,')=',ES13.6)")&
!            IDTAUA,TAUDETA(IDTAUA)
ENDDO
ENDIF

!   _____OCEAN CONFIGRATION OVER___

! ATMOSPHERIC SINGLE SCATTERING CORRECTION
  ALLOCATE(LRADA_SNG(NTHETAOUT,0:NALYR,NPHIOUT))
  CALL SNGL_SCAT_ATMOS_StandAlone(MU_IN,NTHETAOUT,NPHIOUT,MUOUT,PHIOUT,MPLIN)

IF(DETA)THEN
ALLOCATE(RADDETU(NTHETAOUT,4))

DO IDTAU=1,NDTAUA

  DIRAD(IDTAU,1)=-ESUN(1)*EXP(-TAUDETA(IDTAU)*SECANT_THETAL(INDXDETA(IDTAU)))*MU_IN
  DIRAD(IDTAU,2)=-999.0 ! fill value.  Single scattering program only generate 
                        ! meaningful down welling irradiance at the TOA

!WRITE(9,"('DOWNWELLING IRRADIANCE =',ES13.6)")ENGREFL
! DIRAD(IDTAU,:,1) DOWNWELLING IRADIANCE
! DIRAD(IDTAU,:,2) UPWELLING IRADIANCE

ENDDO  ! LOOP IDTAU


! GLINT CORRECTION FOR THE FIRST ORDER SCATTERING.
! GET OUTPUT FOR USER DEFINED ZENITH ANGLES
DO IDTAU=1,NDTAUA
DO IPHI=1,NPHIOUT
  DO ITHETA=1,NTHETAOUT
    RADDETU(ITHETA,:)= LRADA_SNG(ITHETA,INDXDETA_SNGSCAT(IDTAU),IPHI)%VRAD(:)
  ENDDO  !ITHETA

DO ITHETA=1,NTHETAOUT
 IF((.NOT. WLR_FLAG) .AND. (MUOUT(ITHETA)>0.0D0) &
                        .AND. SGLNT .AND. OCEAN) THEN
    DIFF_FLG=.true.
    CALL RADACMDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
                  PHIOUT(IPHI),ARRY1,DIFF_FLG)
    IF(WCFLG) ARRY1=ARRY1*(1.0D0-FWC)
    RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

 ENDIF

 IF(pBRDF) THEN
  DIFF_FLG=.true.
  CALL RADALandDRCT(MU_IN,TAU(INDXDETA(IDTAU)),MUOUT(ITHETA), &
                  PHIOUT(IPHI),ARRY1,DIFF_FLG)
  RADDETU(ITHETA,:)=RADDETU(ITHETA,:)+ARRY1(:)

 ENDIF

 DSTOKES(IDTAU,ITHETA,IPHI,:)=RADDETU(ITHETA,:)

ENDDO  !ITHETA
ENDDO  ! LOOP IPHI
ENDDO  ! LOOP IDTAU
DEALLOCATE(RADDETU)

ENDIF  ! deta if


DEALLOCATE(NUMMIEANG,THETA_SNG,MU_SNG,PM_AO_SNG,PHF_RESIDUE,NUMFULLBETAL,FULLBETAL)


IF(NUMMIE>0)DEALLOCATE(NUMORD)
DEALLOCATE(ALYR,TAU,TAU_PRSV,LBDO_A_PRSV,LRADA_SNG)

DEALLOCATE(FTRUNC)

IF(DETA)DEALLOCATE(INDXDETA,INDXREVA,TAUDETA,INDXDETA_SNGSCAT)

END SUBROUTINE RT_SINGLE_SCATTERING

SUBROUTINE ATMOS_CONFIG(TRUC_FLAG)
USE RTTYPE
USE RTUTILITY
implicit none
LOGICAL :: TRUC_FLAG
INTEGER :: I,ITAU, N,IALYR
REAL*8 :: RTMP

TAU=0.0D0
TAU_PRSV=0.0D0
LBDO_A_PRSV=0.0D0

DO I=1,NALYR
   ALYR(I)%DTAU=DABS(ALYR(I)%TAUT-ALYR(I)%TAUB)/DFLOAT(ALYR(I)%NTAU)
   LBDO_A_PRSV(I)=ALYR(I)%LBDOM
   DO N=ALYR(I)%ITAUS,ALYR(I)%ITAUE
    ITAU=N
    IF(ITAU>1) THEN
	   IF(N==ALYR(I)%ITAUS)THEN
	      TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+ALYR(I-1)%DTAU
	   ELSE
          TAU_PRSV(ITAU)=TAU_PRSV(ITAU-1)+ALYR(I)%DTAU
	   ENDIF
	ENDIF
   ENDDO
ENDDO
TOTALTAU_PRSV=TOTALTAU
IF(OCEAN)OITAU_PRSV=OITAU


DO I=1,NALYR
   IF(TRUC_FLAG .AND. FTRUNC(ALYR(I)%IPT)>0.0D0) THEN  
    !RESCALE OPTICAL DEPTH AND SINGLE SCATTERING ALBEDO
	!FOR DELTA FIT TRUNCATION

	RTMP=ALYR(I)%TAUT-ALYR(I)%TAUB
	ALYR(I)%DTAU=RTMP*(1.0D0-ALYR(I)%LBDOM*FTRUNC(ALYR(I)%IPT))
    ALYR(I)%LBDOM=ALYR(I)%LBDOM*(1.0D0-FTRUNC(ALYR(I)%IPT))  &
	              /(1.0D0-ALYR(I)%LBDOM*FTRUNC(ALYR(I)%IPT))
    ALYR(I)%TAUT=ALYR(I)%TAUB + ALYR(I)%DTAU
	RTMP=RTMP - ALYR(I)%DTAU
	DO IALYR=I+1,NALYR
       ALYR(IALYR)%TAUB=ALYR(IALYR)%TAUB-RTMP
       ALYR(IALYR)%TAUT=ALYR(IALYR)%TAUT-RTMP
	ENDDO
    IF(OCEAN)OITAU=OITAU-RTMP
    TOTALTAU=TOTALTAU-RTMP
   ENDIF

   ALYR(I)%DTAU=DABS(ALYR(I)%TAUT-ALYR(I)%TAUB)/DFLOAT(ALYR(I)%NTAU)

   DO N=ALYR(I)%ITAUS,ALYR(I)%ITAUE
    ITAU=N
    IF(ITAU>1) THEN
	   IF(N==ALYR(I)%ITAUS)THEN
	      TAU(ITAU)=TAU(ITAU-1)+ALYR(I-1)%DTAU
	   ELSE
          TAU(ITAU)=TAU(ITAU-1)+ALYR(I)%DTAU
	   ENDIF
	ENDIF
   ENDDO
ENDDO
IF(OCEAN .AND. ABS(OITAU-TAU(ITAU))>4.0d0*TINY2)THEN
  WRITE(*,*)'OITAU, Atmospherie TAU=',OITAU,TAU(ITAU)
  STOP 'ERROR: CHECK ATMOSPHERE CONFIGRATION'
ENDIF

END SUBROUTINE ATMOS_CONFIG

SUBROUTINE SNGL_SCAT_ATMOS_StandAlone(MU_IN,NTHETAOUT,NPHIOUT,MUOUT,PHIOUT,MPLIN)
USE RTTYPE
USE RTUTILITY
implicit none
REAL*8,INTENT(IN) :: MU_IN

INTEGER(I4B),INTENT(IN) :: NTHETAOUT,NPHIOUT,MPLIN
REAL*8,DIMENSION(NTHETAOUT),INTENT(IN) :: MUOUT
REAL*8,DIMENSION(NPHIOUT),INTENT(IN) :: PHIOUT

INTEGER :: IMIE,I,IPHI,ITHETA,IDTAU,ILAYER
REAL*8 :: RTMP, RTMP1,RTMP2,THETA1,COST1,COST2,PHI1,PHI2,&
          SINT1,SINT2,MUSCAT,RADCORR,THETA_IN
REAL*8,DIMENSION(4)   :: ARRY1,ARRY2,ARRY3,ARRY4
REAL*8,DIMENSION(4,4) :: MTRX1,MTRX2
TYPE(ARRAY4),DIMENSION(:,:),ALLOCATABLE :: LRADATMP,LSPATMP
REAL*8,DIMENSION(:,:),ALLOCATABLE :: RADATMP,RADATMP1

!INTEGER :: NUMPHI,IPHI_TMP
!REAL*8,DIMENSION(:),ALLOCATABLE :: PHI_TMP,WPHI_TMP

THETA_IN=ACOS(MU_IN)

DO I=1,4
  LRADA_SNG(1:NTHETAOUT,0:NALYR,1:NPHIOUT)%VRAD(I)=0.0D0
ENDDO

DO IPHI=1,NPHIOUT
DO ITHETA=1,NTHETAOUT

IF(MUOUT(ITHETA)<0.0D0)THEN

DO I=1,NALYR
  ARRY1=ESUN/FOURPI
  IMIE=ALYR(I)%IPT

  CALL PHASE_MATRIX_CALC(MU_IN,0.0d0,MUOUT(ITHETA),PHIOUT(IPHI),IMIE,MTRX1)
  MTRX1=LBDO_A_PRSV(I)*MTRX1/(1.0D0-LBDO_A_PRSV(I)*FTRUNC(IMIE))

  ARRY2=MATMUL(MTRX1,ARRY1)
! convention sign changes.
  ARRY2(3)=-ARRY2(3)
  ARRY2(4)=-ARRY2(4)
  IF(SCL) ARRY2(2:4)=0.0D0

  RTMP2= EXP(-DABS((ALYR(I)%TAUT-ALYR(I)%TAUB)/MUOUT(ITHETA)))

  IF(ABS(MUOUT(ITHETA)-MU_IN)<TINY2)THEN

    LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
      RTMP2*LRADA_SNG(ITHETA,I-1,IPHI)%VRAD(:)   +          &
           EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I)) *          &
      (ALYR(I)%TAUT-ALYR(I)%TAUB)/DABS(MUOUT(ITHETA))* ARRY2(:)
  ELSE

    RTMP=-MU_IN/(MUOUT(ITHETA)-MU_IN)
    RTMP1=ALYR(I)%TAUT-ALYR(I)%TAUB

    LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=    &
	  RTMP2*LRADA_SNG(ITHETA,I-1,IPHI)%VRAD(:) + &
        RTMP * EXP(-ALYR(I)%TAUT*SECANT_THETAL_PRSV(I))*(1.0D0 -       &
		  EXP(-RTMP1*(1.0D0/MU_IN-1.0D0/MUOUT(ITHETA))) ) * ARRY2(:)

  ENDIF

ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU<0

ELSEIF(MUOUT(ITHETA)>0.0D0)THEN
! ATMOSPHERE MU>0

ARRY1=ESUN/FOURPI
DO I=NALYR-1,0,-1
  IMIE=ALYR(I+1)%IPT
  CALL PHASE_MATRIX_CALC(MU_IN,0.0D0,MUOUT(ITHETA),PHIOUT(IPHI),IMIE,MTRX2)
  MTRX1=LBDO_A_PRSV(I+1)*MTRX2/(1.0D0-LBDO_A_PRSV(I+1)*FTRUNC(IMIE))
  ARRY2=MATMUL(MTRX1,ARRY1)

! convention sign changes.
  ARRY2(3)=-ARRY2(3)
  ARRY2(4)=-ARRY2(4)

  IF(SCL) ARRY2(2:4)=0.0D0

  RTMP=ABS(MU_IN/(MUOUT(ITHETA)-MU_IN))
  RTMP1= ALYR(I+1)%TAUT-ALYR(I+1)%TAUB
  RTMP2=EXP(-DABS(RTMP1/MUOUT(ITHETA)))
  LRADA_SNG(ITHETA,I,IPHI)%VRAD(:)=                              &
    RTMP2*LRADA_SNG(ITHETA,I+1,IPHI)%VRAD(:)   + &
     RTMP* EXP(-ABS(ALYR(I+1)%TAUB*SECANT_THETAL_PRSV(I))) *            &
     (1.0D0 - EXP(-RTMP1/RTMP/ABS(MUOUT(ITHETA))))  * ARRY2(:)

ENDDO   !LOOP ATMOSPHERE LAYERS FOR MU>0

ENDIF ! MUOUT(ITHETA) IF

ENDDO   ! LOOP ITHETA
ENDDO  ! LOOP PHI 

END SUBROUTINE SNGL_SCAT_ATMOS_StandAlone

SUBROUTINE FTRUNC_EVAL
USE RTUTILITY, ONLY : PI,MAXLORD,NUMMIEANG,MU_SNG,PM_AO_SNG,NUMMIE,&
                      FTRUNC,ANGLE_TRUNCATION,DELTAM

IMPLICIT NONE

INTEGER :: NUMLORD,IANG,L,NUMANG,IMIE
real*8 :: ANGCUT,MUF,RTMP,COEFF1,COEFF2,COEFF3

! DELTA FIT DIFINITION
real*8,  DIMENSION(:),ALLOCATABLE :: ANG,P11FIT
real*8,DIMENSION(:),ALLOCATABLE :: BETAL_LOCAL

real*8 :: FTRUNCFIT

NUMLORD=MAXLORD

ALLOCATE(BETAL_LOCAL(0:NUMLORD))

DO IMIE=1,NUMMIE

  NUMANG=NUMMIEANG(IMIE)

  ALLOCATE(ANG(NUMANG),P11FIT(NUMANG))
  DO IANG=1,NUMANG
     ANG(IANG)=ACOS(MU_SNG(IMIE,IANG))/PI*180.0d0
     P11FIT(IANG)=PM_AO_SNG(IMIE,IANG)%PHMX(1,1)
  ENDDO

  ANGCUT=COS(ANGLE_TRUNCATION/180.0D0*PI)

  BETAL_LOCAL=0.0D0
  call bfit(NUMLORD,NUMANG,ANG,P11FIT,ANGCUT,BETAL_LOCAL,FTRUNCFIT,DELTAM)

  IF(IMIE<NUMMIE+1) FTRUNC(IMIE)=FTRUNCFIT

  DEALLOCATE(ANG,P11FIT)

ENDDO  ! NUMMIE DO
DEALLOCATE(BETAL_LOCAL)
END SUBROUTINE FTRUNC_EVAL

